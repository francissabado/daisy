////////////////////////////////////////////////////
// Owner: austriamicrosystems AG                  //
//        Business Unit Silicon Foundry           //
//================================================//
//        HIT-Kit: Digital                        //
////////////////////////////////////////////////////
//################################################################################
//                     c a c 3 5 b 4 e s d . m 4   
//################################################################################
// last modified : 9-May--2007  15:00
//################################################################################
//   CALIBRE technology file for cal_esdcheck only for process c35xx
//-------------------------------------------------------------------------------
//     rev     date            by                      comment
//-------------------------------------------------------------------------------
//    1.00  17-Sep-2003       aob                   basic version  
//          15-Nov-2004       aob                   groups added  , g01dn improved
//                                                  pnpvert10 false diode removed
//          19-Nov-2004       aob                   G01DN fixed (false err ndriver 
//                                                  modified), bondpad size = 69x69
//                                                  (rsp) 
//          22-Nov-2004       aob                   G01DB improved
//          10-May-2006       aob                   E11SN fixed
//          17-May-2006       aob                   latchup checks cxq included
//          18-May-2006       aob                   SCR spacing 15 and LAT3 =20
//           2-Jun-2006       aob                   latchup : diff is all diff, also
//                                                  diff not touching gate
//                                                  (ALLDIFF flag)
//          17-Aug-2006       aob                   remove polynet
//          16-Nov-2006       aob                   polynet finished  
//
//           9-Jan-2007       aob                  - add rpoly1/2/h rblock, change rdiffp RS
//                                                   (was 100, is 115) ...ok
//                                                 - check for min width of rblock connected to pad
//                                                   (rpoly1/rpoly2/rpolyh/rdiffp)... ok
//                                                 - remove snap ELEMENT checks .. INFO only
//                                                     (snap is illegal ...ok
//                                                     g02ct/g03ct ?? realted to snap
//                                                 - g01p1, g01p2 ..poly on pad deleted ...ok
//                                                 - lv_ndriver : update
//                                                                E08M1 missing
//                                                   add check if 200 U spacing to pad ... same pad
//                                                 - lv_pdriver :
//                                                        E08M2 missing
//                                                   add check  200 U spacing to pad ... same pad
//                                                 - gc_nmos/gc_pmos...check for 1.4 k
//                                                 - forward .. not checked
//                                                 - add gc_nmosm, gc_pmosm info ...ok
//----------------------------------------------------------------------------------------------------
//                                                 - path check for n/p diodes to gnd/vss pad .... 1. version for m2/m3/m4
//                                                   via count and density checks ...... 1. version for m2/m3/m4
//                                                  ATTENTION : fourmetal define not consistant
//
//                                                 - E01D1 merge err, G02CT merge err
//                                                 - check for diode layer on forward 
//
//                                                 - CLAMP recognition and Element checks 
//                                                 - add cmim : also for c35b4 .... not ok
//
//----------------------------------------------------------------------------------------------------
//                                                 - path check for gc_nmos/gc_pmos to gnd/vss pad .... 1. version for m2/m3/m4
//                                                   via count and density checks ...... 1. version for m2/m3/m4
//
//                                                  - improve via density checks , close slot, only > 30
//                                                   forward : add check if 200 U spacing to pad ... same pad
//                                                   All checks snaps are Info, SNAP device is error
//                                                   old bus rules miss snap disabled
//                                                   met bus debug : GET_MET
//                                                   add INNER area < 1000 constraint for slot closing
//          25-Jan-2007       aob                    improve met extract for forw diode
//           9-May-2007       aob                    SPAC_NDIFF_2_NTUB_G01DN false err fixed
// 
//################################################################################
//
// get all met1/2/3/4 connected to n/p diode or gc/nmos/pmos to pad
//
#UNDEFINE GET_MET_DI_PATH
#UNDEFINE GET_MET_GC_PATH
//
///////////////////////////////////////////////////////////////////////
//
//   C A L I B R E  R U L E   F I L E  S T A N D A R D   H E A D E R
//
///////////////////////////////////////////////////////////////////////
// DRC/LVS/PEX header for process c35b4 : last modified    21-Aug-2003
////////////////////////////////////////////////////////////////////////////////////
//
//               Define options for stand alone environment 
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
//               I n p u t   d a t a   d e f i n i t i o n s
//
////////////////////////////////////////////////////////////////////////////////////
//
//  layout
//--------------
   LAYOUT SYSTEM GDSII

   LAYOUT PATH  "_GDSFILE()"
   LAYOUT PRIMARY "_LAYTOPCELL()"
                                                                                                                                                        
   LAYOUT ERROR ON INPUT YES  // NO
//
   LAYOUT DEPTH ALL // PRIMARY
//
//
// MASK SVDB DIRECTORY "svdb" XCALIBRE
// MASK SVDB DIRECTORY "svdb" QUERY
//
// check GDSII and terminate
// LAYOUT ERROR ON INPUT YES  // no
// only for SPICE netlist : node , subckt, model
// default is no
// LAYOUT CASE NO // YES 
// LAYOUT INJECTION FACTOR 4
// cut all outside
// LAYOUT WINDEL xlow ylow xhigh yhigh LAYOUT WINDOW CLIP YES
// get all inside
// LAYOUT WINDOW xlow ylow xhigh yhigh LAYOUT WINDOW CLIP YES
//
// EXCLUDE CELL name1 name2 name3
// LAYOUT SYSTEM CNET 
// LAYOUT PATH  "./cnet.l"
//
//  drc
//--------------
//
   DRC SUMMARY REPORT "_LAYTOPCELL()_esd.rpt" REPLACE HIER
   DRC RESULTS DATABASE "_LAYTOPCELL()_esd.asc" ASCII
//
// DRC TOLERANCE FACTOR .01
// gds allows 200 vertices
// DRC MAXIMUM VERTEX 199
   DRC MAXIMUM VERTEX 20
//   DRC MAXIMUM RESULTS 10000
   DRC MAXIMUM RESULTS ALL   
   DRC KEEP EMPTY NO
// DRC CHECK MAP width_diffusion 30                 
// DRC CHECK MAP spacing_diffusion 30                 
// FLAG ACUTE YES
// FLAG SKEW YES
// FLAG OFFGRID YES
//
// netlist for lvs
//-------------------
//
// SOURCE CASE NO // YES
//
// SOURCE PATH "netlist.hspi"
// SOURCE PRIMARY "netlist_top"
// SOURCE SYSTEM SPICE
//
////////////////////////////////////////////////////////////////////////////////////
//
//   L V S   o p t i o n s                
//
////////////////////////////////////////////////////////////////////////////////////
//
// substrate and bulk pins have little importance for comparison
// soft does not mean "soft connected"
// creates extra report section
   LVS SOFT SUBSTRATE PINS YES // NO
// 
// write netlist from layout and source before gate building with
// device and net coordinates
//
// LVS WRITE LAYOUT NETLIST "layout.spi"
// LVS WRITE SOURCE NETLIST "source.spi"
//
// LVS ISOLATE SHORTS YES BY LAYER     
// for hierarchical lvs use cell and name option :
//
// shorts in top level cell between all names OR between
// the specified names in all cells
// LVS ISOLATE SHORTS YES CELL PRIMARY || NAME "VCC?" "VSS?"
//
// shorts in all cells only between spicified names
// LVS ISOLATE SHORTS YES CELL ALL && NAME "VCC?" "VSS?"
//
// primary only between all names (default)
// LVS ISOLATE SHORTS YES CELL PRIMARY
//
// all shorts in all cells
// LVS ISOLATE SHORTS YES CELL ALL    
//
// rename layout text on GDSII with regex 
// LAYOUT RENAME TEXT #VDD_BANG#VDD#g
// LAYOUT RENAME TEXT #gnd_bang#VSS#g
//
   LVS REPORT ICP_lvs.rpt
// report all
   LVS REPORT MAXIMUM ALL
// reduce info generally, LVS tries to report the most informative discrepancies first 
// LVS REPORT MAXIMUM 50
// options may cause large output
// options : A .... detailed instance connections on incorrect nets (no shorts and opens)
//           B .... detailed instance connections on short and opens
//           C .... detailed instance connections on missing net and no similar net
//           D .... detailed instance connections on missing instance and missing gate
//           E .... ignore missing properties
//           F .... disable missing smashed mosfet
//           G .....report detailed instance connections
//           H .....disable cell correspondence names
//           I .....disable isolated nets warning
//           N .....report layout names missing in source
//           V .....report virtuell connect
//
//  LVS REPORT OPTION A B C D
//
// LVS COMPARE CASE NO // default, all comparisons are case INsensitive
// LVS COMPARE CASE YES // all comparison are case sensitive
// LVS COMPARE CASE NAMES  // net instance and port names
// LVS COMPARE CASE TYPES // component type comparison is case sensitive
// LVS COMPARE CASE SUBTYPES // component subtype comparisons are case sensitive
//
// remove empty cell from SPICE and/or layout
// LVS BOX SOURCE calla cellb cellc
// LVS BOX cella cellb cellc
//
   LVS IGNORE PORTS YES //NO
   LVS REDUCE SERIES RESISTORS no
   LVS REDUCE PARALLEL RESISTORS no
   LVS ISOLATE SHORTS YES BY LAYER
// LVS ISOLATE SHORTS YES
// MASK RESULTS DATABASE "maskdb"
   MASK RESULTS DATABASE NONE
//
// LVS FILTER D OPEN  // remove diodes from check
// LVS FILTER mp  w > 3 < 5 OPEN LAYOUT
// LVS FILTER C OPEN  // remove C from check
// LVS FILTER r(x) instapr(r) ==0 SHORT SOURCE // short all 0 res in SPICE
//
// LVS FILTER UNUSED MOS NO
// LVS FILTER UNUSED DIODES NO
// LVS FILTER UNUSED CAPACITORS NO
// LVS FILTER UNUSED BIPOLAR YES
// LVS FILTER UNUSED OPTION AB AC AD AE B C D ZD 
// 20 options, see manual
//  ab ... filter mos devices with source,drain,and gate pims tied together
//  ac ... filter mos devices with floating gate pin and source,drain pins tied to power
//
// LVS FILTER NAND3 OPEN SOURCE LAYOUT
//
// How to short 2 nets in netlist :
// add line in netlist : R net1 net2 $.MODEL=rshort $w=1 $l=1
   LVS FILTER R(RP) SHORT
   LVS FILTER R(RESISTOR) SHORT
   LVS FILTER C(CP) OPEN
//
// abort if any problem with power/ground
// LVS ABORT ON SUPPLY ERROR YES
// for logic gate recognition, filtering
// attention : if set, gate building is CMOS, this may be an advantage for digital circuits
//             names must match on layout and source sides
//
   LVS POWER NAME "?VCC?" "?VDD?"
   LVS GROUND NAME "?VSS?" "?GND?"
//
// drop mismatch in pin count
   LVS DISCARD PINS BY DEVICE YES
//
//
// LVS ALL CAPACITOR PINS SWAPPABLE YES/NO
// LVS REDUCE PARALLEL MOS YES/NO  // default YES
// LVS REDUCE SPLIT GATES YES/NO
// LVS REDUCE SPLIT GATES SEMI ALSO
// LVS REDUCE PARALLEL BIPOLAR YES/NO  // default YES
// LVS REDUCE SERIES CAPACITORS YES/NO // default YES
// LVS REDUCE PARALLEL CAPACITORS YES/NO // default YES
// LVS REDUCE SERIES RESISTORS YES/NO // defaul YES
// LVS REDUCE PARALLEL RESISTORS YES/NO  // default YES
// LVS REDUCE PARALLEL DIODES YES/NO // default YES
//
// creates AOI and OAI and seriell/parallel SPxxx structures
// ALL    : lvs_recognice_gates = TRUE
//          lvs_recognice_simple_gates = FALSE
// SIMPLE : lvs_recognice_gates = TRUE
//          lvs_recognice_simple_gates = TRUE
// NONE   : lvs_recognice_gates = FALSE
//          lvs_recognice_simple_gates = FALSE
// 
// LVS RECOGNIZE GATES ALL/SIMPLE/NONE  // default is all
// build gates with different model names 
// LVS RECOGNIZE GATES ALL/SIMPLE/NONE MIX SUBTYPES // default is all
//
// LVS COMPONENT TYPE PROPERTY lvs_device spicemodel
// LVS COMPONENT SUBTYPE PROPERTY mdl_prim
// LVS PIN NAME PROPERTY phy_pin
// LVS HEAP DIRECTORY /scratch/tmp   // limit is 2 Gb
// LVS PROPERTY RESOLUTION MAXIMUM 200 // max size of ambiguity groups
// LVS PROPERTY RESOLUTION MAXIMUM ALL // max size of ambiguity groups
// for LVS neighborhood
// LVS SIGNATURE MAXIMUM 10 // see doc
// LVS SIGNATURE MAXIMUM ALL
// LVS SPLIT GATE RATIO MP W 10   // see doc
// LVS REVERSE WL YES // see doc
//
// connect nets by colon :
//  only nets with colon are connected
//  text after colon is stripped off
//  bar: bar:x bar:abc are connected  to bar
//  xyz and zyz: are not connected
//  vdd: and vdd: are connected
//  xyz: in layout and zyz in schem are initial correspondence points
// VIRTUAL CONNECT COLON YES
//
// example : 4 nets :  vss vss vss: vss:x 
// VIRTUAL CONNECT COLON NO  
// VIRTUAL CONNECT NAME "VSS"  // vss: and vss:x stay
// VIRTUAL CONNECT COLON YES 
// VIRTUAL CONNECT NAME "VSS"  // 4 nets connected
// VIRTUAL CONNECT NAME "VSS" "VDD" "VSSA" "VDDA" "vdd_bang" "gnd_bang"
//
// connect all equal names and report 
   VIRTUAL CONNECT NAME '?'
   VIRTUAL CONNECT REPORT YES
// 
// lvs device parameters
//-----------------------
//
// check for 1 %
//
// mos
   TRACE PROPERTY mn W W 1
   TRACE PROPERTY mp W W 1
   TRACE PROPERTY mn L L 1
   TRACE PROPERTY mp L L 1
//
   TRACE PROPERTY m(cvar) W W 1 // IC-Station
   TRACE PROPERTY m(cvar) L L 1 // IC-Station
//
   TRACE PROPERTY lddn W W 1
   TRACE PROPERTY lddn L L 1
// TRACE PROPERTY lddp W W 1
// TRACE PROPERTY lddp L L 1
// resistors
   TRACE PROPERTY r  W W 1
   TRACE PROPERTY r  L L 1
// bipolar
// IC_Station :TRACE PROPERTY Q(pnplat2) a a 1  
   TRACE PROPERTY Q(pnplat) a a 1  
   TRACE PROPERTY Q(pnpvert10) a a 1  
// jfet
// TRACE PROPERTY J(njfet4) w w 1  
// TRACE PROPERTY J(njfet4) l l 1  
// cap
   TRACE PROPERTY C a a  1  
   TRACE PROPERTY C p p  1  
//
   TRACE PROPERTY D a a 1
//
// TRACE PROPERTY r r r 10
// TRACE PROPERTY r r r 5
// TRACE PROPERTY r r r 0.5
// TRACE PROPERTY r r r 0.01
// TRACE PROPERTY c c c 2
//
////////////////////////////////////////////////////////////////////////////////////
//
//   N e t l i s t   e x t r a c t i o n
//
////////////////////////////////////////////////////////////////////////////////////
//
// netlist and parasitic extraction for XCALIBRE-H
//-------------------------------------------------
// attention : exclude supply nets, use correct supply nets
//
//  PEX FDB thnets GLOBAL 10000  EXCLUDE LAYOUT VDD VSS GND vdd_bang gnd_bang
//
// reduce geometries of nearbody caps to speed up run and reduce disk space
//  PEX LAYER routingpoly_bias WINDOW 2.0 
//  PEX LAYER met1_bias WINDOW 2.0 
//  PEX LAYER met2_bias WINDOW 2.0 
//  PEX LAYER met3_bias WINDOW 2.0 
//
// extract simple netlist 
//------------------------
//      output : SPICE LSIM
//   PEX NETLIST SIMPLE ICP_netout.spi SPICE LAYOUT
// PEX NETLIST SIMPLE "netout.spi" HSPICE LAYOUT
// PEX NETLIST SIMPLE "netout.spi" SPICE SOURCE
// PEX NETLIST SIMPLE "netout.spi" SPICE SOURCE LOCATION SEPARATOR "_" MAXLENGTH 20
//
// PEX BACKANNOTATION SIMPLE "ascii.ba" ASCII
   PEX BACKANNOTATION SIMPLE NONE
   PEX BACKANNOTATION LUMPED NONE
   PEX BACKANNOTATION DISTRIBUTED NONE
//
// extract lumped netlist :
//--------------------------
//   PEX NETLIST LUMPED "netout_lumped.spi" SPICE LAYOUT MASK
//   PEX NETLIST LUMPED "netout_lumped.spi" HSPICE LAYOUT MASK
//     extract lumped netlist with source names :
//     ground vss : ground node, if not given :0 
//     location : device loc as comment
//     separator : net name hierarchy, default is / 
//     output  : SPICE , LSIM
//     maxlength : MAXLENGTH number : replace long names
// PEX NETLIST LUMPED "netout_lumped.spi" SPICE SOURCE GROUND VSS SEPARATOR "_" LOCATION MASK
//     lump all caps (crossover, nearbody) to ground
// PEX REDUCE LUMPED C < 100000
// PEX REPORT LUMPED "pexrep_lumped.spi" LAYOUT 
   PEX REPORT LUMPED NONE
//     only for this nets, must be layout names
//   PEX INCLUDE LUMPED net1 net2 net3 
//     remove nets
   PEX EXCLUDE LUMPED VDD VSS        
//
// extract distributed netlist :
//------------------------------
//     location : rlocation = res loc 
//     loop : do not suppress parallel branches
//     source : LAYOUT SOURCE  output  : SPICE SPF SPEF LSIM
// PEX NETLIST DISTRIBUTED "netout_distr.spi" SPICE LAYOUT MASK
//   PEX NETLIST DISTRIBUTED "netout_distr.spi" SPICE SOURCE GROUND VSS LOOP LOCATION RLOCATION    SEPARATOR "/"   MASK
   PEX REPORT DISTRIBUTED NONE
//     remove res < value (ohm)
// PEX REDUCE DISTRIBUTED R 5 BRANCH
//    R, D, C  : res, delay, cap : set thresholds constrains on RC - nets
// PEX THRESHOLD R < 10 C < 10
//     pex report distributed is very large : source = LAYOUT SOURCE type = ASII LSIM SDF 
// PEX REPORT DISTRIBUTED "pexrep_distr.spi" ASCII LAYOUT 
// PEX REPORT DISTRIBUTED "pexrep_distr.spi" ASCII SOURCE 
// PEX REPORT DISTRIBUTED "pexrep_distr.spi" SDF SOURCE    
//     only for this nets, must be layout names
//   PEX INCLUDE DISTRIBUTED net1 net2 net3 
//     remove nets
   PEX EXCLUDE DISTRIBUTED VDD VSS        
//
// PEX COUPLED DISTRIBUTED YES/NO
// PEX DELAY PENFIELD 0.7
// PEX DELAY ELMORE 0.7
// PEX DELAY NONE        
//
////////////////////////////////////////////////////////////////////////////////////
//
//   T e x t   d e f i n i t i o n
//
////////////////////////////////////////////////////////////////////////////////////
//
// define free floating text used from gds2 database
// attention : for soft checking you have to use the same layer number
// for EXPAND TEXT !!!!
//
//  TEXT LAYER 59          
//  text_vdd = (EXPAND TEXT ?VDD? 59 BY 0.1) OR (EXPAND TEXT ?VCC? 59 BY 0.1)
//  text_vss = (EXPAND TEXT ?VSS? 59 BY 0.1) OR (EXPAND TEXT ?GND? 59 BY 0.1)
//  LABEL ORDER MET3 MET2 MET1
//
// ATTACH 59 MET1 MASK
// ATTACH 59 MET2 MASK
// ATTACH 59 MET3 MASK
// 
// define text directly in rule file :
//
//      name                       x (u)        y(U)     layer number (35=met1,37=met2)
//
// text A1                        137.000      121.400   35                    
// text AA                         75.800       67.600   35                    
// text VDDA                       51.200       95.400   35                    
// text VDDA                      100.000      220.800   35                    
// text VDDA                      141.200      306.600   35                    
// text VDDH                      180.800      381.200   35                    
// text VSS                        98.200      309.200   35                    
// text VSS                       166.600       -7.800   35                    
// text VSS                       180.600      390.800   35                    
// text VSS                       293.200      131.400   35                    
//
// include path
// INCLUDE "textfile"
//
// read text from ports
//
// cell number 3 name : BU4
//
//   LAYOUT TEXT A 1.15 16.95 137  BU4
//   LAYOUT TEXT Q 5.75 20.45 137  BU4
//
// cell number 4 name : IN4
//
//   LAYOUT TEXT Q 1.15 16.75 137  IN4
//   LAYOUT TEXT A 5.75 16.75 137  IN4
//
// cell number 5 name : NO2
//
//   LAYOUT TEXT A 1.15 16.55 137  NO2
//   LAYOUT TEXT Q 5.75 16.55 137  NO2
//   LAYOUT TEXT B 3.45 17.65 137  NO2
//
// PORT LAYER TEXT 137
// TEXT LAYER 137
// ATTACH 137 MET2     
// 
///////////////////////////////////////////////////////////////////////
//
//                 end of standard header   
//
///////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////
// Owner: austriamicrosystems AG                  //
//        CONCERTO! Business Unit Silicon Foundry //
//================================================//
//        HIT-Kit: Digital                        //
////////////////////////////////////////////////////
//
   TITLE "DRC for 0.35 U ESD DESIGN RULES Doc ENG-236 REV 2.0 last modified 24-Jan-07"
//
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   DRC INCREMENTAL CONNECT YES
// attention : INCREMENTAL CONNECT
//             connectivity from NAR is lost after next CONNECT 
//>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//
// ATTENTION : flag for definition of processes
//
// use c35b4 4 metal process
//--------------------------
//
// use always four metal
// no problem if used for met3 also
//
#DEFINE fourmetal
// 
// use c35b3 3 metal process
//--------------------------
//
//#UNDEFINE fourmetal
//
//
///////////////////////////////////////////////////////////////////////
//
// CALIBRE  R U L E S   F I L E   F O R   P R O C E S S   C 3 5 
//
//       _rules_title (standalone options)
//
//       Document: ENG-183                      Revision: 3.0
//
//       Created with ams_tech on by 
//
//=====================================================================
//   Version          Datum          by       Description
//---------------------------------------------------------------------
//   1.0           14-Jan-2002       aob      Created
//                                            new layer table with
//                                            datatypes/texttypes
//                  6-Feb-2002       aob      bipolar added
//                 22-Feb-2002       aob      port layer text for padpin added
//                  5-Apr-2002       aob      layer definition extend
//                 10-Apr-2002       aob      routingmetal added
//                  2-May-2002       aob      mxnet layer number fixed
//                 12-Jun-2002       aob      layer definition for generated 
//                                            layers extended
//                  5-Jul-2002       aob      text_vdd/vss for ERC modified
//                  2-Aug-2002       aob      layer mapping changed due to
//                                            IC station numbers
//                                            61 = 600, 62 = 700, 63 = 800
//                 20-Aug-2002       aob      primary only for EXPAND txt for ERC
//                 22-Aug-2002       aob      layout:reduced needs text type map
//                                            resdef_text added
//                 27-Sep-2002       aob      inddef_text added
//                 18-Nov-2002       aob      m1pinshape added to mask out floating net
//                  6-Mar-2003       aob      attach met1 routingmet1 ...added
//                 12-Mar-2003       aob      direct connects added
//                 19-May-2003       aob      layer map inddef text to 722
//                 
///////////////////////////////////////////////////////////////////////

// List of layers that are defined for the c35 process:
// These layers are original layers with reserved names that can't be
// changed !
// Use the layer number definition for rule file use in standalone mode
//
// Trench isolation layer
   LAYER TRENCH 3
//
// NTUB ... ntub mask (nwell)
   LAYER NTUB 5
// PTUB ... ptub in ntub mask (pwell)
   LAYER PTUB 7
// DIFF ... field mask (diffusion)
   LAYER DIFF 10
// MIDOX 
   LAYER MIDOX 14
// POLY1 ... poly1 mask
   LAYER POLY1 20
// NPLUS ... n+ implant mask
   LAYER NPLUS 23
// PPLUS ... p+ implant mask
   LAYER PPLUS 24
// HRES ... high resistive mask
   LAYER HRES 29
// POLY2 ... poly2 mask
   LAYER POLY2 30
// CONT ... contact mask
   LAYER CONT 34
// MET1 ... metal1 mask
   LAYER MET1 35
// VIA ... via mask
   LAYER VIA 36
// MET2 ... metal2 mask
   LAYER MET2 37
// VIA2 ... via2 mask
   LAYER VIA2 38
// MET3 ... metal3 mask
   LAYER MET3 39
// PAD ... pad mask
   LAYER PAD 40
//===============================
//
   LAYER ESD  31
   LAYER SALEX 32
//
// met4
//-------
#IFDEF fourmetal
   LAYER VIA3 41
   LAYER MET4 42
#ENDIF
//
// generated layers
//
// FIMP ... field implant mask
   LAYER FIMP 8
// standard nldd implant
   LAYER NLDD 21
// 5 Volt nldd implant
   LAYER NLDD50 53
//
   LAYER MAP 35 DATATYPE 1 201
   LAYER M1HOLE 201 
//
   LAYER MAP 37 DATATYPE 1 202
   LAYER M2HOLE 202 
//
   LAYER MAP 39 DATATYPE 1 203
   LAYER M3HOLE 203 
//
#IFDEF fourmetal
   LAYER MAP 42 DATATYPE 1 204
   LAYER M4HOLE 204 
#ENDIF
//
// bipolar layers
//-------------------
//
// n+ buried layer
   LAYER NBUR 1
// p+ buried layer
   LAYER PBUDEF  2
// bipolar ntub
   LAYER BNTUB 15
// p+ base poly layer
   LAYER BPOLY 28
// emitter layer
   LAYER EMITT 26
// collector layer
   LAYER COLL  11  
// bipolar hbt open mask
   LAYER HBT 25
// capacitor layer
   LAYER CAPLAY 27
// emitter poly
   LAYER EPOLY 33
// metal cap definition
   LAYER METCAP	55
// 
// definition layers
//--------------------
//
// cell box outline
   LAYER MAP 62 DATATYPE 1  701
   LAYER CELBOX  701 
// standard family cell definition
   LAYER MAP 62 DATATYPE 2  702
   LAYER SFCDEF  702 
// GND substrate definition layer
   LAYER MAP 62 DATATYPE 3  703
   LAYER SUBDEF  703
// hottub definition layer
   LAYER MAP 62 DATATYPE 4  704
   LAYER HOTTUB  704
// nofill with fill pattern
   LAYER MAP 62 DATATYPE 5  705
   LAYER NOFILL  705
//
//
// zener diode
   LAYER MAP 62 DATATYPE 10  710
   LAYER ZENER  710
// diode
   LAYER MAP 62 DATATYPE 11  711
   LAYER DIODE  711
// ntub resistor definition
   LAYER MAP 62 DATATYPE 12  712
   LAYER TUBDEF  712
// resistor definition
   LAYER MAP 62 DATATYPE 13  713
   LAYER RESDEF  713
// resistor terminal
   LAYER MAP 62 DATATYPE 14  714
   LAYER RESTRM  714
// sandwich cap definition
   LAYER MAP 62 DATATYPE 20  720
   LAYER CAPDEF  720
// varactor definition layer
   LAYER MAP 62 DATATYPE 21  721
   LAYER VARDUM  721
// Inductor definition layer
   LAYER MAP 62 DATATYPE 22  722
   LAYER INDDEF  722
// hall definition layer
   LAYER MAP 62 DATATYPE 24  724
   LAYER HALLDEF  724
// diffusion cut
   LAYER MAP 62 DATATYPE 30  730
   LAYER DIFCUT  730
// poly1 cut
   LAYER MAP 62 DATATYPE 31  731
   LAYER PO1CUT  731
// poly2 cut
   LAYER MAP 62 DATATYPE 32  732
   LAYER PO2CUT  732
// base poly cut
   LAYER MAP 62 DATATYPE 33  733
   LAYER BPCUT  733
// tub cut
   LAYER MAP 62 DATATYPE 34  734
   LAYER TUBCUT  734
//
// text layer       
//-------------
//
   LAYER MAP 61 TEXTTYPE 1  601
   LAYER P1PIN  601
//
// GDT debug
//
   //LAYER MAP 60 TEXTTYPE 0  602
//
   LAYER MAP 61 TEXTTYPE 2  602
   LAYER M1PIN  602
   TEXT LAYER M1PIN
   PORT LAYER TEXT M1PIN
   ATTACH M1PIN routingmet1 MASK
   ATTACH M1PIN MET1 DIRECT
//
   LAYER MAP 61 TEXTTYPE 3  603
   LAYER M2PIN  603
   TEXT LAYER M2PIN
   PORT LAYER TEXT M2PIN
   ATTACH M2PIN routingmet2 MASK
   ATTACH M2PIN MET2 DIRECT     
//
   LAYER MAP 61 TEXTTYPE 4  604
   LAYER M3PIN  604
   TEXT LAYER M3PIN
   PORT LAYER TEXT M3PIN
   ATTACH M3PIN routingmet3 MASK
   ATTACH M3PIN MET3 DIRECT
//
   LAYER MAP 61 TEXTTYPE 10  610
   LAYER PADPIN  610
   PORT LAYER TEXT PADPIN
   TEXT LAYER PADPIN
//
#IFDEF fourmetal
// 4 metal attach to met4
   LAYER MAP 61 TEXTTYPE 5  605
   LAYER M4PIN  605
   TEXT LAYER M4PIN
   PORT LAYER TEXT M4PIN
   ATTACH M4PIN routingmet4 MASK
   ATTACH PADPIN routingmet4 MASK
   ATTACH M4PIN MET4 DIRECT     
   ATTACH PADPIN MET4 DIRECT     
#ELSE
// 3 metal attach to met3
   ATTACH PADPIN routingmet3 MASK
   ATTACH PADPIN MET3 DIRECT      
#ENDIF
//
// this is used for soft checks ERC
// make sure only text on top cell is used to avoid any problems with text in cell
//
//
// VDD net (vdd,vcc)
//-------------------
// used for ESD
//
// add optional text info if necessary ( top level)
//
//  LAYOUT TEXT VDD 259 54 M1PIN Test_CHECKER
//
//
   text_vdd_a = (EXPAND TEXT "?VDD?" M1PIN  BY 0.1 PRIMARY ONLY) OR
                (EXPAND TEXT "?VCC?" M1PIN  BY 0.1 PRIMARY ONLY)
   text_vdd_b = (EXPAND TEXT "?VDD?" M2PIN  BY 0.1 PRIMARY ONLY) OR
                (EXPAND TEXT "?VCC?" M2PIN  BY 0.1 PRIMARY ONLY)
   text_vdd_c = (EXPAND TEXT "?VDD?" M3PIN  BY 0.1 PRIMARY ONLY) OR
                (EXPAND TEXT "?VCC?" M3PIN  BY 0.1 PRIMARY ONLY)
   text_vdd_e = (EXPAND TEXT "?VDD?" PADPIN  BY 0.1 PRIMARY ONLY) OR
                (EXPAND TEXT "?VCC?" PADPIN  BY 0.1 PRIMARY ONLY)
   text_vdd_f = (EXPAND TEXT "?vdd?" PADPIN  BY 0.1 PRIMARY ONLY) OR
                (EXPAND TEXT "?vcc?" PADPIN  BY 0.1 PRIMARY ONLY)
   text_vdd1 =  text_vdd_e OR ((text_vdd_a OR text_vdd_f) OR (text_vdd_b  OR  text_vdd_c ))
#IFDEF fourmetal
   text_vdd_d = (EXPAND TEXT "?VDD?" M4PIN  BY 0.1 PRIMARY ONLY) OR
                (EXPAND TEXT "?VCC?" M4PIN  BY 0.1 PRIMARY ONLY)
   text_vdd  =  text_vdd1 OR text_vdd_d
#ELSE
   text_vdd  =  COPY text_vdd1
#ENDIF
//
//
// VSS (vss,gnd,vee,no agnd)
//----------------------------
// currently not used for ESD
//
   text_vss_a = (EXPAND TEXT "?VSS?" M1PIN  BY 0.1 PRIMARY ONLY) OR
                ((EXPAND TEXT "?GND?" M1PIN  BY 0.1 PRIMARY ONLY) OR
                (EXPAND TEXT "?VEE?" M1PIN  BY 0.1 PRIMARY ONLY))
   text_vss_b = (EXPAND TEXT "?VSS?" M2PIN  BY 0.1 PRIMARY ONLY) OR
                ((EXPAND TEXT "?GND?" M2PIN  BY 0.1 PRIMARY ONLY) OR
                (EXPAND TEXT "?VEE?" M2PIN  BY 0.1 PRIMARY ONLY))
   text_vss_c = (EXPAND TEXT "?VSS?" M3PIN  BY 0.1 PRIMARY ONLY) OR
                ((EXPAND TEXT "?GND?" M3PIN  BY 0.1 PRIMARY ONLY) OR
                (EXPAND TEXT "?VEE?" M3PIN  BY 0.1 PRIMARY ONLY))
   text_vss_e = (EXPAND TEXT "?VSS?" PADPIN  BY 0.1 PRIMARY ONLY) OR
                ((EXPAND TEXT "?GND?" PADPIN  BY 0.1 PRIMARY ONLY) OR
                (EXPAND TEXT "?VEE?" PADPIN  BY 0.1 PRIMARY ONLY))
   text_vss_f = (EXPAND TEXT "?vss?" PADPIN  BY 0.1 PRIMARY ONLY) OR
                ((EXPAND TEXT "?gnd?" PADPIN  BY 0.1 PRIMARY ONLY) OR
                (EXPAND TEXT "?vee?" PADPIN  BY 0.1 PRIMARY ONLY))
// remove agnd
   text_agnd = (EXPAND TEXT "AGND" M1PIN BY 0.1 PRIMARY ONLY) OR
               ((EXPAND TEXT "AGND" M2PIN BY 0.1 PRIMARY ONLY) OR
               ((EXPAND TEXT "AGND" M3PIN BY 0.1 PRIMARY ONLY) OR
               (EXPAND TEXT "AGND" PADPIN BY 0.1 PRIMARY ONLY)))
   text_vss1 = text_vss_e OR (( text_vss_a OR text_vss_b ) OR (text_vss_c OR  text_vss_f ))
#IFDEF fourmetal
   text_vss_d = (EXPAND TEXT "?VSS?" M4PIN  BY 0.1 PRIMARY ONLY) OR
                ((EXPAND TEXT "?GND?" M4PIN  BY 0.1 PRIMARY ONLY) OR
                (EXPAND TEXT "?VEE?" M4PIN  BY 0.1 PRIMARY ONLY))
   text_vss  = (text_vss_d OR text_vss1) NOT text_agnd
#ELSE
   text_vss  = COPY text_vss1
#ENDIF
//
//
   LAYER MAP 61 TEXTTYPE 21  621
   LAYER P1NET  621
//
   LAYER MAP 61 TEXTTYPE 22  622
   LAYER M1NET  622
   TEXT LAYER M1NET
   ATTACH M1NET routingmet1 MASK
   ATTACH M1NET MET1 DIRECT     
//
   LAYER MAP 61 TEXTTYPE 23  623
   LAYER M2NET  623
   TEXT LAYER M2NET
   ATTACH M2NET routingmet2 MASK
   ATTACH M2NET MET2 DIRECT      
//
   LAYER MAP 61 TEXTTYPE 24  624
   LAYER M3NET  624
   TEXT LAYER M3NET
   ATTACH M3NET routingmet3 MASK
   ATTACH M3NET MET3 DIRECT      
//
#IFDEF fourmetal
   LAYER MAP 61 TEXTTYPE 25  625
   LAYER M4NET  625
   TEXT LAYER M4NET
   ATTACH M4NET routingmet4 MASK
   ATTACH M4NET MET4 DIRECT     
#ENDIF
//
   LAYER MAP 61 TEXTTYPE 30  630
   LAYER PADNET  630
   LAYER MAP 61 TEXTTYPE 31  631
   LAYER COMMEN  631
//
   LAYER MAP 63 TEXTTYPE 1  801
   LAYER CESIG1  801
   LAYER MAP 63 TEXTTYPE 2  802
   LAYER CESIG2  802
   LAYER MAP 63 TEXTTYPE 3  803
   LAYER CESIG3  803
   LAYER MAP 63 TEXTTYPE 4  804
   LAYER CESIG4  804
//
   LAYER MAP 63 TEXTTYPE 21  821
   LAYER CEPWR1  821
   LAYER MAP 63 TEXTTYPE 22  822
   LAYER CEPWR2  822
   LAYER MAP 63 TEXTTYPE 23  823
   LAYER CEPWR3  823
   LAYER MAP 63 TEXTTYPE 24  824
   LAYER CEPWR4  824
//
   LAYER MAP 62 TEXTTYPE 13  913
   LAYER RESDEF_TEXT  913
//
// for spiral recognition
// Inductor definition layer
//
   LAYER MAP 62 TEXTTYPE 22  722
   LAYER INDDEF_TEXT  722
//
// for hall definition
   LAYER MAP 62 TEXTTYPE 24  724
   LAYER HALLDEF_TEXT  724
//
// mask out floating met1 
   LAYER MAP 61 DATATYPE 2  923
   LAYER M1PINSHAPE 923
//
//
   ATTACH MET1 routingmet1 MASK //ghe
   ATTACH MET2 routingmet2 MASK //ghe
   ATTACH MET3 routingmet3 MASK //ghe
#IFDEF fourmetal
   ATTACH MET4 routingmet4 MASK //ghe
#ENDIF
//
// for text debugging use following DRC :
//
// check if any text is on mapped textype
//
// M1PIN_TEXT  { EXPAND TEXT "?" M1PIN BY 0.1  }
// M2PIN_TEXT  { EXPAND TEXT "?" M2PIN BY 0.1  }
// M3PIN_TEXT  { EXPAND TEXT "?" M3PIN BY 0.1  }
// PADPIN_TEXT { EXPAND TEXT "?" PADPIN BY 0.1 }
//
// M3PIN_VDD { EXPAND TEXT "VDD" M3PIN BY 0.1 }
// NWELL_VDD { NET routingnwell "VDD" }
// M3PINP_VDD { routingmet3 WITH TEXT "VDD" M3PIN }
//
///////////////////////////////////////////////////////////////////////
////////////////////////////////////
// Owner: Austria Mikro Systeme   //
// HIT-Kit: Digital               //
////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//
//   CALIBRE  R U L E S  F I L E  F O R  P R O C E S S  C 3 5
//
//       _rules_title
//
//       Document: ENG-183                      Revision: 3.0
//
//       Created with ams_tech on by 
//
//=====================================================================
//   Version          Datum          by       Description
//---------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////
//                 17-Jan-2002       aob      used for c35b4        
//                 28-Jan-2002       aob      rpolyhcon is poly2con
//                                            met4 connectivity added
//                  7-Feb-2002       aob      rpolyh added
//                 19-Feb-2002       aob      cvar added
//                 26-Mar-2002       aob      slot checks added
//                 10-Apr-2002       aob      spirals added
//                                            routingmetal added, 
//                                            connectivity changed
//                 16-Apr-2002       aob      unused parts removed
//                 25-Apr-2002       aob      rpolyh without resdef 
//                                            vert15 removed
//                                            nwd = AND
//                 13-Mai-2002       aob      ndiode/pdiode not s/d diff
//                 21-May-2002       aob      slot check modified for AMC2
//                 24-May-2002       aob      rec017 added
//                                            only slots < 4 U width checked
//                 13-Jun-2002       aob      cvar extract changed
//                 22-Jul-2002       aob      ndiffcon/pdiffcon used   
//                 27-Sep-2002       aob      spirals met3/met4 added
//                 30-Sep-2002       aob      do not allow layer under spiral 
//                 17-Oct-2002       aob      pnpvert10 sizing reduced
//                 13-Jan-2003       aob      aux layer DIFF nmos4/pmos4 changed
//                  6-Mar-2003       aob      nwdiode shield added
//                 11-Mar-2003       aob      trans_shield added
//                 14-May-2003       aob      isolated layout nets LVS spirals
//                                            terminals fixed
//                 16-Jun-2003       aob      hall element added
//                 17-Jun-2003       aob      z diode with 0.2 U impl ovlp only
//                 15-Jul-2003       aob      element rules added, pnplat2 changed
//                                            devswitch added
//                 21-Aug-2003       aob      allow rpoly2 over rnwell
///////////////////////////////////////////////////////////////////////
//
//   Structure of this technology file:
//---------------------------------------------------------------------
//
//   1.) Header and version control
//   2.) ICverify options
//   3.) Boolean operations and derived layers
//   4.) Interconnect section
//     
//       Including files for:
//
//   5.) Device recognition
//   6.) Design rules
//   7.) Parasitic extraction
//   8.) Standalone options
//
///////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////
//
//   Derived Layers are defined to find the following devices
//---------------------------------------------------------------------
//
//   EX 1 - rpoly2, rpolyh, rdiffn, rdiffp, rnwell
//   EX 2 - pnpvert, pnplat2
//   EX 3 - nmosh, nmos4, pmos4
//   EX 4 - cpoly, cvar
//   EX 5 - nd, pd, nwd, zdiode
//
///////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////
//                         ICVERIFY OPTIONS                          //
///////////////////////////////////////////////////////////////////////


   PRECISION 1000
   RESOLUTION 50

   UNIT RESISTANCE ohm
   UNIT CAPACITANCE ff

   DRC TOLERANCE FACTOR 0.005

//=====================================================================

///////////////////////////////////////////////////////////////////////
//                       DEFINE BOOLEAN LAYERS                       //
///////////////////////////////////////////////////////////////////////
//
// write device seed layer to DRC output for debugging
//
// #DEFINE DEVSWITCH
#UNDEFINE DEVSWITCH

#IFDEF fourmetal
   LAYOUT TOP LAYER MET4 VIA3 MET3 VIA2 MET2 VIA MET1
#ELSE
   LAYOUT TOP LAYER MET3 VIA2 MET2 VIA MET1
#ENDIF

//=====================================================================
// create layers to find substrate

// for test purposes
// POLYGON -10.0 -10.0 221.0 240.0 SUBDEF
// cut nwell if subdef edge cuts ntub, but do
// not cut substrate below ntub
// create a small area of subdef

   subdef_ring    = SUBDEF NOT (SIZE SUBDEF BY -0.05)
   substrate_all  = EXTENT

   ntub_subdefcut = NTUB NOT subdef_ring
   substrate      = (substrate_all NOT subdef_ring) OR (subdef_ring AND NTUB)

   psub           = substrate NOT NTUB

//=====================================================================
// remove cut layer areas

   diff_cut         = DIFF NOT DIFCUT
   poly1_cut        = POLY1 NOT PO1CUT
   poly2_cut        = POLY2 NOT PO2CUT


//=====================================================================
// get contacts

// poly1 and poly2 contacts

   poly1_n_poly2    = poly1_cut NOT poly2_cut
   poly1con         = CONT AND poly1_n_poly2
   con_n_p1         = CONT NOT poly1con
   poly2con         = CONT AND poly2_cut   

// other contacts
// rpolyh is poly2
//
   rpolyhcon        = poly2con AND HRES
   diffcon          = CONT AND diff_cut
//
// for ERC
//
   via_cont         = VIA OR CONT
   via2_via         = VIA2 OR VIA
#IFDEF fourmetal
   via3_via2        = VIA3 OR VIA2
#ELSE
   via3_via2        = COPY VIA2
#ENDIF


//=====================================================================
// create layers to find ndiff and pdiff structures

   ndiff_1          = diff_cut AND NPLUS
   pdiff_1          = diff_cut AND PPLUS


//=====================================================================
// EX 1  EX 1  EX 1  EX 1  EX 1  EX 1  EX 1  EX 1  EX 1  EX 1  EX 1  
//=====================================================================
// create layers to find poly2, polyh, ndiff, pdiff and nwell resistors

   poly1_poly2      = POLY1 AND POLY2

// poly1 resistor
                                                                                                                                               
   pres1_1           = (poly1_cut AND RESDEF) NOT HRES
   pres1_2           = pres1_1 NOT poly1_poly2
   pres1             = pres1_2 NOT RESTRM

// poly2 resistor

   pres_1           = (poly2_cut AND RESDEF) NOT HRES
   pres_2           = pres_1 NOT poly1_poly2
   pres             = pres_2 NOT RESTRM

// hrespoly resistor with resdef, no restrm

   presh_1          = poly2_cut AND HRES
// presh            = (presh_1 NOT PPLUS) AND RESDEF
   presh            = presh_1 NOT PPLUS
   preshterm        = presh_1 AND PPLUS

// pdiff resistor
 
   pdres_1          = pdiff_1 AND RESDEF
   pdres_2          = pdres_1 NOT INTERACT pres
   pdres            = pdres_2 NOT RESTRM

// ndiff resistor

   ndres_1          = ndiff_1 AND RESDEF
   ndres_2          = ndres_1 NOT INTERACT pres
   ndres            = ndres_2 NOT RESTRM

// nwell resistor

   nwres_1          = NTUB AND TUBDEF
   nwres_2          = nwres_1 NOT INTERACT pdres
   nwres_3          = nwres_2 NOT INTERACT ndres
   nwres            = nwres_3 NOT RESTRM

#IFDEF DEVSWITCH
  xrpoly2 { COPY pres  }
  xrpolyh { COPY presh }
  xrdiffp { COPY pdres }
  xrdiffn { COPY ndres }
  xrnwell { COPY nwres }
#ENDIF

//=====================================================================
// create layers to find poly1, poly2 and nwell structures not belonging
// to a resistor

   routingpoly      = copy poly1_cut
   routingpoly2_1   = poly2_cut NOT pres
   routingpoly2     = routingpoly2_1 NOT presh
//
// cut ntub if subdef crosses ntub
// remove isolated ntub stripes in spirals 
// and cut nwell in hall element
//
   halldef_cut    = SIZE HALLDEF BY -12.0
   routingnwell  = ((ntub_subdefcut NOT nwres) NOT INDDEF) NOT halldef_cut

//=====================================================================
// create layers to find ndiff and pdiff structures not belonging
// to a resistor or any gate structure

   ndiff_2          = ndiff_1 NOT routingpoly
   ndiff            = ndiff_2 NOT ndres

   pdiff_2          = pdiff_1 NOT routingpoly
   pdiff            = pdiff_2 NOT pdres


//=====================================================================
// create layers to find gate structures of n- and p- low voltage 
// devices and nmosh (NTUB version)

   trans            = diff_cut AND routingpoly
// for XCALI 
   trans_shield     = SIZE trans BY 0.01
   ngate            = trans NOT NTUB
   pgate            = trans AND NTUB
   gate             = ngate OR pgate
   ndev             = ngate AND NPLUS
   pdev             = pgate AND PPLUS


//=====================================================================
// EX 2  EX 2  EX 2  EX 2  EX 2  EX 2  EX 2  EX 2  EX 2  EX 2  EX 2  
//=====================================================================
// create layers to find pnpvert and pnplat2 bipolar transistors

// pnpvert (vert10 - pnp vertical bipolar transistor - 10um * 10um)

   pnpvert_1        = HOLES pdiff < 1000.0
// filter too large holes
   pnpvert_2        = NTUB INSIDE pnpvert_1
   pnpvert_3        = ndiff AND pnpvert_2
   pnpvert_4        = HOLES pnpvert_3
   pnpvert_5        = pdiff INSIDE pnpvert_4
   pnpvert10_e      = PERIMETER pnpvert_5 >39.9 < 40.1
   pnpvert10        = SIZE pnpvert10_e BY 2.0

// pnplat2 (pnp lateral bipolar transistors)
// lat2 has emitter area 2*2
 
   pnplat           = HOLES pdev < 10.0
//
// pnplat2_e        = PERIMETER pnplat >7.95 <8.05
//
// allow poly1 biasing
   pnplat2_e        = PERIMETER pnplat >7.5 <8.05
   pnplat2_c        = (pdiff TOUCH pnplat2_g) NOT pnplat2_e
   pnplat2_g        = pdev TOUCH pnplat2_e

#IFDEF DEVSWITCH
   xpnplat    { COPY pnplat2_e }
   xpnpvert10 { COPY pnpvert10 }
#ENDIF
//=====================================================================
// create layers to find nwells belonging to illegal hv transistors
// illegal is : ntub touches exactly trans
//              ntub ovlp != 1.6

   nwell_ill        = NTUB TOUCH trans 
   nwell_hv_trans   = NTUB CUT trans
   nwell_hvmos_good = INT nwell_hv_trans trans == 1.6 OPPOSITE PARA ONLY REGION
   ill_hvmos_nwell  = nwell_ill OR (nwell_hv_trans NOT INTERACT nwell_hvmos_good)
   nwell_n_hvmos    = NTUB NOT INTERACT nwell_hvmos_good

//=====================================================================
// EX 3  EX 3  EX 3  EX 3  EX 3  EX 3  EX 3  EX 3  EX 3  EX 3  EX 3  
//=====================================================================
// create layers to find mos transistors (pmos, nmos, nmosh)

   routp_n_trans    = routingpoly NOT trans

// pmos transistors
 
   pmos_1           = pdev NOT pnplat2_g
   pmos_2           = pmos_1 TOUCH routp_n_trans
   pmos_3           = pmos_2 TOUCH pdiff == 2
   pmos             = pmos_3 NOT MIDOX
   pmos_midox       = pmos_3 AND MIDOX
//
// nmosh transistors
// check for touching or ovlp of ntub
//
   nmosh_1          = (trans TOUCH NTUB) OR (trans CUT NTUB)
   nmosh            = nmosh_1 INTERACT ndev
// 
// avoid false extract   
   nmoshall         = nmosh_1 AND (trans AND NPLUS)
   nmosh_d          = ndiff AND (NTUB INTERACT nmoshall)
   nmosh_d_fill     = EXT nmosh_d nmosh < 6.00 OPPOSITE PARA ONLY
                      REGION
   nmosh_d_term_1   = nmosh_d OR nmosh_d_fill
   nmosh_d_term     = nmosh_d_term_1 TOUCH nmosh

   nmosh_nomidox    = nmosh NOT INTERACT MIDOX
   nmosmh           = nmosh INTERACT MIDOX
   // nmosmh { COPY nmosmh }
   // nmosh { COPY nmosh_nomidox }

// nmos transistors with and without midox

   nmos_1           = ndev NOT nmosh
   nmos_2           = nmos_1 NOT INTERACT ill_hvmos_nwell
   nmos_3           = nmos_2 TOUCH routp_n_trans
   nmos_4           = nmos_3 TOUCH ndiff == 2
   nmos             = nmos_4 NOT MIDOX
   nmos_midox       = nmos_4 AND MIDOX

#IFDEF DEVSWITCH
   xnmosh { COPY nmosh }
   xnmosmh { COPY nmosmh }
   xnmos { COPY nmos }
   xnmosm { COPY nmos_midox }
   xpmos { COPY pmos }
   xpmosm { COPY pmos_midox }
#ENDIF
//=====================================================================
// EX 4  EX 4  EX 4  EX 4  EX 4  EX 4  EX 4  EX 4  EX 4  EX 4  EX 4  
//=====================================================================
// create layers to find capacitors (poly1-poly2 and cvar)

// poly1-poly2 (cpoly) capacitor

   cpoly_1          = routingpoly NOT HRES
   cpoly            = cpoly_1 AND poly2_cut
#IFDEF DEVSWITCH
  xcpoly  { COPY cpoly }
#ENDIF
//
// cvar device is nmos transistor in nwell arranged in 2 dimensional array
// all diff and poly is connected by metal
//
// one device should be : w = 6.6 l = 0.65  col spacing 1.0 row spacing 1.6
//
// get device element
   cvar_ele = (pgate AND NPLUS) NOT INTERACT nmosh 
// get diff polygon and close gaps
   cvar_ndiff = ndiff_1 ENCLOSE cvar_ele
   cvar_ndiff_gap = EXT cvar_ndiff < 1.8 OPPOSITE PARA ONLY REGION
   cvar_ndiff_closed = cvar_ndiff OR cvar_ndiff_gap
// get poly/ndiff intersections
   cvar_ndiff_cross1 = INSIDE EDGE cvar_ndiff_closed (routingpoly INTERACT cvar_ele)
   cvar_ndiff_cross = EXPAND EDGE cvar_ndiff_cross1  INSIDE BY 0.1
// cvar_ndiff_cross { COPY cvar_ndiff_cross }

   cvar_device_layer = COPY cvar_ndiff_closed
//
#IFDEF DEVSWITCH
   xcvar { COPY cvar_device_layer }
#ENDIF
//=====================================================================
// EX 5  EX 5  EX 5  EX 5  EX 5  EX 5  EX 5  EX 5  EX 5  EX 5  EX 5  
//=====================================================================
// create layers to find diodes
// attention : all diodes are created by AND !!!

// nd (ndiff over substrate, no sd of device)

   ndiode_1       = (ndiff NOT NTUB) NOT INTERACT trans
   ndiode         = ndiode_1 AND DIODE
//   ndiode       = ndiode_2 ENCLOSE ndiode_1

// pd (pdiff over nwell, no sd of device)

   pdiode_1       = (pdiff AND NTUB) NOT INTERACT trans
   pdiode         = pdiode_1 AND DIODE
//   pdiode       = pdiode_2 ENCLOSE pdiode_1

// nwd (nwell over substrate)

   nwdiode        = NTUB AND DIODE
//   nwdiode      = nwdiode_1 ENCLOSE NTUB
   nwdiode_shield   = SIZE nwdiode BY 0.1 //ghe
//
///////////////////////////////////////////////////////////////////////

// zdiode (ndiff interact pdiff not belonging to the same net)

   zdiode_1       = pdiff COINCIDENT OUTSIDE EDGE ndiff
   zdiode_2       = zdiode_1 EXPAND EDGE OUTSIDE BY 0.1
   zdiode_3       = pdiff AND ndiff
   zdiode_4       = zdiode_2 OR zdiode_3
   zdiode_5       = pdiff INTERACT zdiode_4
   zdiode_6       = ndiff INTERACT zdiode_4
   zdiode_7       = zdiode_5 OR zdiode_6
   zdiode_8       = zdiode_7 AND ZENER
   zdiode_9       = zdiode_8 ENCLOSE zdiode_7
   zdiode_all     = zdiode_4 AND zdiode_9

// this are all possibe z diodes, but we allow only 0.2 U ovlp
//
   zdiode_02_1 = INT zdiode_all == 0.2 OPPOSITE PARA ONLY REGION
   zdiode_02   = zdiode_all INTERACT zdiode_02_1
   zdiode = COPY zdiode_02_1
//
   ILL_ZDIODE_UNDEFINED { @ Zener diode must have 0.2 implant ovlp
            zdiode_all NOT zdiode_02 
   }
//
#IFDEF DEVSWITCH
   xndiode  { COPY ndiode }
   xpdiode  { COPY pdiode }
   xnwdiode { COPY nwdiode }
   xzdiode  { COPY zdiode }
#ENDIF
//
//=====================================================================
// create layers to separate n- and p-diffusion contacts

   ndiffcon       = ndiff_1 AND CONT
   pdiffcon       = pdiff_1 AND CONT

//=====================================================================
// create layers to seperate zdiode nplus and pplus areas from other
// nplus and pplus areas

   nplus_n_zener    = NPLUS NOT ZENER
   pplus_n_zener    = PPLUS NOT ZENER


//=====================================================================
// create layers to find diffusion outside zdiodes and illegal zdiodes

   diff_n_zener     = DIFF NOT ZENER
   ndiff_n_zener    = ndiff NOT ZENER
   pdiff_n_zener    = pdiff NOT ZENER


//=====================================================================
// create layers to find gate structures not belonging to a device

   ncap             = ngate NOT ndev
   pcap             = pgate NOT pdev

//=====================================================================
// create layers to separate test and probe pads (smaler 70*70 U)
// from bond pads - needed for drc
// 60 x 69 !!!!

//
// filter scribe for ESD
// >>>>> ESD >>>>>
   // te_pro_pad         = PAD AREA < 4901
   te_pro_pad         = PAD AREA < 4761
   pad_long_edge      = PAD LENGTH > 200
   pad_with_long_edge = PAD WITH EDGE pad_long_edge
   bondpad_1          = PAD NOT te_pro_pad
   bondpad            = bondpad_1 NOT pad_with_long_edge
//
////////////////////////////////////////////////////
   // m1_not_bondpad   = routingmet1 NOT ENCLOSE bondpad
   // m2_not_bondpad   = routingmet2 NOT ENCLOSE bondpad
   // m3_not_bondpad   = routingmet3 NOT ENCLOSE bondpad
// #IFDEF fourmetal
   // m4_not_bondpad   = routingmet4 NOT ENCLOSE bondpad
// #ENDIF
   // p1_not_bondpad   = POLY1 NOT ENCLOSE bondpad

//=====================================================================
// create layers needed to check length to width ratio of poly1, nwell
// and hrespoly resistors

// poly2 resistors

   pres_w           = pres COINCIDENT EDGE RESTRM
   pres_l           = pres NOT COINCIDENT EDGE RESTRM
   pres_wexp        = pres_w EXPAND EDGE OUTSIDE BY 0.1
   pres_lexp        = pres_l EXPAND EDGE OUTSIDE BY 0.1
   pres_exp         = SIZE pres BY 0.1
//<<<<<<<<<<<<<<<<<<<<<<<<<<<
// modified for connectivity
   pres_exp_net     = COPY    pres_exp
   CONNECT pres_exp_net 
   //pres_exp_net     = POLYNET pres_exp
   pres_wexp_net    = STAMP pres_wexp BY pres_exp_net
   pres_lexp_net    = STAMP pres_lexp BY pres_exp_net

// nwell resistors

   nwres_w          = nwres COINCIDENT EDGE RESTRM
   nwres_l          = nwres NOT COINCIDENT EDGE RESTRM
   nwres_wexp       = nwres_w EXPAND EDGE OUTSIDE BY 0.1
   nwres_lexp       = nwres_l EXPAND EDGE OUTSIDE BY 0.1
   nwres_exp        = SIZE nwres BY 0.1
//<<<<<<<<<<<<<<<<<<<<<<<<<<<
// modified for connectivity
   nwres_exp_net    = COPY    nwres_exp
   CONNECT nwres_exp_net 
   //nwres_exp_net    = POLYNET nwres_exp
   nwres_wexp_net   = STAMP nwres_wexp BY nwres_exp_net
   nwres_lexp_net   = STAMP nwres_lexp BY nwres_exp_net

// hrespoly resistors

   presh_w          = presh COINCIDENT EDGE preshterm
   presh_l          = presh NOT COINCIDENT EDGE preshterm
   presh_wexp       = presh_w EXPAND EDGE OUTSIDE BY 0.1
   presh_lexp       = presh_l EXPAND EDGE OUTSIDE BY 0.1
   presh_exp        = SIZE presh BY 0.1
//<<<<<<<<<<<<<<<<<<<<<<<<<<<
// modified for connectivity
   presh_exp_net    = COPY  presh_exp
   CONNECT presh_exp_net 
   //presh_exp_net    = POLYNET presh_exp
   presh_wexp_net   = STAMP presh_wexp BY presh_exp_net
   presh_lexp_net   = STAMP presh_lexp BY presh_exp_net


//=====================================================================
// create layers to separate resistors with 45 and 90 degree corners

// poly2 resistors

   pres45_1         = ANGLE pres == 45
   pres45           = pres45_1 EXPAND EDGE INSIDE BY 0.1

// hrespoly resistors

   presh45_1        = ANGLE presh == 45
   presh45          = presh45_1 EXPAND EDGE INSIDE BY 0.1

// ndiff resistors

   ndres45_1        = ANGLE ndres == 45
   ndres45          = ndres45_1 EXPAND EDGE INSIDE BY 0.1

// pdiff resistors

   pdres45_1        = ANGLE pdres == 45
   pdres45          = pdres45_1 EXPAND EDGE INSIDE BY 0.1

// nwell resistors

   nwres45_1         = ANGLE nwres == 45
   nwres45           = nwres45_1 EXPAND EDGE INSIDE BY 0.1


//=====================================================================
// create layers for single layer space notch checks

   poly2check      = POLY2 NOT COINCIDENT EDGE pres45
   poly2hcheck     = presh_1 NOT COINCIDENT EDGE presh45

   diffcheck_1      = DIFF INTERACT RESDEF
   diffcheck_2      = diffcheck_1 NOT RESDEF
   diffcheck_3      = DIFF NOT diffcheck_2
   diffcheck_4      = diffcheck_3 NOT COINCIDENT EDGE ndres45
   diffcheck        = diffcheck_4 NOT COINCIDENT EDGE pdres45

   ntubcheck        = NTUB NOT COINCIDENT EDGE nwres45

//=====================================================================
// create layers for ndiff - nwell checks

   ndiff_n_nmosh    = ndiff_1 NOT INTERACT nmosh

//=====================================================================
// create layers for slot rule checks

   met1_withslots  = MET1 NOT M1HOLE
   met2_withslots  = MET2 NOT M2HOLE
   met3_withslots  = MET3 NOT M3HOLE
#IFDEF fourmetal
   met4_withslots  = MET4 NOT M4HOLE
#ENDIF
 

//=====================================================================
// create other layers needed for drc and connectivity

// for erc

   p1_or_p2         = POLY1 OR POLY2
   diff_or_poly     = DIFF OR p1_or_p2
   implant          = NPLUS OR PPLUS

// substrate taps

   welltap          = ndiff AND routingnwell
   subtap           = pdiff NOT routingnwell

//=====================================================================
//                             SPIRALS 
//=====================================================================
//
// Definition : consist of met2/met3/met4 parts, connected by via2/via3
//              INDDEF layer encloses whole spiral
//              model name is text on INDDEF layer
//              RESTRM layer defines connection, must have text P1/P2 !!!
//              if no name is found, but spiral definition is ok, then
//              model name is unknown
//              there are some checks, if spiral is shorted or bad (open)
//              by external metal
// text convention : text is on m3pin for 3 met spirals, on met4 on 4 met spirals
//                   text is placed in restrm rectangle
//
// ATTENTION : 3 met spirals are not allowed in 4 met process
//             met3/met2 is used in c35b3
//             met4/met3 is used in c35b4
//
//  check text on restrms
//
#IFDEF fourmetal
// for text on met4
   spiral_term11 = RESTRM INTERACT (EXPAND TEXT "P1" M4PIN BY 2)
   spiral_term22 = RESTRM INTERACT (EXPAND TEXT "P2" M4PIN BY 2)
#ELSE
// text p1/p2 in m3pin 
   spiral_term11 = RESTRM INTERACT (EXPAND TEXT "P1" M3PIN BY 2)
   spiral_term22 = RESTRM INTERACT (EXPAND TEXT "P2" M3PIN BY 2)
#ENDIF
//
// get spiral terms
//
// metal inside spiral may be met2/3/4
#IFDEF fourmetal
   spiral_met_all = ((MET2 AND INDDEF) OR (MET3 AND INDDEF)) OR (MET4 AND INDDEF)
#ELSE
   spiral_met_all = (MET2 AND INDDEF) OR (MET3 AND INDDEF)
#ENDIF
//
// metal for terminal only met2/3
   spiral_term = ((spiral_term11 OR spiral_term22) AND INDDEF) INTERACT spiral_met_all  
// spiral_inddef
   spiral_inddef = INDDEF INTERACT spiral_term == 2
   spiral_body = spiral_inddef AND spiral_met_all
// spiral_body { COPY spiral_body }
//
   spiral_met3 = spiral_body AND MET3
   spiral_met2 = spiral_body AND MET2
   spiral_via2 = spiral_body AND VIA2
   CONNECT spiral_met3 spiral_met2 BY spiral_via2
#IFDEF fourmetal
   spiral_met4 = spiral_body AND MET4
   spiral_via3 = spiral_body AND VIA3
   CONNECT spiral_met4 spiral_met3 BY spiral_via3
#ENDIF
//
// check connectivity from term1 to term2
// terminal connected to met3 for c35b3 and met4 for c35b4
//
//   BAD_SPIRAL_OPEN_M2 {@ Warning : spiral met2 terminals not connected
//                    spiral_term11s = STAMP spiral_term11 BY spiral_met2
//                    spiral_term22s = STAMP spiral_term22 BY spiral_met2
//                    NET AREA RATIO spiral_term11s spiral_term22s == 0
//                   }
#IFDEF fourmetal
   BAD_SPIRAL_OPEN_M4 {@ Warning : spiral met4 terminals not connected
                    spiral_term11s = STAMP spiral_term11 BY spiral_met4
                    spiral_term22s = STAMP spiral_term22 BY spiral_met4
                    NET AREA RATIO spiral_term11s spiral_term22s == 0
                   }
#ELSE
   BAD_SPIRAL_OPEN_M3 {@ Warning : spiral met3 terminals not connected
                    spiral_term11s = STAMP spiral_term11 BY spiral_met3
                    spiral_term22s = STAMP spiral_term22 BY spiral_met3
                    NET AREA RATIO spiral_term11s spiral_term22s == 0
                   }
#ENDIF
//
// check if any metal creates internal shorts
// which are not found by DRC
//
   BAD_SPIRAL_MET3_INTSHORT {@ ERC Warning : internal spiral met3 short
              HOLES spiral_met3
              }
   BAD_SPIRAL_MET2_INTSHORT {@ ERC Warning : internal spiral met2 short
              HOLES spiral_met2
              }
#IFDEF fourmetal
   BAD_SPIRAL_MET4_INTSHORT {@ ERC Warning : internal spiral met4 short
              HOLES spiral_met4
              }
#ENDIF
//
// any met2/3/ routing metal crosses definition layer ( not on terminal)
//
   BAD_SPIRAL_MET2SHORT {@ ERC Warning : spiral may be shorted to external met2
                   drcerr = EXT spiral_met2 routingmet2 < 0.1 REGION ABUT == 0
                   drcerr NOT INTERACT spiral_term
                   }
   BAD_SPIRAL_MET3SHORT {@ ERC Warning : spiral may be shorted to external met3
                   drcerr = EXT spiral_met3 routingmet3 < 0.1 REGION ABUT == 0
                   drcerr NOT INTERACT spiral_term
                   }
#IFDEF fourmetal
   BAD_SPIRAL_MET4SHORT {@ ERC Warning : spiral may be shorted to external met4
                   drcerr = EXT spiral_met4 routingmet4 < 0.1 REGION ABUT == 0
                   drcerr NOT INTERACT spiral_term
                   }
#ENDIF
//
// check for illegal layer under spiral
// only nwell allowed
//  
   bad_spirlay_1 = INDDEF AND POLY1 
   bad_spirlay_2 = INDDEF AND POLY2 
   bad_spirlay_3 = INDDEF AND DIFF  
   bad_spirlay_4 = INDDEF AND implant
   bad_spirlay_5 = INDDEF AND MET1
   bad_spirlay_6 = INDDEF AND via_cont
   bad_spirlay_all = bad_spirlay_1 OR (bad_spirlay_2 OR (bad_spirlay_3 OR (bad_spirlay_4 OR
                     (bad_spirlay_5 OR bad_spirlay_6))))
#IFDEF fourmetal
   BAD_SPIRAL_ILLEGAL_LAYER {@ ERC Warning : illegal layer below spiral
                             COPY bad_spirlay_all
                             INDDEF AND MET2
                            }
#ELSE
   BAD_SPIRAL_ILLEGAL_LAYER {@ ERC Warning : illegal layer below spiral
                             COPY bad_spirlay_all
                            }
#ENDIF
//
// split different types
//
#IFDEF fourmetal
//
// list of 29 metal4 spirals 
//
   spiral_body_SP014S300D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP014S300D" INDDEF_TEXT BY 2))
   spiral_body_SP018S300D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP018S300D" INDDEF_TEXT BY 2))
   spiral_body_SP020S180D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP020S180D" INDDEF_TEXT BY 2))
   spiral_body_SP023S200D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP023S200D" INDDEF_TEXT BY 2))
   spiral_body_SP025C200D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP025C200D" INDDEF_TEXT BY 2))
   spiral_body_SP026S200D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP026S200D" INDDEF_TEXT BY 2))
   spiral_body_SP028S300D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP028S300D" INDDEF_TEXT BY 2))
   spiral_body_SP028C200D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP028C200D" INDDEF_TEXT BY 2))
   spiral_body_SP030C200D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP030C200D" INDDEF_TEXT BY 2))
   spiral_body_SP037S180D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP037S180D" INDDEF_TEXT BY 2))
   spiral_body_SP038S300D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP038S300D" INDDEF_TEXT BY 2))
   spiral_body_SP040C200D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP040C200D" INDDEF_TEXT BY 2))
   spiral_body_SP040C300D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP040C300D" INDDEF_TEXT BY 2))
   spiral_body_SP045C200D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP045C200D" INDDEF_TEXT BY 2))
   spiral_body_SP047S180D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP047S180D" INDDEF_TEXT BY 2))
   spiral_body_SP050S155D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP050S155D" INDDEF_TEXT BY 2))
   spiral_body_SP051C300D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP051C300D" INDDEF_TEXT BY 2))
   spiral_body_SP068C300D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP068C300D" INDDEF_TEXT BY 2))
   spiral_body_SP090C200D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP090C200D" INDDEF_TEXT BY 2))
   spiral_body_SP090S155D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP090S155D" INDDEF_TEXT BY 2))
   spiral_body_SP112C300D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP112C300D" INDDEF_TEXT BY 2))
   spiral_body_SP140C200D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP140C200D" INDDEF_TEXT BY 2))
   spiral_body_SP200C200D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP200C200D" INDDEF_TEXT BY 2))
//
   spiral_body_SY014C165D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SY014C165D" INDDEF_TEXT BY 2))
   spiral_body_SY015C200D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SY015C200D" INDDEF_TEXT BY 2))
   spiral_body_SY016C180D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SY016C180D" INDDEF_TEXT BY 2))
   spiral_body_SY017C165D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SY017C165D" INDDEF_TEXT BY 2))
   spiral_body_SY019C180D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SY019C180D" INDDEF_TEXT BY 2))
   spiral_body_SY028C160D = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SY028C160D" INDDEF_TEXT BY 2))
//
// get spiral without text
//
   spnamed_1 =
    spiral_body_SY014C165D     
   OR( spiral_body_SP014S300D    
   OR( spiral_body_SY015C200D    
   OR spiral_body_SY016C180D ))
   spnamed_2 =
    spiral_body_SY017C165D    
   OR( spiral_body_SP018S300D    
   OR( spiral_body_SY019C180D    
   OR( spiral_body_SP020S180D    
   OR spiral_body_SP023S200D )))
   spnamed_3 =
    spiral_body_SP025C200D    
   OR( spiral_body_SP026S200D    
   OR( spiral_body_SY028C160D    
   OR( spiral_body_SP028C200D    
   OR spiral_body_SP028S300D )))
   spnamed_4 =
    spiral_body_SP030C200D   
   OR( spiral_body_SP037S180D    
   OR( spiral_body_SP038S300D    
   OR( spiral_body_SP040C200D    
   OR spiral_body_SP040C300D )))
   spnamed_5 =
    spiral_body_SP045C200D    
   OR( spiral_body_SP047S180D    
   OR( spiral_body_SP050S155D    
   OR( spiral_body_SP051C300D    
   OR spiral_body_SP068C300D )))
   spnamed_6 =
    spiral_body_SP090C200D    
   OR( spiral_body_SP090S155D    
   OR( spiral_body_SP112C300D    
   OR( spiral_body_SP140C200D    
   OR spiral_body_SP200C200D )))
// 
   spiral_body_named = spnamed_1 OR (spnamed_2 OR (spnamed_3 OR (spnamed_4 OR (spnamed_5 OR spnamed_6))))
//
   spiral_body_unknown = spiral_body NOT spiral_body_named
   INFO_UNKNOWN_SPIRAL_NAME {@ ERC Warning : Name of Spiral not identified
                             INDDEF INTERACT spiral_body_unknown
                            }

#ELSE
//
// list of 29 metal3 spirals 
//
   spiral_body_SP014S300C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP014S300C" INDDEF_TEXT BY 2))
   spiral_body_SP018S300C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP018S300C" INDDEF_TEXT BY 2))
   spiral_body_SP020S180C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP020S180C" INDDEF_TEXT BY 2))
   spiral_body_SP023S200C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP023S200C" INDDEF_TEXT BY 2))
   spiral_body_SP025C200C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP025C200C" INDDEF_TEXT BY 2))
   spiral_body_SP026S200C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP026S200C" INDDEF_TEXT BY 2))
   spiral_body_SP028S300C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP028S300C" INDDEF_TEXT BY 2))
   spiral_body_SP028C200C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP028C200C" INDDEF_TEXT BY 2))
   spiral_body_SP030C200C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP030C200C" INDDEF_TEXT BY 2))
   spiral_body_SP037S180C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP037S180C" INDDEF_TEXT BY 2))
   spiral_body_SP038S300C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP038S300C" INDDEF_TEXT BY 2))
   spiral_body_SP040C200C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP040C200C" INDDEF_TEXT BY 2))
   spiral_body_SP040C300C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP040C300C" INDDEF_TEXT BY 2))
   spiral_body_SP045C200C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP045C200C" INDDEF_TEXT BY 2))
   spiral_body_SP047S180C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP047S180C" INDDEF_TEXT BY 2))
   spiral_body_SP050S155C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP050S155C" INDDEF_TEXT BY 2))
   spiral_body_SP051C300C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP051C300C" INDDEF_TEXT BY 2))
   spiral_body_SP068C300C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP068C300C" INDDEF_TEXT BY 2))
   spiral_body_SP090C200C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP090C200C" INDDEF_TEXT BY 2))
   spiral_body_SP090S155C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP090S155C" INDDEF_TEXT BY 2))
   spiral_body_SP112C300C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP112C300C" INDDEF_TEXT BY 2))
   spiral_body_SP140C200C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP140C200C" INDDEF_TEXT BY 2))
   spiral_body_SP200C200C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SP200C200C" INDDEF_TEXT BY 2))
//
   spiral_body_SY014C165C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SY014C165C" INDDEF_TEXT BY 2))
   spiral_body_SY015C200C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SY015C200C" INDDEF_TEXT BY 2))
   spiral_body_SY016C180C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SY016C180C" INDDEF_TEXT BY 2))
   spiral_body_SY017C165C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SY017C165C" INDDEF_TEXT BY 2))
   spiral_body_SY019C180C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SY019C180C" INDDEF_TEXT BY 2))
   spiral_body_SY028C160C = spiral_body AND ( spiral_inddef INTERACT (EXPAND TEXT "SY028C160C" INDDEF_TEXT BY 2))
//
// get spiral without text
//
   spnamed_1 =
    spiral_body_SY014C165C     
   OR( spiral_body_SP014S300C    
   OR( spiral_body_SY015C200C    
   OR spiral_body_SY016C180C ))
   spnamed_2 =
    spiral_body_SY017C165C    
   OR( spiral_body_SP018S300C    
   OR( spiral_body_SY019C180C    
   OR( spiral_body_SP020S180C    
   OR spiral_body_SP023S200C )))
   spnamed_3 =
    spiral_body_SP025C200C    
   OR( spiral_body_SP026S200C    
   OR( spiral_body_SY028C160C    
   OR( spiral_body_SP028C200C    
   OR spiral_body_SP028S300C )))
   spnamed_4 =
    spiral_body_SP030C200C   
   OR( spiral_body_SP037S180C    
   OR( spiral_body_SP038S300C    
   OR( spiral_body_SP040C200C    
   OR spiral_body_SP040C300C )))
   spnamed_5 =
    spiral_body_SP045C200C    
   OR( spiral_body_SP047S180C    
   OR( spiral_body_SP050S155C    
   OR( spiral_body_SP051C300C    
   OR spiral_body_SP068C300C )))
   spnamed_6 =
    spiral_body_SP090C200C    
   OR( spiral_body_SP090S155C    
   OR( spiral_body_SP112C300C    
   OR( spiral_body_SP140C200C    
   OR spiral_body_SP200C200C )))
// 
   spiral_body_named = spnamed_1 OR (spnamed_2 OR (spnamed_3 OR (spnamed_4 OR (spnamed_5 OR spnamed_6))))
//
   spiral_body_unknown = spiral_body NOT spiral_body_named
   INFO_UNKNOWN_SPIRAL_NAME {@ ERC Warning : Name of Spiral not identified
                             INDDEF INTERACT spiral_body_unknown
                            }
//
#ENDIF
//
// find any inddef not extracting a correct spiral
// also possible if bad or missing terminal text, wrong process  
//
   BAD_SPIRAL_LAYOUT {@ ERC Warning : INDDEF does not define a correct spiral
                      @               check for name, pin text, process
                        INDDEF NOT INTERACT spiral_body_named
                     }
//
//
#IFDEF DEVSWITCH
//
#IFDEF fourmetal
// met4
//
   xsp014S300D  { INDDEF INTERACT spiral_body_SP014S300D }   
   xsp018S300D  { INDDEF INTERACT spiral_body_SP018S300D }   
   xsp020S180D  { INDDEF INTERACT spiral_body_SP020S180D }   
   xsp023S200D  { INDDEF INTERACT spiral_body_SP023S200D }
   xsp025C200D  { INDDEF INTERACT spiral_body_SP025C200D }   
   xsp026S200D  { INDDEF INTERACT spiral_body_SP026S200D }   
   xsp028C200D  { INDDEF INTERACT spiral_body_SP028C200D }   
   xsp028S300D  { INDDEF INTERACT spiral_body_SP028S300D }
   xsp030C200D  { INDDEF INTERACT spiral_body_SP030C200D }   
   xsp037S180D  { INDDEF INTERACT spiral_body_SP037S180D }   
   xsp038S300D  { INDDEF INTERACT spiral_body_SP038S300D }   
   xsp040C200D  { INDDEF INTERACT spiral_body_SP040C200D }   
   xsp040C300D  { INDDEF INTERACT spiral_body_SP040C300D }
   xsp045C200D  { INDDEF INTERACT spiral_body_SP045C200D }   
   xsp047S180D  { INDDEF INTERACT spiral_body_SP047S180D }   
   xsp050S155D  { INDDEF INTERACT spiral_body_SP050S155D }   
   xsp051C300D  { INDDEF INTERACT spiral_body_SP051C300D }   
   xsp068C300D  { INDDEF INTERACT spiral_body_SP068C300D }
   xsp090C200D  { INDDEF INTERACT spiral_body_SP090C200D }   
   xsp090S155D  { INDDEF INTERACT spiral_body_SP090S155D }   
   xsp112C300D  { INDDEF INTERACT spiral_body_SP112C300D }   
   xsp140C200D  { INDDEF INTERACT spiral_body_SP140C200D }   
   xsp200C200D  { INDDEF INTERACT spiral_body_SP200C200D }
//
   xsy014C165D  { INDDEF INTERACT spiral_body_SY014C165D }    
   xsy015C200D  { INDDEF INTERACT spiral_body_SY015C200D }   
   xsy016C180D  { INDDEF INTERACT spiral_body_SY016C180D }  
   xsy017C165D  { INDDEF INTERACT spiral_body_SY017C165D }   
   xsy019C180D  { INDDEF INTERACT spiral_body_SY019C180D }   
   xsy028C160D  { INDDEF INTERACT spiral_body_SY028C160D }   
#ELSE
//
// met3
//
   xsp014S300C  { INDDEF INTERACT spiral_body_SP014S300C }   
   xsp018S300C  { INDDEF INTERACT spiral_body_SP018S300C }   
   xsp020S180C  { INDDEF INTERACT spiral_body_SP020S180C }   
   xsp023S200C  { INDDEF INTERACT spiral_body_SP023S200C }
   xsp025C200C  { INDDEF INTERACT spiral_body_SP025C200C }   
   xsp026S200C  { INDDEF INTERACT spiral_body_SP026S200C }   
   xsp028C200C  { INDDEF INTERACT spiral_body_SP028C200C }   
   xsp028S300C  { INDDEF INTERACT spiral_body_SP028S300C }
   xsp030C200C  { INDDEF INTERACT spiral_body_SP030C200C }   
   xsp037S180C  { INDDEF INTERACT spiral_body_SP037S180C }   
   xsp038S300C  { INDDEF INTERACT spiral_body_SP038S300C }   
   xsp040C200C  { INDDEF INTERACT spiral_body_SP040C200C }   
   xsp040C300C  { INDDEF INTERACT spiral_body_SP040C300C }
   xsp045C200C  { INDDEF INTERACT spiral_body_SP045C200C }   
   xsp047S180C  { INDDEF INTERACT spiral_body_SP047S180C }   
   xsp050S155C  { INDDEF INTERACT spiral_body_SP050S155C }   
   xsp051C300C  { INDDEF INTERACT spiral_body_SP051C300C }   
   xsp068C300C  { INDDEF INTERACT spiral_body_SP068C300C }
   xsp090C200C  { INDDEF INTERACT spiral_body_SP090C200C }   
   xsp090S155C  { INDDEF INTERACT spiral_body_SP090S155C }   
   xsp112C300C  { INDDEF INTERACT spiral_body_SP112C300C }   
   xsp140C200C  { INDDEF INTERACT spiral_body_SP140C200C }   
   xsp200C200C  { INDDEF INTERACT spiral_body_SP200C200C }
//
   xsy014C165C  { INDDEF INTERACT spiral_body_SY014C165C }    
   xsy015C200C  { INDDEF INTERACT spiral_body_SY015C200C }   
   xsy016C180C  { INDDEF INTERACT spiral_body_SY016C180C }  
   xsy017C165C  { INDDEF INTERACT spiral_body_SY017C165C }   
   xsy019C180C  { INDDEF INTERACT spiral_body_SY019C180C }   
   xsy028C160C  { INDDEF INTERACT spiral_body_SY028C160C }   
#ENDIF

#ENDIF
//
// remove spiral from interconnect
// normally spiral does not have met1
// connectivity metal does not have slots !!!
// remove hall spiral from interconnect
//
   routingmet1 = (met1_withslots NOT spiral_body) NOT halldef_cut
   routingmet2 = (met2_withslots NOT spiral_body) NOT halldef_cut
   routingmet3 = met3_withslots NOT spiral_body
   routingvia  = (VIA  NOT spiral_body) NOT halldef_cut
   routingvia2 = VIA2 NOT spiral_body
#IFDEF fourmetal
   routingmet4 = met4_withslots NOT spiral_body
   routingvia3 = VIA3 NOT spiral_body
#ENDIF
//
//=====================================================================
//                               HALL
//=====================================================================
//
// define a cut layer to open nwell and spiral in hall element
//
// best value for hallc35
   // halldef_cut    = SIZE HALLDEF BY -12.0
//
   hall_term_a  = (RESTRM INTERACT (EXPAND TEXT "A" M1PIN BY 2)) INTERACT HALLDEF
   hall_term_b  = (RESTRM INTERACT (EXPAND TEXT "B" M1PIN BY 2)) INTERACT HALLDEF
   hall_term_c  = (RESTRM INTERACT (EXPAND TEXT "C" M1PIN BY 2)) INTERACT HALLDEF
   hall_term_d  = (RESTRM INTERACT (EXPAND TEXT "D" M1PIN BY 2)) INTERACT HALLDEF
   hall_term_s  = (RESTRM INTERACT (EXPAND TEXT "S" M1PIN BY 2)) INTERACT HALLDEF
   hall_term_p1 = (RESTRM INTERACT (EXPAND TEXT "P1" M2PIN BY 2)) INTERACT HALLDEF
   hall_term_p2 = (RESTRM INTERACT (EXPAND TEXT "P2" M2PIN BY 2)) INTERACT HALLDEF
//
   hall_body_HALLC35 = HALLDEF INTERACT (EXPAND TEXT "HALLC35" HALLDEF_TEXT BY 2)
//
#IFDEF DEVSWITCH
   xhallc35 { COPY hall_body_HALLC35 }
#ENDIF
//
///////////////////////////////////////////////////////////////////////
//                       CONNECT STATEMENTS                          //
///////////////////////////////////////////////////////////////////////
//
// Create interconnects used in direct mode
//
   CONNECT MET3           MET2                       BY VIA2      DIRECT
   CONNECT MET2           MET1                       BY VIA       DIRECT
   CONNECT MET1           POLY2 POLY1 DIFF           BY CONT      DIRECT

// Create interconnects used in mask mode

#IFDEF fourmetal
   CONNECT MET4           MET3                       BY VIA3 DIRECT
   CONNECT routingmet4    routingmet3                BY routingvia3 MASK   
#ENDIF

// Create interconnects used in mask mode

   CONNECT routingmet3    routingmet2                BY routingvia2 MASK   
   CONNECT routingmet2    routingmet1                BY routingvia  MASK   
   CONNECT routingmet1    routingpoly2               BY poly2con    MASK
   CONNECT routingmet1    routingpoly                BY poly1con    MASK
   CONNECT routingmet1    ndiff                      BY ndiffcon    MASK
   CONNECT routingmet1    pdiff                      BY pdiffcon    MASK
   CONNECT pdiff          substrate                  BY subtap      MASK
   CONNECT ndiff          routingnwell               BY welltap     MASK
   CONNECT routingpoly    trans ncap pcap                           MASK
   CONNECT routingpoly2   preshterm                                 MASK
   CONNECT RESTRM         routingpoly2                              MASK
   CONNECT RESTRM         routingpoly                               MASK
   CONNECT RESTRM         ndiff                                     MASK
   CONNECT RESTRM         pdiff                                     MASK
   CONNECT ndiff          nmosh_d_term                              MASK
   CONNECT pdiff          pnpvert10_e pnplat2_e pnplat2_c           MASK
// for XCALI 
   CONNECT nwdiode_shield routingnwell                              MASK 
   CONNECT trans_shield routingpoly                                 MASK
//
// add connectivity for unrel met checks
//
   CONNECT routingmet3    PAD                                       MASK
// 
// connect spirals
//
#IFDEF fourmetal
// spiral connections for 4 met spirals
   CONNECT spiral_term11 routingmet4   MASK
   CONNECT spiral_term22 routingmet4   MASK
#ELSE
// spiral connections for 3 met spirals
   CONNECT spiral_term11 routingmet3   MASK
   CONNECT spiral_term22 routingmet3   MASK
#ENDIF
//
// remove isolated layout nets warning from LVS
// add connectivity to retrm on spiral terms
//
   CONNECT RESTRM spiral_term11 MASK
   CONNECT RESTRM spiral_term22 MASK
//
// connect hall terms
   CONNECT hall_term_a hall_term_b hall_term_c hall_term_d hall_term_s routingmet1 MASK
   CONNECT hall_term_p1 hall_term_p2 routingmet2 MASK
//////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
//                       DEVICE-RECOGNITION                          //                         
///////////////////////////////////////////////////////////////////////


//=====================================================================
// EX 1  EX 1  EX 1  EX 1  EX 1  EX 1  EX 1  EX 1  EX 1  EX 1  EX 1  
//=====================================================================
// RESISTORS - rpoly2, rdiffn, rdiffp, rnwell


// RPOLY2

// RPOLY2 - 45 degree corners

DEVICE r(rpoly2) pres RESTRM(POS) RESTRM(NEG) <pres45>
[  
   property L,W
   W = perimeter_coincide_outside(pres,RESTRM) / 2
   res_l = perimeter(pres) / 2 - W
   L = res_l - W * bends(pres) * 0.168  // 45 degree corners !!!
]

// RPOLY - 90 degree corners or no corners

DEVICE r(rpoly2) pres RESTRM(POS) RESTRM(NEG)
[  
   property L,W
   W = perimeter_coincide_outside(pres,RESTRM) / 2
   res_l = perimeter(pres) / 2 - W
   L = res_l - W * bends(pres) * 0.5    // 90 degree corners !!!
]


// RPOLYH

// RPOLYH - 45 degree corners

DEVICE r(rpolyh) presh preshterm(POS) preshterm(NEG) <presh45>
[  
    property L,W
    W = perimeter_coincide_outside(presh,preshterm) / 2
    res_l = perimeter(presh) / 2 - W
    L = res_l - W * bends(presh) * 0.168  // 45 degree corners !!!
]

// RPOLYH - 90 degree corners or no corners

DEVICE r(rpolyh) presh preshterm(POS) preshterm(NEG)
[  
    property L,W
    W = perimeter_coincide_outside(presh,preshterm) / 2
    res_l = perimeter(presh) / 2 - W
    L = res_l - W * bends(presh) * 0.5    // 90 degree corners !!!
]


// RDIFFN

// RDIFFN - 45 degree corners

DEVICE r(rdiffn) ndres RESTRM(POS) RESTRM(NEG) <ndres45>
[
   property L,W
   W = perimeter_coincide_outside(ndres,RESTRM) / 2
   res_l = perimeter_outside(ndres,RESTRM) / 2
   L = res_l - W * bends(ndres) * 0.168  // 45 degree corners !!!
]

// RDIFFN - 90 degree corners or no corners

DEVICE r(rdiffn) ndres RESTRM(POS) RESTRM(NEG)
[
   property L,W
   W = perimeter_coincide_outside(ndres,RESTRM) / 2
   res_l = perimeter_outside(ndres,RESTRM) / 2
   L = res_l - W * bends(ndres) * 0.5    // 90 degree corners !!!
]


// RDIFFN3

// RDIFFN3 - 45 degree corners

DEVICE r(rdiffn3) ndres RESTRM(POS) RESTRM(NEG) substrate(SUB) 
                  <ndres45>
[
   property L,W
   W = perimeter_coincide_outside(ndres,RESTRM) / 2
   res_l = perimeter_outside(ndres,RESTRM) / 2
   L = res_l - W * bends(ndres) * 0.168  // 45 degree corners !!!
]

// RDIFFN3 - 90 degree corners or no corners

DEVICE r(rdiffn3) ndres RESTRM(POS) RESTRM(NEG) substrate(SUB)
[
   property L,W
   W = perimeter_coincide_outside(ndres,RESTRM) / 2
   res_l = perimeter_outside(ndres,RESTRM) / 2
   L = res_l - W * bends(ndres) * 0.5    // 90 degree corners !!!
]


// RDIFFP

// RDIFFP - 45 degree corners

DEVICE r(rdiffp) pdres RESTRM(POS) RESTRM(NEG) <pdres45>
[
   property L,W
   W = perimeter_coincide_outside(pdres,RESTRM) / 2
   res_l = perimeter_outside(pdres,RESTRM) / 2
   L = res_l - W * bends(pdres) * 0.168  // 45 degree corners !!!
]

// RDIFFP - 90 degree corners or no corners

DEVICE r(rdiffp) pdres RESTRM(POS) RESTRM(NEG)
[
   property L,W
   W = perimeter_coincide_outside(pdres,RESTRM) / 2
   res_l = perimeter_outside(pdres,RESTRM) / 2
   L = res_l - W * bends(pdres) * 0.5    // 90 degree corners !!!
]


// RDIFFP3

// RDIFFP3 - 45 degree corners

DEVICE r(rdiffp3) pdres RESTRM(POS) RESTRM(NEG) routingnwell(SUB)
                  <pdres45>
[
   property L,W
   W = perimeter_coincide_outside(pdres,RESTRM) / 2
   res_l = perimeter_outside(pdres,RESTRM) / 2
   L = res_l - W * bends(pdres) * 0.168  // 45 degree corners !!!
]

// RDIFFP3 - 90 degree corners or no corners

DEVICE r(rdiffp3) pdres RESTRM(POS) RESTRM(NEG) routingnwell(SUB)
[
   property L,W
   W = perimeter_coincide_outside(pdres,RESTRM) / 2
   res_l = perimeter_outside(pdres,RESTRM) / 2
   L = res_l - W * bends(pdres) * 0.5    // 90 degree corners !!!
]


// RNWELL

// RNWELL - 45 degree corners

DEVICE r(rnwell) nwres RESTRM(POS) RESTRM(NEG) substrate(SUB)
                 <nwres45>
[
   property L,W
   W = perimeter_coincide_outside(nwres,RESTRM) / 2
   res_l = perimeter(nwres) / 2 - W
   L = res_l - W * bends(nwres) * 0.168  // 45 degree corners !!!
]

// RNWELL - 90 degree corners or no corners

DEVICE r(rnwell) nwres RESTRM(POS) RESTRM(NEG) substrate(SUB)
[
   property L,W
   W = perimeter_coincide_outside(nwres,RESTRM) / 2
   res_l = perimeter(nwres) / 2 - W
   L = res_l - W * bends(nwres) * 0.5    // 90 degree corners !!!
]


//=====================================================================
// EX 2  EX 2  EX 2  EX 2  EX 2  EX 2  EX 2  EX 2  EX 2  EX 2  EX 2  
//=====================================================================
// BIPOLAR TRANSISTORS - pnpvert, pnplat

// PNPVERT vert10

DEVICE Q(pnpvert10) pnpvert10 substrate(C) ndiff(B) pnpvert10_e(E)
[
   property A
   // IC_Station : A = 1
   A = 1e-12
]

// PNP_LAT2

// IC_Station : DEVICE Q(pnplat2) pnplat2_g pnplat2_c(C) routingnwell(B) pnplat2_e(E) 
DEVICE Q(pnplat) pnplat2_g pnplat2_c(C) routingnwell(B) pnplat2_e(E) 
                 substrate(S) routingpoly(G)
[
   property A
   // IC_Station : A = 1
   A = 1e-12
]


//=====================================================================
// EX 3  EX 3  EX 3  EX 3  EX 3  EX 3  EX 3  EX 3  EX 3  EX 3  EX 3  
//=====================================================================
//  MOS TRANSISTORS - nmosh, nmos4, pmos4, nmosm4, pmosm4
 
 
// NMOSMH

DEVICE lddn(nmosmh) nmosmh nmosh_d_term(D) routingpoly(G) ndiff(S) psub(B)
                   <nmosh_d_fill>
[
   property L,W,AD,AS,PD,PS 
   bend_effect = 0.5
   W = (perimeter_coincide(nmosmh,ndiff))
   a = area(nmosmh)
   L = a/W
   if (bends(nmosmh) > 0)
   {
     if (W > L)
       W = W - bend_effect * bends(nmosmh) * L
     else
       L = L - bend_effect * bends(nmosmh) * W
   }
   AS = area(S)
   AD = area(D) - area(nmosh_d_fill)
   PS = perimeter_outside(S,nmosmh)
   PD = perimeter(D) - perimeter_coincide(nmosh_d_fill,D)
        + perimeter_inside(nmosh_d_fill,D)
]

// NMOSH

DEVICE lddn(nmosh) nmosh_nomidox nmosh_d_term(D) routingpoly(G) ndiff(S) psub(B)
                   <nmosh_d_fill>
[
   property L,W,AD,AS,PD,PS 
   bend_effect = 0.5
   W = (perimeter_coincide(nmosh_nomidox,ndiff))
   a = area(nmosh_nomidox)
   L = a/W
   if (bends(nmosh_nomidox) > 0)
   {
     if (W > L)
       W = W - bend_effect * bends(nmosh_nomidox) * L
     else
       L = L - bend_effect * bends(nmosh_nomidox) * W
   }
   AS = area(S)
   AD = area(D) - area(nmosh_d_fill)
   PS = perimeter_outside(S,nmosh_nomidox)
   PD = perimeter(D) - perimeter_coincide(nmosh_d_fill,D)
        + perimeter_inside(nmosh_d_fill,D)
]
//
//
//  N-MOS
//
// attention : for ad/as/pd/ps do not use corrected w
//
DEVICE mn(nmos4) nmos routingpoly(G) ndiff(S) ndiff(D) substrate(B) <ndiff_1>
[
   property W,L,AS,AD,PS,PD,NRS,NRD
   bend_effect = 0.5
   W = (perimeter_coincide(nmos,ndiff)
        + perimeter_inside(nmos,ndiff)) / 2
   L = perimeter_outside(nmos,ndiff) / 2
   W_orig = W
   if (bends(nmos) > 0)
   {
     if (W > L)
       W = W - bend_effect * bends(nmos) * L
     else
       L = L - bend_effect * bends(nmos) * W
   }
   pis = perimeter_inside( S, ndiff_1 )
   pid = perimeter_inside( D, ndiff_1 )
   if ( pis == 0 ) {  // Shorted S/D - assign half to each side.
     AD = area(D) * W_orig /pid/ 2 
     AS = AD
     PD = (perimeter(D) * W_orig/pid - perimeter_coincide(D,nmos))/2
     PS = PD
   }
   else if ( pid == 0 ) {  // Shorted S/D - assign half to each side.
     AS = area(S) * W_orig /pis/ 2 
     AD = as
     PS = (perimeter(S) * W_orig/pis - perimeter_coincide(S,nmos))/2
     PD = PS
   }
   else {  // Regular case.
     AS = area(S) * W_orig / pis
     AD = area(D) * W_orig / pid
     PS = perimeter(S) * W_orig/pis - perimeter_coincide(S,nmos)
     PD = perimeter(D) * W_orig/pid - perimeter_coincide(D,nmos)
   }
   NRS = 0.85 * 0.5e-06 / W_orig
   NRD = NRS
]

DEVICE mn(nmosm4) nmos_midox routingpoly(G) ndiff(S) ndiff(D) substrate(B) <ndiff_1>
[
   property W,L,AS,AD,PS,PD,NRS,NRD
   bend_effect = 0.5
   W = (perimeter_coincide(nmos_midox,ndiff)
        + perimeter_inside(nmos_midox,ndiff)) / 2
   L = perimeter_outside(nmos_midox,ndiff) / 2
   W_orig = W
   if (bends(nmos_midox) > 0)
   {
     if (W > L)
       W = W - bend_effect * bends(nmos_midox) * L
     else
       L = L - bend_effect * bends(nmos_midox) * W
   }
   pis = perimeter_inside( S, ndiff_1 )
   pid = perimeter_inside( D, ndiff_1 )
   if ( pis == 0 ) {  // Shorted S/D - assign half to each side.
     AD = area(D) * w_orig /pid/ 2 
     AS = AD
     PD = (perimeter(D) * W_orig/pid - perimeter_coincide(D,nmos_midox))/2
     PS = PD
   }
   else if ( pid == 0 ) {  // Shorted S/D - assign half to each side.
     AS = area(S) * w_orig /pis/ 2 
     AD = as
     PS = (perimeter(S) * W_orig/pis - perimeter_coincide(S,nmos_midox))/2
     PD = PS
   }
   else {  // Regular case.
     AS = area(S) * w_orig / pis
     AD = area(D) * w_orig / pid
     PS = perimeter(S) * W_orig/pis - perimeter_coincide(S,nmos_midox)
     PD = perimeter(D) * W_orig/pid - perimeter_coincide(D,nmos_midox)
   }
   NRS = 0.85 * 0.5e-06 / W_orig
   NRD = NRS
]


//  P-MOS

DEVICE mp(pmos4) pmos routingpoly(G) pdiff(S) pdiff(D) routingnwell(B) <pdiff_1>
[
   property W,L,AS,AD,PS,PD,NRS,NRD
   bend_effect = 0.5
   W = (perimeter_coincide(pmos,pdiff)
        + perimeter_inside(pmos,pdiff)) / 2
   L = perimeter_outside(pmos,pdiff) / 2
   W_orig = W
   if (bends(pmos) >0 )
   {
     if (W > L)
       W = W - bend_effect * bends(pmos) * L
     else
       L = L - bend_effect * bends(pmos) * W
   }
   pis = perimeter_inside( S, pdiff_1 )
   pid = perimeter_inside( D, pdiff_1 )
   if ( pis == 0 ) {  // Shorted S/D - assign half to each side.
     AD = area(D) * w_orig /pid/ 2 
     AS = AD
     PD = (perimeter(D) * W_orig/pid - perimeter_coincide(D,pmos))/2
     PS = PD
   }
   else if ( pid == 0 ) {  // Shorted S/D - assign half to each side.
     AS = area(S) * w_orig /pis/ 2 
     AD = as
     PS = (perimeter(S) * W_orig/pis - perimeter_coincide(S,pmos))/2
     PD = PS
   }
   else {  // Regular case.
     AS = area(S) * w_orig / pis
     AD = area(D) * w_orig / pid
     PS = perimeter(S) * W_orig/pis - perimeter_coincide(S,pmos)
     PD = perimeter(D) * W_orig/pid - perimeter_coincide(D,pmos)
   }
   NRS = 0.85 * 0.5e-06 / W_orig
   NRD = NRS
]

DEVICE mp(pmosm4) pmos_midox routingpoly(G) pdiff(S) pdiff(D) routingnwell(B) <pdiff_1>
[
   property W,L,AS,AD,PS,PD,NRS,NRD
   bend_effect = 0.5
   W = (perimeter_coincide(pmos_midox,pdiff)
        + perimeter_inside(pmos_midox,pdiff)) / 2
   L = perimeter_outside(pmos_midox,pdiff) / 2
   W_orig = W
   if (bends(pmos_midox) >0 )
   {
     if (W > L)
       W = W - bend_effect * bends(pmos_midox) * L
     else
       L = L - bend_effect * bends(pmos_midox) * W
   }
   pis = perimeter_inside( S, pdiff_1 )
   pid = perimeter_inside( D, pdiff_1 )
   if ( pis == 0 ) {  // Shorted S/D - assign half to each side.
     AD = area(D) * w_orig /pid/ 2 
     AS = AD
     PD = (perimeter(D) * W_orig/pid - perimeter_coincide(D,pmos_midox))/2
     PS = PD
   }
   else if ( pid == 0 ) {  // Shorted S/D - assign half to each side.
     AS = area(S) * w_orig /pis/ 2 
     AD = as
     PS = (perimeter(S) * W_orig/pis - perimeter_coincide(S,pmos_midox))/2
     PD = PS
   }
   else {  // Regular case.
     AS = area(S) * w_orig / pis
     AD = area(D) * w_orig / pid
     PS = perimeter(S) * W_orig/pis - perimeter_coincide(S,pmos_midox)
     PD = perimeter(D) * W_orig/pid - perimeter_coincide(D,pmos_midox)
   }
   NRS = 0.85 * 0.5e-06 / W_orig
   NRD = NRS
]

//=====================================================================
// EX 4  EX 4  EX 4  EX 4  EX 4  EX 4  EX 4  EX 4  EX 4  EX 4  EX 4  
//=====================================================================
// CAPACITANCES - cpolya, cvar

// CPOLYA

DEVICE c(cpolya) cpoly routingpoly(POS) routingpoly2(NEG)
[
   property A,P
   A = area(cpoly) * 1e+12
   P = perimeter(cpoly) * 1e+6
]

//
// CVAR
//
// device layer is ndiff polygon
// cols are found by counting of poly/ndiff crossings
// rows are found by count of gates
// l = l of one gate
// w = sum of all w of gates
//
// extract cvar as nmos, w,l , ad = number od cols, as = number of rows
//
// IC_Station DEVICE m(cvar) cvar_device_layer routingpoly(G) ndiff(B) substrate(S) <cvar_ndiff_cross> <cvar_ele> 
//
DEVICE m(cvar) cvar_device_layer routingpoly(G) ndiff(S) ndiff(D) substrate(B) <cvar_ndiff_cross>
   <cvar_ele>
[
   property W,L,AS,AD
   c_elements = count(cvar_ele)
   c_cross = count(cvar_ndiff_cross)/2
   w=perimeter_coincide_inside(cvar_ele, routingpoly)/2
   l=(perimeter_inside(cvar_ele, routingpoly)/2)/ c_elements
   // cols
   AD = c_cross
   // rows
   AS = c_elements/c_cross
]
//=====================================================================
// EX 5  EX 5  EX 5  EX 5  EX 5  EX 5  EX 5  EX 5  EX 5  EX 5  EX 5  
//=====================================================================
// DIODES - nd, pd, nwd, zd


// NDIFF-DIODE

DEVICE d(nd) ndiode substrate(POS) ndiff(NEG)
[
   property A,P
   A = area(ndiode) * 1e+12
   P = perimeter(ndiode) * 1e+6
]


// PDIFF-DIODE

DEVICE d(pd) pdiode pdiff(POS) routingnwell(NEG)
[
   property A,P
   A = area(pdiode) * 1e+12
   P = perimeter(pdiode) * 1e+6
]


// NWELL-DIODE

DEVICE d(nwd) nwdiode substrate(POS) routingnwell(NEG)
[
   property A,P
   A = area(nwdiode) * 1e+12
   P = perimeter(nwdiode) * 1e+6
]


// ZDIODE

DEVICE d(zd2sm24) zdiode pdiff(POS) ndiff(NEG) substrate(SUB)

//=====================================================================
// EX 5  EX 5  EX 5  EX 5  EX 5  EX 5  EX 5  EX 5  EX 5  EX 5  EX 5  
//=====================================================================
//=====================================================================
//                             SPIRALS 
//=====================================================================
//
// Definition : consist of met2/met3/met4 parts, connected by via2/via3
//              INDDEF layer encloses whole spiral
//              model name is text on INDDEF layer
//              RESTRM layer defines connection, must have text P1/P2 !!!
//              if no name is found, but spiral definition is ok, then
//              model name is unknown
//              there are some checks, if spiral is shorted or bad (open)
//              by external metal
// text convention : text is on m3pin for 3 met spirals, on met4 on 4 met spirals
//                   text is placed in restrm rectangle
//   
// 29 met3 spirals
//
#IFDEF fourmetal
//
// four metal spirals
//
   DEVICE L(SP014S300D) spiral_body_SP014S300D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP018S300D) spiral_body_SP018S300D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP020S180D) spiral_body_SP020S180D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP023S200D) spiral_body_SP023S200D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP025C200D) spiral_body_SP025C200D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP026S200D) spiral_body_SP026S200D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP028C200D) spiral_body_SP028C200D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP028S300D) spiral_body_SP028S300D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP030C200D) spiral_body_SP030C200D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP037S180D) spiral_body_SP037S180D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP038S300D) spiral_body_SP038S300D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP040C200D) spiral_body_SP040C200D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP040C300D) spiral_body_SP040C300D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP045C200D) spiral_body_SP045C200D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP047S180D) spiral_body_SP047S180D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP050S155D) spiral_body_SP050S155D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP051C300D) spiral_body_SP051C300D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP068C300D) spiral_body_SP068C300D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP090C200D) spiral_body_SP090C200D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP090S155D) spiral_body_SP090S155D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP112C300D) spiral_body_SP112C300D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP140C200D) spiral_body_SP140C200D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP200C200D) spiral_body_SP200C200D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
//
   DEVICE L(SY014C165D) spiral_body_SY014C165D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SY015C200D) spiral_body_SY015C200D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SY016C180D) spiral_body_SY016C180D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SY017C165D) spiral_body_SY017C165D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SY019C180D) spiral_body_SY019C180D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SY028C160D) spiral_body_SY028C160D spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
#ELSE
//
// 3 metal spirals
//
   DEVICE L(SP014S300C) spiral_body_SP014S300C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP018S300C) spiral_body_SP018S300C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP020S180C) spiral_body_SP020S180C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP023S200C) spiral_body_SP023S200C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP025C200C) spiral_body_SP025C200C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP026S200C) spiral_body_SP026S200C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP028C200C) spiral_body_SP028C200C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP028S300C) spiral_body_SP028S300C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP030C200C) spiral_body_SP030C200C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP037S180C) spiral_body_SP037S180C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP038S300C) spiral_body_SP038S300C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP040C200C) spiral_body_SP040C200C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP040C300C) spiral_body_SP040C300C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP045C200C) spiral_body_SP045C200C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP047S180C) spiral_body_SP047S180C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP050S155C) spiral_body_SP050S155C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP051C300C) spiral_body_SP051C300C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP068C300C) spiral_body_SP068C300C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP090C200C) spiral_body_SP090C200C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP090S155C) spiral_body_SP090S155C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP112C300C) spiral_body_SP112C300C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP140C200C) spiral_body_SP140C200C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SP200C200C) spiral_body_SP200C200C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
//
   DEVICE L(SY014C165C) spiral_body_SY014C165C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SY015C200C) spiral_body_SY015C200C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SY016C180C) spiral_body_SY016C180C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SY017C165C) spiral_body_SY017C165C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SY019C180C) spiral_body_SY019C180C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
   DEVICE L(SY028C160C) spiral_body_SY028C160C spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
#ENDIF
//
// if not found, should be any spiral name, but terminals must exist
//
   DEVICE L(spiral_unknown) spiral_body_unknown spiral_term11(POS) spiral_term22(NEG) psub(SUB) (POS NEG)
//
//=====================================================================
//                             HALL
//=====================================================================
//
   DEVICE hall(HALLC35) hall_body_HALLC35 hall_term_a(A) hall_term_b(B) hall_term_c(C) hall_term_d(D)
                        hall_term_s(S) hall_term_p1(P1) hall_term_p2(P2)
//
///////////////////////////////////////////////////////////////////////
//
//                end of CALIBRE device extraction
//
///////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////
//
//                           ESD checks  
//
///////////////////////////////////////////////////////////////////////
//-------------------------------------------------------------------------------
//     rev     date            by                      comment
//-------------------------------------------------------------------------------
//    1.00  16-Sep-2003       a.o.          0.35 U Document ENG-236 REV 1.0
//          11-Nov-2004       aob           groups added, g01dn changed
//                                          nd_diode/pd_diode pnpvert removed
//          10-May-2006       aob           E11SN fixed
//          17-May-2006       aob           latchup checks cxq included
//-------------------------------------------------------------------------------
// Note : ESD check always done for 4 metal process
//
///////////////////////////////////////////////////////////////////////

//> From: Fankhauser Bernd 
//> Sent: Mittwoch, 17. November 2004 08:18
//> To:   Heiling Gernot
//> Subject:      RE: ESD Check
//> 
//> Servus Gernot,
//> 
//> habe jetzt versucht, die Rules zu identifizieren, die auf keinen Fall
//> ausgeblendet werden sollen:
//> - alle rules in 3.1 (NDIFF)
//> - alle rules in 3.4 (POLY1, POLY2)
//> - alle rules in 3.5 (CMIM)
//> - alle rules in 4.2 (LV_NDRIVER)
//> - 4.8 (RBLOCK)
//> 
//> LG,
//> Bernd
//
// define some groups for unselection
// by default all checks are selected
//
// DRC SELECT CHECK CHECK_ALWAYS
// DRC SELECT CHECK GENERAL_RULES
// DRC SELECT CHECK ELEMENT_RULES
// DRC SELECT CHECK BUS_RULES
// DRC SELECT CHECK INFO
// DRC UNSELECT CHECK BUS_RULES
// DRC UNSELECT CHECK INFO

  GROUP CHECK_ALWAYS
   P_TRIG_INFO_LATCHUP                                                                                      
   N_TRIG_INFO_LATCHUP                                                                                      
   P_TRIG_SCR_25_REGION_LATCHUP                                                                                      
   P_TRIG_100_NOGUARD_LATCHUP                                                                                      
   P_TRIG_100_MISS_PTAP_LATCHUP                                                                                      
   P_TRIG_100_MISS_NTAP_LATCHUP                                                                                      
   N_TRIG_SCR_25_REGION_LATCHUP                                                                                      
   N_TRIG_100_NOGUARD_LATCHUP                                                                                      
   N_TRIG_100_MISS_PTAP_LATCHUP                                                                                      
   N_TRIG_100_MISS_NTAP_LATCHUP                                                                                      
// 3.1 rules
   SPAC_NDIFF_2_NTUB_G01DN                                                          
   SPAC_NDIFF_NO_NTUB_G01DN                                                           
   SPAC_NDIFF_1_NTUB_G01DN                                                          
   SPAC_NDIFF_NTUB_G02DN                                                            
   //OVLP_NTUB_NDIFF_G01NW                                                                            
// 3.4 rules
   ILL_PGATE_BONDPAD_G02P1                                                           
   ILL_NGATE_BONDPAD_G02P1                                                           
// deleted    ILL_POLY1_BONDPAD_G01P1                                                           
   ILL_CPOLY_BONDPAD_G02P2                                                           
//  deleted  ILL_POLY2_BONDPAD_G01P2                                                           
// 4.2 rules

   NDRIVER_SPAC_SCON_GATE_E02M1
   NDRIVER_SPAC_DCON_GATE_E03M1
   NDRIVER_SPAC_MET1_GATE_E04M1
   NDRIVER_OVLP_DIFF_CONT_E05M1
   NDRIVER_OVLP_MET1_CONT_E06M1
   NDRIVER_SPAC_NTUB_GATE_E09M1
   NDRIVER_GATE_LENGTH_33V_E10M1
   NDRIVER_FINGER_WIDTH_E12M1_E13M1
   NDRIVER_MISS_PDIFF_E15M1
   NDRIVER_MIN_TRANS_WIDTH_E01M1

// 4.8 rules
   ANALOG_PAD_RBLK_LT200_E01RB                                                                               
   RBLOCK_RDIFFP_RES_LT200_OHM_E01RB                                                                               
   RBLOCK_RPOLY1_RES_LT200_OHM_E01RB                                                                               
   //PAD_NO_RBLOCK_E01RB                                                                               
// end group
//
  GROUP INFO INFO_? ?_INFO
// end group

  GROUP GENERAL_RULES
   SPAC_PDIFF_IN_NTUB_G01DP                                                           
   SNAP_SPAC_DIFFCONS_G02CT                                                                                    
   ND_FORWARD_SPAC_DIFFCONS_G02CT                                                                            
   PD_FORWARD_SPAC_DIFFCONS_G02CT                                                                               
   SNAP_OVLP_NTUB_CONT_G03CT                                                                            
// end group

  GROUP ELEMENT_RULES
   SNAP_SPAC_NDIFF_FIXED_E01SN_INFO                                                                            
   SNAP_BAD_ASYMMETRICAL_INFO                                                                            
   SNAP_BAD_UNIDENTIFIED_INFO                                                                            
   SNAP_EDGE_LENGTH135_E02SN_INFO                                                                            
   SNAP_NDIFFANGLE135_E02SN_INFO                                                                            
   SNAP_OVLP_MET1_CONT_E03SN_INFO                                                                            
   SNAP_OVLP_DIFF_CONT_E04SN_INFO                                                                     
   SNAP_SPAC_NDIFF_UNRELNDIFF_E07SN_INFO                                                                     
   SNAP_LENGTH_ACTIVE_EDGE_E08SN_INFO                                                                     
   SNAP_MINLENGTH_ACTIVE_EDGE_E10SN_INFO                                                                        
   SNAP_MAXLENGTH_ACTIVE_EDGE_E11SN_INFO                                                                        
   SNAP_RATIO_DIFF_CONT_EDGE_E14SN_INFO                                                                     


   PDRIVER_SPAC_SCON_GATE_E02M2 
   PDRIVER_SPAC_DCON_GATE_E03M2 
   PDRIVER_SPAC_MET1_GATE_E04M2 
   PDRIVER_OVLP_DIFF_CONT_E05M2 
   PDRIVER_OVLP_MET1_CONT_E06M2 
   PDRIVER_GATE_LENGTH_33V_E09M2 
   PDRIVER_FINGER_WIDTH_E11M2_E12M2 
   PDRIVER_MISS_PDIFF_E14M2 
   PDRIVER_MIN_TRANS_WIDTH_E01M2 


   ND_FORWARD_SPAC_PNDIFF_E01D1       // { @ Forward N-Diode Element rule E01D1 : no min ndiff/pdiff spacing 0.6 U
   ND_FORWARD_SPAC_DIFFCONS_G02CT     // { @ LV N-Diode Element rule G02CT : diffcons min spacing and size
   ND_FORWARD_MINOVLP_DCONT_E02D1     // { @ Forward N-Diode Element rule E02D1 : diff ovlp of cont should be min = 0.15

   PD_FORWARD_OVLP_NTUB_NDIFF_G01NW   // { @ PD Forward G01NW : Ntub ovlp of ndiff for LV FORWARD  Diode < 1 U
   PD_FORWARD_SPAC_PNDIFF_E01D1       // { @ LV Forward P-Diode Element rule E01DN : no min ndiff/pdiff spacing 0.6 U
   PD_FORWARD_SPAC_DIFFCONS_G02CT     // { @ LV Forward P-Diode Element rule G02CT : diffcons min spacing and size
   PD_FORWARD_MINOVLP_DCONT_E02D1 // { @ LV Forward P-Diode Element rule E02D1 : diff ovlp of cont should be min = 0.15

   ANALOG_PAD_RBLK_LT200_MISSFOR                                                                               
   ANALOG_PAD_RBLK_LT200_MISSCLAMP                                                                               
// end group
// 
  GROUP BUS_RULES
   MISS_SNAP_VDDBUS_B01G                                                                               
   MISS_SNAP_GNDBUS_B01G                                                                               
// end group

//
//======================================================================
//                      pads und busses   
//======================================================================
//
//
// all metal connected to bondpad
//
   CONNECT bondpad routingmet2
// 
// connect text marker
//
   CONNECT text_vdd bondpad
   CONNECT text_vss bondpad
//
   VDD_TEXT_INFO { @ INFO : text vdd 
     COPY text_vdd 
   }
   VSS_TEXT_INFO { @ INFO : text vss 
     COPY text_vss 
   }
//
// get met1 subbus connected to pad
//
   met1_nosubbus_vddtext  = NET AREA RATIO routingmet1 text_vdd > 0
   //met1_nosubbus_vddtext { COPY met1_nosubbus_vddtext }
   met1_con_pad = NET AREA RATIO routingmet1 bondpad > 0
   //met1_con_pad { COPY met1_con_pad }
//
// combine met1 busses :
// find bus via subtap and via gnd txt
// this is necessary for chips with GND without subtap
//
   met1_subbus_subtap    = NET AREA RATIO routingmet1 subtap > 0
   met1_subbus = COPY met1_subbus_subtap
   met1_subbus_gnd_only  = NET AREA RATIO routingmet1 text_vss > 0
   met1_subbus_all = met1_subbus_subtap OR met1_subbus_gnd_only
//
   //met1_subbus { COPY met1_subbus }
   met1_subbus_gndpad = met1_con_pad AND met1_subbus_all
   //met1_subbus_gndpad { COPY met1_subbus_gndpad }
//
// BONDPAD_INFO { @ INFO : bondpad > 70 x 70 U
//     FLATTEN bondpad
// }
//
   GNDPAD_INFO { @ INFO : GND pad 
    FLATTEN ( met1_subbus_gndpad AND bondpad ) 
   }
   VDDPAD_INFO { @ INFO : VDD pad 
    FLATTEN ( met1_nosubbus_vddtext AND bondpad ) 
   }
//
   met1_nosubbus_vddpad = met1_con_pad AND met1_nosubbus_vddtext
   //met1_nosubbus_vddpad { COPY met1_nosubbus_vddpad }
//
// get bondpad no supply
//
   bondpad_nosupply = bondpad NOT INTERACT (met1_subbus_gndpad OR met1_nosubbus_vddtext)
   BONDPAD_NOSUPPLY_INFO { @ INFO : no supply pad
     FLATTEN bondpad_nosupply 
   }
//
//======================================================================
//                             4.7 RBLOCK
//======================================================================
//
//
// rdiffp/rpoly1/rpoly2/rpolyh 
//
// Why is rblock extracted first ?
//
// if rblock < 200 Ohm rblock is shorted and nodes after
// rblock is pad node   
//
// only checked for rdiffp
//
// min resistance of RBLOCK
// worst case process conditions
//
// get restrm connected to bond  pad
//
// for rdiffp,rpoly1,rpoly2
//
   restrm_con_pad = NET AREA RATIO RESTRM bondpad_nosupply > 0
   //restrm_con_pad { COPY restrm_con_pad }
//
// for rpolyh
//
   restrmh_con_pad = NET AREA RATIO preshterm bondpad_nosupply > 0
//
//----------------------------------------------------------------
//  rdiffp blocking res 
//----------------------------------------------------------------
//
// _RDIFFP_typ_ _RDIFFP_typ
// _RDIFFP_min_ _RDIFFP_min
// _RDIFFP_max_ _RDIFFP_max
//
// get rdiff connected
//
   pdre = pdres INTERACT restrm_con_pad 
   xblock = COPY pdre
//
// pdre { COPY pdre }
// RBLOCK_RESISTANCE_INFO { @ INFO : rdiffp rblock resistor found
//    FLATTEN  pdre 
// }
//
// check for w/l
//
   pdre_w           = pdre COINCIDENT EDGE RESTRM
   pdre_l           = pdre NOT COINCIDENT EDGE RESTRM
   pdre_wexp        = pdre_w EXPAND EDGE OUTSIDE BY 0.1
   pdre_lexp        = pdre_l EXPAND EDGE OUTSIDE BY 0.1
   pdre_exp         = SIZE pdre BY 0.1
//<<<<<<<<<<<<<<<<<<<<<<<<<<<
// modified for connectivity
   pdre_exp_net     = COPY pdre_exp
   CONNECT pdre_exp_net
   //pdre_exp_net     = POLYNET pdre_exp
   pdre_wexp_net    = STAMP pdre_wexp BY pdre_exp_net
   pdre_lexp_net    = STAMP pdre_lexp BY pdre_exp_net
//
#UNDEFINE debug
//#IFDEF debug
// 
// get res value with worst case min sheet res
//
// modified 
//  rdiffp rblock resistors
//
// _RDIFFP_typ_ 140
// _RDIFFP_min_ 115
// _RDIFFP_max_ 165
//
// check for very low rblock
//
   RBLOCK_RDIFFP_RES_0_11_5_OHM_INFO { @ INFO E01RB rdiffp block resistor 0 to 11.5 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 0.001  <= 0.1 ))
    }
   RBLOCK_RDIFFP_RES_11_5_23_OHM_INFO { @ INFO E01RB rdiffp block resistor 11.5 to 23 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 0.1  <= 0.2 ))
    }
   RBLOCK_RDIFFP_RES_23_34_5_OHM_INFO { @ INFO E01RB rdiffp block resistor 23 to 34.5 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 0.2  <= 0.3 ))
    }
   RBLOCK_RDIFFP_RES_34_5_46_OHM_INFO { @ INFO E01RB rdiffp block resistor 34.5 to 46 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 0.3  <= 0.4 ))
    }
   RBLOCK_RDIFFP_RES_46_57_5_OHM_INFO { @ INFO E01RB rdiffp block resistor 46 to 57.5 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 0.4  <= 0.5 ))
    }
   RBLOCK_RDIFFP_RES_57_5_69_OHM_INFO { @ INFO E01RB rdiffp block resistor 57.5 to 69 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 0.5  <= 0.6 ))
    }
   RBLOCK_RDIFFP_RES_69_80_5_OHM_INFO { @ INFO E01RB rdiffp block resistor 69 to 80.5 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 0.6  <= 0.7 ))
    }
   RBLOCK_RDIFFP_RES_80_5_92_OHM_INFO { @ INFO E01RB rdiffp block resistor 80.5 to 92 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 0.7  <= 0.8 ))
    }
   RBLOCK_RDIFFP_RES_92_103_5_OHM_INFO { @ INFO E01RB rdiffp block resistor 92 to 103.5 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 0.8  <= 0.9 ))
    }
   RBLOCK_RDIFFP_RES_103_5_115_OHM_INFO { @ INFO E01RB rdiffp block resistor 103.5 to 115 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 0.9  <= 1 ))
    }
   RBLOCK_RDIFFP_RES_115_126_5_OHM_INFO { @ INFO E01RB rdiffp block resistor 115 to 126.5 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 1  <= 1.1 ))
    }
   RBLOCK_RDIFFP_RES_126_5_138_OHM_INFO { @ INFO E01RB rdiffp block resistor 126.5 to 138 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 1.1  <= 1.2 ))
    }
   RBLOCK_RDIFFP_RES_138_149_5_OHM_INFO { @ INFO E01RB rdiffp block resistor 138 to 149.5 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 1.2  <= 1.3 ))
    }
   RBLOCK_RDIFFP_RES_149_5_161_OHM_INFO { @ INFO E01RB rdiffp block resistor 149.5 to 161 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 1.3  <= 1.4 ))
    }
   RBLOCK_RDIFFP_RES_161_172_5_OHM_INFO { @ INFO E01RB rdiffp block resistor 161 to 172.5 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 1.4  <= 1.5 ))
    }
   RBLOCK_RDIFFP_RES_172_5_184_OHM_INFO { @ INFO E01RB rdiffp block resistor 172.5 to 184 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 1.5  <= 1.6 ))
    }
   RBLOCK_RDIFFP_RES_184_195_5_OHM_INFO { @ INFO E01RB rdiffp block resistor 184 to 195.5 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 1.6  <= 1.7 ))
    }
   RBLOCK_RDIFFP_RES_195_5_207_OHM_INFO { @ INFO E01RB rdiffp block resistor 195.5 to 207 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 1.7  <= 1.8 ))
    }
   RBLOCK_RDIFFP_RES_207_218_5_OHM_INFO { @ INFO E01RB rdiffp block resistor 207 to 218.5 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 1.8  <= 1.9 ))
    }
   RBLOCK_RDIFFP_RES_218_5_230_OHM_INFO { @ INFO E01RB rdiffp block resistor 218.5 to 230 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 1.9  <= 2 ))
    }
   RBLOCK_RDIFFP_RES_230_241_5_OHM_INFO { @ INFO E01RB rdiffp block resistor 230 to 241.5 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 2  <= 2.1 ))
    }
   RBLOCK_RDIFFP_RES_241_5_253_OHM_INFO { @ INFO E01RB rdiffp block resistor 241.5 to 253 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 2.1  <= 2.2 ))
    }
   RBLOCK_RDIFFP_RES_253_264_5_OHM_INFO { @ INFO E01RB rdiffp block resistor 253 to 264.5 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 2.2  <= 2.3 ))
    }
   RBLOCK_RDIFFP_RES_264_5_276_OHM_INFO { @ INFO E01RB rdiffp block resistor 264.5 to 276 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 2.3  <= 2.4 ))
    }
   RBLOCK_RDIFFP_RES_276_287_5_OHM_INFO { @ INFO E01RB rdiffp block resistor 276 to 287.5 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 2.4  <= 2.5 ))
    }
   RBLOCK_RDIFFP_RES_287_5_299_OHM_INFO { @ INFO E01RB rdiffp block resistor 287.5 to 299 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 2.5  <= 2.6 ))
    }
   RBLOCK_RDIFFP_RES_299_310_5_OHM_INFO { @ INFO E01RB rdiffp block resistor 299 to 310.5 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 2.6  <= 2.7 ))
    }
   RBLOCK_RDIFFP_RES_310_5_322_OHM_INFO { @ INFO E01RB rdiffp block resistor 310.5 to 322 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 2.7  <= 2.8 ))
    }
   RBLOCK_RDIFFP_RES_322_333_5_OHM_INFO { @ INFO E01RB rdiffp block resistor 322 to 333.5 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 2.8  <= 2.9 ))
    }
   RBLOCK_RDIFFP_RES_333_5_345_OHM_INFO { @ INFO E01RB rdiffp block resistor 333.5 to 345 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 2.9  <= 3 ))
    }
   RBLOCK_RDIFFP_RES_345_356_5_OHM_INFO { @ INFO E01RB rdiffp block resistor 345 to 356.5 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 3  <= 3.1 ))
    }
   RBLOCK_RDIFFP_RES_356_5_368_OHM_INFO { @ INFO E01RB rdiffp block resistor 356.5 to 368 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 3.1  <= 3.2 ))
    }
   RBLOCK_RDIFFP_RES_368_379_5_OHM_INFO { @ INFO E01RB rdiffp block resistor 368 to 379.5 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 3.2  <= 3.3 ))
    }
   RBLOCK_RDIFFP_RES_379_5_391_OHM_INFO { @ INFO E01RB rdiffp block resistor 379.5 to 391 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 3.3  <= 3.4 ))
    }
   RBLOCK_RDIFFP_RES_391_402_5_OHM_INFO { @ INFO E01RB rdiffp block resistor 391 to 402.5 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 3.4  <= 3.5 ))
    }
   RBLOCK_RDIFFP_RES_402_5_414_OHM_INFO { @ INFO E01RB rdiffp block resistor 402.5 to 414 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 3.5  <= 3.6 ))
    }
   RBLOCK_RDIFFP_RES_414_425_5_OHM_INFO { @ INFO E01RB rdiffp block resistor 414 to 425.5 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 3.6  <= 3.7 ))
    }
   RBLOCK_RDIFFP_RES_425_5_437_OHM_INFO { @ INFO E01RB rdiffp block resistor 425.5 to 437 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 3.7  <= 3.8 ))
    }
   RBLOCK_RDIFFP_RES_437_448_5_OHM_INFO { @ INFO E01RB rdiffp block resistor 437 to 448.5 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 3.8  <= 3.9 ))
    }
   RBLOCK_RDIFFP_RES_448_5_460_OHM_INFO { @ INFO E01RB rdiffp block resistor 448.5 to 460 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 3.9  <= 4 ))
    }
   RBLOCK_RDIFFP_RES_460_471_5_OHM_INFO { @ INFO E01RB rdiffp block resistor 460 to 471.5 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 4  <= 4.1 ))
    }
   RBLOCK_RDIFFP_RES_471_5_483_OHM_INFO { @ INFO E01RB rdiffp block resistor 471.5 to 483 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 4.1  <= 4.2 ))
    }
   RBLOCK_RDIFFP_RES_483_494_5_OHM_INFO { @ INFO E01RB rdiffp block resistor 483 to 494.5 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 4.2  <= 4.3 ))
    }
   RBLOCK_RDIFFP_RES_494_5_506_OHM_INFO { @ INFO E01RB rdiffp block resistor 494.5 to 506 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 4.3  <= 4.4 ))
    }
   RBLOCK_RDIFFP_RES_506_517_5_OHM_INFO { @ INFO E01RB rdiffp block resistor 506 to 517.5 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 4.4  <= 4.5 ))
    }
   RBLOCK_RDIFFP_RES_517_5_529_OHM_INFO { @ INFO E01RB rdiffp block resistor 517.5 to 529 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 4.5  <= 4.6 ))
    }
   RBLOCK_RDIFFP_RES_529_540_5_OHM_INFO { @ INFO E01RB rdiffp block resistor 529 to 540.5 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 4.6  <= 4.7 ))
    }
   RBLOCK_RDIFFP_RES_540_5_552_OHM_INFO { @ INFO E01RB rdiffp block resistor 540.5 to 552 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 4.7  <= 4.8 ))
    }
   RBLOCK_RDIFFP_RES_552_563_5_OHM_INFO { @ INFO E01RB rdiffp block resistor 552 to 563.5 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 4.8  <= 4.9 ))
    }
   RBLOCK_RDIFFP_RES_563_5_575_OHM_INFO { @ INFO E01RB rdiffp block resistor 563.5 to 575 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 4.9  <= 5 ))
    }
// max
   RBLOCK_RDIFFP_RES_GT_575_OHM_INFO { @ INFO E01RB rdiffp block resistor gt 575 Ohm ( RS min = 115 )
    FLATTEN ( pdre INTERACT( NET AREA RATIO pdre_lexp_net pdre_wexp_net > 5 ))
    }

//#ENDIF 
//
// 9-Jan-07 :
//
// _RDIFFP_typ_ 140
// _RDIFFP_min_ 115
// _RDIFFP_max_ 165
//
// all rdiffp(rblock) < 200 Ohm
// RS  = 115 min  140 typ 165 max Ohm/square
//
// 1.739  = 200 Ohm/115
//
// worst case 
// E01RB : Minimum res of rblock under worst case conditions
//
   xblock_lt_200 = pdre INTERACT (NET AREA RATIO pdre_lexp_net pdre_wexp_net < 1.739)
   RBLOCK_RDIFFP_RES_LT200_OHM_E01RB { @ E01RB rdiffp block resistor < 200 Ohm ( RS min = 115 )
        FLATTEN xblock_lt_200 
   }
   RBLOCK_RDIFFP_RES_GT200_OHM_INFO { @ INFO : rdiffp block resistor > 200 Ohm ( RS min = 115 ) ok
        FLATTEN( pdre NOT xblock_lt_200 ) 
   }
//
// check for min width of blocking res ( INFO only)
//
   RBLOCK_RDIFFP_WIDTH_RECRDP { @ RECRDP : Minimum RDIFFP RBLOCK connected to pad  width = 5.0
        INT pdre < 5.0 ABUT>0<90 SINGULAR REGION
   }
//
//----------------------------------------------------------------
//  rpoly blocking res 
//----------------------------------------------------------------
//
// _RPOLY_typ_ _RPOLY_typ
// _RPOLY_min_ _RPOLY_min
// _RPOLY_max_ _RPOLY_max
//
// min resistance of RBLOCK
//
// get rpoly1 connected
//
   pre = pres1 INTERACT restrm_con_pad
   xblock_p = COPY pre
//
   RBLOCK_RPOLY1_INFO { @ INFO : rpoly1 rblock resistor found
      FLATTEN  pre
   }
//
// check for w/l
//
   pre_w           = pre COINCIDENT EDGE RESTRM
   pre_l           = pre NOT COINCIDENT EDGE RESTRM
   pre_wexp        = pre_w EXPAND EDGE OUTSIDE BY 0.1
   pre_lexp        = pre_l EXPAND EDGE OUTSIDE BY 0.1
   pre_exp         = SIZE pre BY 0.1
   pre_exp_net     = COPY    pre_exp
   CONNECT pre_exp_net
   //pre_exp_net     = POLYNET pre_exp
   pre_wexp_net    = STAMP pre_wexp BY pre_exp_net
   pre_lexp_net    = STAMP pre_lexp BY pre_exp_net
//
//  rpoly1 rblock resistors
//
// _RPOLY_typ_ 8
// _RPOLY_min_ 5
// _RPOLY_max_ 11
//
   RBLOCK_RPOLY1_RES_0_5_OHM_INFO { @ INFO E01RB rpoly1 block resistor 0 to 5 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 0.01  <= 1 ))
    }
   RBLOCK_RPOLY1_RES_5_10_OHM_INFO { @ INFO E01RB rpoly1 block resistor 5 to 10 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 1  <= 2 ))
    }
   RBLOCK_RPOLY1_RES_10_15_OHM_INFO { @ INFO E01RB rpoly1 block resistor 10 to 15 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 2  <= 3 ))
    }
   RBLOCK_RPOLY1_RES_15_20_OHM_INFO { @ INFO E01RB rpoly1 block resistor 15 to 20 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 3  <= 4 ))
    }
   RBLOCK_RPOLY1_RES_20_25_OHM_INFO { @ INFO E01RB rpoly1 block resistor 20 to 25 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 4  <= 5 ))
    }
   RBLOCK_RPOLY1_RES_25_30_OHM_INFO { @ INFO E01RB rpoly1 block resistor 25 to 30 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 5  <= 6 ))
    }
   RBLOCK_RPOLY1_RES_30_35_OHM_INFO { @ INFO E01RB rpoly1 block resistor 30 to 35 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 6  <= 7 ))
    }
   RBLOCK_RPOLY1_RES_35_40_OHM_INFO { @ INFO E01RB rpoly1 block resistor 35 to 40 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 7  <= 8 ))
    }
   RBLOCK_RPOLY1_RES_40_45_OHM_INFO { @ INFO E01RB rpoly1 block resistor 40 to 45 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 8  <= 9 ))
    }
   RBLOCK_RPOLY1_RES_45_50_OHM_INFO { @ INFO E01RB rpoly1 block resistor 45 to 50 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 9  <= 10 ))
    }
   RBLOCK_RPOLY1_RES_50_55_OHM_INFO { @ INFO E01RB rpoly1 block resistor 50 to 55 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 10  <= 11 ))
    }
   RBLOCK_RPOLY1_RES_55_60_OHM_INFO { @ INFO E01RB rpoly1 block resistor 55 to 60 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 11  <= 12 ))
    }
   RBLOCK_RPOLY1_RES_60_65_OHM_INFO { @ INFO E01RB rpoly1 block resistor 60 to 65 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 12  <= 13 ))
    }
   RBLOCK_RPOLY1_RES_65_70_OHM_INFO { @ INFO E01RB rpoly1 block resistor 65 to 70 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 13  <= 14 ))
    }
   RBLOCK_RPOLY1_RES_70_75_OHM_INFO { @ INFO E01RB rpoly1 block resistor 70 to 75 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 14  <= 15 ))
    }
   RBLOCK_RPOLY1_RES_75_80_OHM_INFO { @ INFO E01RB rpoly1 block resistor 75 to 80 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 15  <= 16 ))
    }
   RBLOCK_RPOLY1_RES_80_85_OHM_INFO { @ INFO E01RB rpoly1 block resistor 80 to 85 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 16  <= 17 ))
    }
   RBLOCK_RPOLY1_RES_85_90_OHM_INFO { @ INFO E01RB rpoly1 block resistor 85 to 90 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 17  <= 18 ))
    }
   RBLOCK_RPOLY1_RES_90_95_OHM_INFO { @ INFO E01RB rpoly1 block resistor 90 to 95 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 18  <= 19 ))
    }
   RBLOCK_RPOLY1_RES_95_100_OHM_INFO { @ INFO E01RB rpoly1 block resistor 95 to 100 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 19  <= 20 ))
    }
   RBLOCK_RPOLY1_RES_100_105_OHM_INFO { @ INFO E01RB rpoly1 block resistor 100 to 105 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 20  <= 21 ))
    }
   RBLOCK_RPOLY1_RES_105_110_OHM_INFO { @ INFO E01RB rpoly1 block resistor 105 to 110 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 21  <= 22 ))
    }
   RBLOCK_RPOLY1_RES_110_115_OHM_INFO { @ INFO E01RB rpoly1 block resistor 110 to 115 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 22  <= 23 ))
    }
   RBLOCK_RPOLY1_RES_115_120_OHM_INFO { @ INFO E01RB rpoly1 block resistor 115 to 120 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 23  <= 24 ))
    }
   RBLOCK_RPOLY1_RES_120_125_OHM_INFO { @ INFO E01RB rpoly1 block resistor 120 to 125 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 24  <= 25 ))
    }
   RBLOCK_RPOLY1_RES_125_130_OHM_INFO { @ INFO E01RB rpoly1 block resistor 125 to 130 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 25  <= 26 ))
    }
   RBLOCK_RPOLY1_RES_130_135_OHM_INFO { @ INFO E01RB rpoly1 block resistor 130 to 135 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 26  <= 27 ))
    }
   RBLOCK_RPOLY1_RES_135_140_OHM_INFO { @ INFO E01RB rpoly1 block resistor 135 to 140 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 27  <= 28 ))
    }
   RBLOCK_RPOLY1_RES_140_145_OHM_INFO { @ INFO E01RB rpoly1 block resistor 140 to 145 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 28  <= 29 ))
    }
   RBLOCK_RPOLY1_RES_145_150_OHM_INFO { @ INFO E01RB rpoly1 block resistor 145 to 150 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 29  <= 30 ))
    }
   RBLOCK_RPOLY1_RES_150_155_OHM_INFO { @ INFO E01RB rpoly1 block resistor 150 to 155 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 30  <= 31 ))
    }
   RBLOCK_RPOLY1_RES_155_160_OHM_INFO { @ INFO E01RB rpoly1 block resistor 155 to 160 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 31  <= 32 ))
    }
   RBLOCK_RPOLY1_RES_160_165_OHM_INFO { @ INFO E01RB rpoly1 block resistor 160 to 165 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 32  <= 33 ))
    }
   RBLOCK_RPOLY1_RES_165_170_OHM_INFO { @ INFO E01RB rpoly1 block resistor 165 to 170 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 33  <= 34 ))
    }
   RBLOCK_RPOLY1_RES_170_175_OHM_INFO { @ INFO E01RB rpoly1 block resistor 170 to 175 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 34  <= 35 ))
    }
   RBLOCK_RPOLY1_RES_175_180_OHM_INFO { @ INFO E01RB rpoly1 block resistor 175 to 180 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 35  <= 36 ))
    }
   RBLOCK_RPOLY1_RES_180_185_OHM_INFO { @ INFO E01RB rpoly1 block resistor 180 to 185 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 36  <= 37 ))
    }
   RBLOCK_RPOLY1_RES_185_190_OHM_INFO { @ INFO E01RB rpoly1 block resistor 185 to 190 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 37  <= 38 ))
    }
   RBLOCK_RPOLY1_RES_190_195_OHM_INFO { @ INFO E01RB rpoly1 block resistor 190 to 195 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 38  <= 39 ))
    }
   RBLOCK_RPOLY1_RES_195_200_OHM_INFO { @ INFO E01RB rpoly1 block resistor 195 to 200 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 39  <= 40 ))
    }
   RBLOCK_RPOLY1_RES_200_205_OHM_INFO { @ INFO E01RB rpoly1 block resistor 200 to 205 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 40  <= 41 ))
    }
   RBLOCK_RPOLY1_RES_205_210_OHM_INFO { @ INFO E01RB rpoly1 block resistor 205 to 210 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 41  <= 42 ))
    }
   RBLOCK_RPOLY1_RES_210_215_OHM_INFO { @ INFO E01RB rpoly1 block resistor 210 to 215 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 42  <= 43 ))
    }
   RBLOCK_RPOLY1_RES_215_220_OHM_INFO { @ INFO E01RB rpoly1 block resistor 215 to 220 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 43  <= 44 ))
    }
   RBLOCK_RPOLY1_RES_220_225_OHM_INFO { @ INFO E01RB rpoly1 block resistor 220 to 225 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 44  <= 45 ))
    }
   RBLOCK_RPOLY1_RES_225_230_OHM_INFO { @ INFO E01RB rpoly1 block resistor 225 to 230 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 45  <= 46 ))
    }
   RBLOCK_RPOLY1_RES_230_235_OHM_INFO { @ INFO E01RB rpoly1 block resistor 230 to 235 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 46  <= 47 ))
    }
   RBLOCK_RPOLY1_RES_235_240_OHM_INFO { @ INFO E01RB rpoly1 block resistor 235 to 240 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 47  <= 48 ))
    }
   RBLOCK_RPOLY1_RES_240_245_OHM_INFO { @ INFO E01RB rpoly1 block resistor 240 to 245 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 48  <= 49 ))
    }
   RBLOCK_RPOLY1_RES_245_250_OHM_INFO { @ INFO E01RB rpoly1 block resistor 245 to 250 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 49  <= 50 ))
    }
   RBLOCK_RPOLY1_RES_250_255_OHM_INFO { @ INFO E01RB rpoly1 block resistor 250 to 255 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 50  <= 51 ))
    }
   RBLOCK_RPOLY1_RES_255_260_OHM_INFO { @ INFO E01RB rpoly1 block resistor 255 to 260 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 51  <= 52 ))
    }
   RBLOCK_RPOLY1_RES_260_265_OHM_INFO { @ INFO E01RB rpoly1 block resistor 260 to 265 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 52  <= 53 ))
    }
   RBLOCK_RPOLY1_RES_265_270_OHM_INFO { @ INFO E01RB rpoly1 block resistor 265 to 270 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 53  <= 54 ))
    }
   RBLOCK_RPOLY1_RES_270_275_OHM_INFO { @ INFO E01RB rpoly1 block resistor 270 to 275 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 54  <= 55 ))
    }
   RBLOCK_RPOLY1_RES_275_280_OHM_INFO { @ INFO E01RB rpoly1 block resistor 275 to 280 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 55  <= 56 ))
    }
   RBLOCK_RPOLY1_RES_280_285_OHM_INFO { @ INFO E01RB rpoly1 block resistor 280 to 285 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 56  <= 57 ))
    }
   RBLOCK_RPOLY1_RES_285_290_OHM_INFO { @ INFO E01RB rpoly1 block resistor 285 to 290 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 57  <= 58 ))
    }
   RBLOCK_RPOLY1_RES_290_295_OHM_INFO { @ INFO E01RB rpoly1 block resistor 290 to 295 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 58  <= 59 ))
    }
   RBLOCK_RPOLY1_RES_295_300_OHM_INFO { @ INFO E01RB rpoly1 block resistor 295 to 300 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 59  <= 60 ))
    }
   RBLOCK_RPOLY1_RES_300_305_OHM_INFO { @ INFO E01RB rpoly1 block resistor 300 to 305 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 60  <= 61 ))
    }
   RBLOCK_RPOLY1_RES_305_310_OHM_INFO { @ INFO E01RB rpoly1 block resistor 305 to 310 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 61  <= 62 ))
    }
   RBLOCK_RPOLY1_RES_310_315_OHM_INFO { @ INFO E01RB rpoly1 block resistor 310 to 315 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 62  <= 63 ))
    }
   RBLOCK_RPOLY1_RES_315_320_OHM_INFO { @ INFO E01RB rpoly1 block resistor 315 to 320 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 63  <= 64 ))
    }
   RBLOCK_RPOLY1_RES_320_325_OHM_INFO { @ INFO E01RB rpoly1 block resistor 320 to 325 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 64  <= 65 ))
    }
   RBLOCK_RPOLY1_RES_325_330_OHM_INFO { @ INFO E01RB rpoly1 block resistor 325 to 330 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 65  <= 66 ))
    }
   RBLOCK_RPOLY1_RES_330_335_OHM_INFO { @ INFO E01RB rpoly1 block resistor 330 to 335 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 66  <= 67 ))
    }
   RBLOCK_RPOLY1_RES_335_340_OHM_INFO { @ INFO E01RB rpoly1 block resistor 335 to 340 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 67  <= 68 ))
    }
   RBLOCK_RPOLY1_RES_340_345_OHM_INFO { @ INFO E01RB rpoly1 block resistor 340 to 345 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 68  <= 69 ))
    }
   RBLOCK_RPOLY1_RES_345_350_OHM_INFO { @ INFO E01RB rpoly1 block resistor 345 to 350 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 69  <= 70 ))
    }
// max
   RBLOCK_RPOLY1_RES_GT_350_OHM_INFO { @ INFO E01RB rpoly1 block resistor gt 350 Ohm ( RS min = 5.0)
    FLATTEN ( pre INTERACT( NET AREA RATIO pre_lexp_net pre_wexp_net > 70        ))
    }
//
// res for min 200/5  = 40 
//
   xblock_p_lt_200 = pre INTERACT (NET AREA RATIO pre_lexp_net pre_wexp_net < 40.0)
//
   RBLOCK_RPOLY1_RES_LT200_OHM_E01RB { @ E01RB rpoly block resistor < 200 Ohm ( RS min = 5   )
        FLATTEN xblock_p_lt_200
   }
   RBLOCK_RPOLY1_RES_GT200_OHM_INFO { @ INFO : rpoly block resistor > 200 Ohm ( RS min = 5   ) ok
        FLATTEN( pre NOT xblock_p_lt_200 )
   }
//
// check for min width of blocking res (INFO only)
//
   RBLOCK_RPOLY1_WIDTH_RECRP1 { @  Minimum RPOLY1 RBLOCK connected to pad  width = 2.0
        INT pre < 2.0 ABUT>0<90 SINGULAR REGION
   }
//
//----------------------------------------------------------------
//  rpoly2 blocking res 
//----------------------------------------------------------------
//
// _RPOLY2_typ_ _RPOLY2_typ
// _RPOLY2_min_ _RPOLY2_min
// _RPOLY2_max_ _RPOLY2_max
//
// min resistance of RBLOCK
//
// get rpoly2 connected
//
   pre2 = pres INTERACT restrm_con_pad
   xblock_p2 = COPY pre2
//
   RBLOCK_RPOLY2_INFO { @ INFO : rpoly2 rblock resistor found
      FLATTEN  pre2
   }
//
// check for w/l
//
   pre2_w           = pre2 COINCIDENT EDGE RESTRM
   pre2_l           = pre2 NOT COINCIDENT EDGE RESTRM
   pre2_wexp        = pre2_w EXPAND EDGE OUTSIDE BY 0.1
   pre2_lexp        = pre2_l EXPAND EDGE OUTSIDE BY 0.1
   pre2_exp         = SIZE pre2 BY 0.1
   pre2_exp_net     = COPY    pre2_exp
   CONNECT pre2_exp_net
   //pre_exp_net     = POLYNET pre_exp
   pre2_wexp_net    = STAMP pre2_wexp BY pre2_exp_net
   pre2_lexp_net    = STAMP pre2_lexp BY pre2_exp_net
//
//  rpoly2 rblock resistors
//
// _RPOLY2_typ_ 50
// _RPOLY2_min_ 40
// _RPOLY2_max_ 60
//
   RBLOCK_RPOLY2_RES_0_10_OHM_INFO { @ INFO E01RB rpoly2 block resistor 0 to 10 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 0.001  <= 0.25 ))
    }
   RBLOCK_RPOLY2_RES_10_20_OHM_INFO { @ INFO E01RB rpoly2 block resistor 10 to 20 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 0.25  <= 0.5 ))
    }
   RBLOCK_RPOLY2_RES_20_30_OHM_INFO { @ INFO E01RB rpoly2 block resistor 20 to 30 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 0.5  <= 0.75 ))
    }
   RBLOCK_RPOLY2_RES_30_40_OHM_INFO { @ INFO E01RB rpoly2 block resistor 30 to 40 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 0.75  <= 1 ))
    }
   RBLOCK_RPOLY2_RES_40_50_OHM_INFO { @ INFO E01RB rpoly2 block resistor 40 to 50 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 1  <= 1.25 ))
    }
   RBLOCK_RPOLY2_RES_50_60_OHM_INFO { @ INFO E01RB rpoly2 block resistor 50 to 60 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 1.25  <= 1.5 ))
    }
   RBLOCK_RPOLY2_RES_60_70_OHM_INFO { @ INFO E01RB rpoly2 block resistor 60 to 70 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 1.5  <= 1.75 ))
    }
   RBLOCK_RPOLY2_RES_70_80_OHM_INFO { @ INFO E01RB rpoly2 block resistor 70 to 80 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 1.75  <= 2 ))
    }
   RBLOCK_RPOLY2_RES_80_90_OHM_INFO { @ INFO E01RB rpoly2 block resistor 80 to 90 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 2  <= 2.25 ))
    }
   RBLOCK_RPOLY2_RES_90_100_OHM_INFO { @ INFO E01RB rpoly2 block resistor 90 to 100 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 2.25  <= 2.5 ))
    }
   RBLOCK_RPOLY2_RES_100_110_OHM_INFO { @ INFO E01RB rpoly2 block resistor 100 to 110 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 2.5  <= 2.75 ))
    }
   RBLOCK_RPOLY2_RES_110_120_OHM_INFO { @ INFO E01RB rpoly2 block resistor 110 to 120 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 2.75  <= 3 ))
    }
   RBLOCK_RPOLY2_RES_120_130_OHM_INFO { @ INFO E01RB rpoly2 block resistor 120 to 130 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 3  <= 3.25 ))
    }
   RBLOCK_RPOLY2_RES_130_140_OHM_INFO { @ INFO E01RB rpoly2 block resistor 130 to 140 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 3.25  <= 3.5 ))
    }
   RBLOCK_RPOLY2_RES_140_150_OHM_INFO { @ INFO E01RB rpoly2 block resistor 140 to 150 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 3.5  <= 3.75 ))
    }
   RBLOCK_RPOLY2_RES_150_160_OHM_INFO { @ INFO E01RB rpoly2 block resistor 150 to 160 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 3.75  <= 4 ))
    }
   RBLOCK_RPOLY2_RES_160_170_OHM_INFO { @ INFO E01RB rpoly2 block resistor 160 to 170 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 4  <= 4.25 ))
    }
   RBLOCK_RPOLY2_RES_170_180_OHM_INFO { @ INFO E01RB rpoly2 block resistor 170 to 180 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 4.25  <= 4.5 ))
    }
   RBLOCK_RPOLY2_RES_180_190_OHM_INFO { @ INFO E01RB rpoly2 block resistor 180 to 190 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 4.5  <= 4.75 ))
    }
   RBLOCK_RPOLY2_RES_190_200_OHM_INFO { @ INFO E01RB rpoly2 block resistor 190 to 200 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 4.75  <= 5 ))
    }
   RBLOCK_RPOLY2_RES_200_210_OHM_INFO { @ INFO E01RB rpoly2 block resistor 200 to 210 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 5  <= 5.25 ))
    }
   RBLOCK_RPOLY2_RES_210_220_OHM_INFO { @ INFO E01RB rpoly2 block resistor 210 to 220 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 5.25  <= 5.5 ))
    }
   RBLOCK_RPOLY2_RES_220_230_OHM_INFO { @ INFO E01RB rpoly2 block resistor 220 to 230 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 5.5  <= 5.75 ))
    }
   RBLOCK_RPOLY2_RES_230_240_OHM_INFO { @ INFO E01RB rpoly2 block resistor 230 to 240 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 5.75  <= 6 ))
    }
   RBLOCK_RPOLY2_RES_240_250_OHM_INFO { @ INFO E01RB rpoly2 block resistor 240 to 250 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 6  <= 6.25 ))
    }
   RBLOCK_RPOLY2_RES_250_260_OHM_INFO { @ INFO E01RB rpoly2 block resistor 250 to 260 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 6.25  <= 6.5 ))
    }
   RBLOCK_RPOLY2_RES_260_270_OHM_INFO { @ INFO E01RB rpoly2 block resistor 260 to 270 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 6.5  <= 6.75 ))
    }
   RBLOCK_RPOLY2_RES_270_280_OHM_INFO { @ INFO E01RB rpoly2 block resistor 270 to 280 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 6.75  <= 7 ))
    }
   RBLOCK_RPOLY2_RES_280_290_OHM_INFO { @ INFO E01RB rpoly2 block resistor 280 to 290 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 7  <= 7.25 ))
    }
   RBLOCK_RPOLY2_RES_290_300_OHM_INFO { @ INFO E01RB rpoly2 block resistor 290 to 300 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 7.25  <= 7.5 ))
    }
   RBLOCK_RPOLY2_RES_300_310_OHM_INFO { @ INFO E01RB rpoly2 block resistor 300 to 310 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 7.5  <= 7.75 ))
    }
   RBLOCK_RPOLY2_RES_310_320_OHM_INFO { @ INFO E01RB rpoly2 block resistor 310 to 320 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 7.75  <= 8 ))
    }
   RBLOCK_RPOLY2_RES_320_330_OHM_INFO { @ INFO E01RB rpoly2 block resistor 320 to 330 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 8  <= 8.25 ))
    }
   RBLOCK_RPOLY2_RES_330_340_OHM_INFO { @ INFO E01RB rpoly2 block resistor 330 to 340 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 8.25  <= 8.5 ))
    }
   RBLOCK_RPOLY2_RES_340_350_OHM_INFO { @ INFO E01RB rpoly2 block resistor 340 to 350 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 8.5  <= 8.75 ))
    }
   RBLOCK_RPOLY2_RES_350_360_OHM_INFO { @ INFO E01RB rpoly2 block resistor 350 to 360 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 8.75  <= 9 ))
    }
   RBLOCK_RPOLY2_RES_360_370_OHM_INFO { @ INFO E01RB rpoly2 block resistor 360 to 370 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 9  <= 9.25 ))
    }
   RBLOCK_RPOLY2_RES_370_380_OHM_INFO { @ INFO E01RB rpoly2 block resistor 370 to 380 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 9.25  <= 9.5 ))
    }
   RBLOCK_RPOLY2_RES_380_390_OHM_INFO { @ INFO E01RB rpoly2 block resistor 380 to 390 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 9.5  <= 9.75 ))
    }
   RBLOCK_RPOLY2_RES_390_400_OHM_INFO { @ INFO E01RB rpoly2 block resistor 390 to 400 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 9.75  <= 10 ))
    }
   RBLOCK_RPOLY2_RES_400_410_OHM_INFO { @ INFO E01RB rpoly2 block resistor 400 to 410 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 10  <= 10.25 ))
    }
   RBLOCK_RPOLY2_RES_410_420_OHM_INFO { @ INFO E01RB rpoly2 block resistor 410 to 420 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 10.25  <= 10.5 ))
    }
   RBLOCK_RPOLY2_RES_420_430_OHM_INFO { @ INFO E01RB rpoly2 block resistor 420 to 430 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 10.5  <= 10.75 ))
    }
   RBLOCK_RPOLY2_RES_430_440_OHM_INFO { @ INFO E01RB rpoly2 block resistor 430 to 440 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 10.75  <= 11 ))
    }
   RBLOCK_RPOLY2_RES_440_450_OHM_INFO { @ INFO E01RB rpoly2 block resistor 440 to 450 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 11  <= 11.25 ))
    }
   RBLOCK_RPOLY2_RES_450_460_OHM_INFO { @ INFO E01RB rpoly2 block resistor 450 to 460 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 11.25  <= 11.5 ))
    }
   RBLOCK_RPOLY2_RES_460_470_OHM_INFO { @ INFO E01RB rpoly2 block resistor 460 to 470 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 11.5  <= 11.75 ))
    }
   RBLOCK_RPOLY2_RES_470_480_OHM_INFO { @ INFO E01RB rpoly2 block resistor 470 to 480 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 11.75  <= 12 ))
    }
   RBLOCK_RPOLY2_RES_480_490_OHM_INFO { @ INFO E01RB rpoly2 block resistor 480 to 490 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 12  <= 12.25 ))
    }
   RBLOCK_RPOLY2_RES_490_500_OHM_INFO { @ INFO E01RB rpoly2 block resistor 490 to 500 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 12.25  <= 12.5 ))
    }
   RBLOCK_RPOLY2_RES_500_510_OHM_INFO { @ INFO E01RB rpoly2 block resistor 500 to 510 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 12.5  <= 12.75 ))
    }
   RBLOCK_RPOLY2_RES_510_520_OHM_INFO { @ INFO E01RB rpoly2 block resistor 510 to 520 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 12.75  <= 13 ))
    }
   RBLOCK_RPOLY2_RES_520_530_OHM_INFO { @ INFO E01RB rpoly2 block resistor 520 to 530 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 13  <= 13.25 ))
    }
   RBLOCK_RPOLY2_RES_530_540_OHM_INFO { @ INFO E01RB rpoly2 block resistor 530 to 540 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 13.25  <= 13.5 ))
    }
   RBLOCK_RPOLY2_RES_540_550_OHM_INFO { @ INFO E01RB rpoly2 block resistor 540 to 550 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 13.5  <= 13.75 ))
    }
   RBLOCK_RPOLY2_RES_550_560_OHM_INFO { @ INFO E01RB rpoly2 block resistor 550 to 560 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 13.75  <= 14 ))
    }
   RBLOCK_RPOLY2_RES_560_570_OHM_INFO { @ INFO E01RB rpoly2 block resistor 560 to 570 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 14  <= 14.25 ))
    }
   RBLOCK_RPOLY2_RES_570_580_OHM_INFO { @ INFO E01RB rpoly2 block resistor 570 to 580 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 14.25  <= 14.5 ))
    }
   RBLOCK_RPOLY2_RES_580_590_OHM_INFO { @ INFO E01RB rpoly2 block resistor 580 to 590 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 14.5  <= 14.75 ))
    }
   RBLOCK_RPOLY2_RES_590_600_OHM_INFO { @ INFO E01RB rpoly2 block resistor 590 to 600 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 14.75  <= 15 ))
    }
   RBLOCK_RPOLY2_RES_600_610_OHM_INFO { @ INFO E01RB rpoly2 block resistor 600 to 610 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 15  <= 15.25 ))
    }
   RBLOCK_RPOLY2_RES_610_620_OHM_INFO { @ INFO E01RB rpoly2 block resistor 610 to 620 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 15.25  <= 15.5 ))
    }
   RBLOCK_RPOLY2_RES_620_630_OHM_INFO { @ INFO E01RB rpoly2 block resistor 620 to 630 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 15.5  <= 15.75 ))
    }
   RBLOCK_RPOLY2_RES_630_640_OHM_INFO { @ INFO E01RB rpoly2 block resistor 630 to 640 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 15.75  <= 16 ))
    }
   RBLOCK_RPOLY2_RES_640_650_OHM_INFO { @ INFO E01RB rpoly2 block resistor 640 to 650 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 16  <= 16.25 ))
    }
   RBLOCK_RPOLY2_RES_650_660_OHM_INFO { @ INFO E01RB rpoly2 block resistor 650 to 660 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 16.25  <= 16.5 ))
    }
   RBLOCK_RPOLY2_RES_660_670_OHM_INFO { @ INFO E01RB rpoly2 block resistor 660 to 670 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 16.5  <= 16.75 ))
    }
   RBLOCK_RPOLY2_RES_670_680_OHM_INFO { @ INFO E01RB rpoly2 block resistor 670 to 680 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 16.75  <= 17 ))
    }
   RBLOCK_RPOLY2_RES_680_690_OHM_INFO { @ INFO E01RB rpoly2 block resistor 680 to 690 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 17  <= 17.25 ))
    }
   RBLOCK_RPOLY2_RES_690_700_OHM_INFO { @ INFO E01RB rpoly2 block resistor 690 to 700 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 17.25  <= 17.5 ))
    }
   RBLOCK_RPOLY2_RES_700_710_OHM_INFO { @ INFO E01RB rpoly2 block resistor 700 to 710 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 17.5  <= 17.75 ))
    }
   RBLOCK_RPOLY2_RES_710_720_OHM_INFO { @ INFO E01RB rpoly2 block resistor 710 to 720 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 17.75  <= 18 ))
    }
   RBLOCK_RPOLY2_RES_720_730_OHM_INFO { @ INFO E01RB rpoly2 block resistor 720 to 730 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 18  <= 18.25 ))
    }
   RBLOCK_RPOLY2_RES_730_740_OHM_INFO { @ INFO E01RB rpoly2 block resistor 730 to 740 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 18.25  <= 18.5 ))
    }
   RBLOCK_RPOLY2_RES_740_750_OHM_INFO { @ INFO E01RB rpoly2 block resistor 740 to 750 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 18.5  <= 18.75 ))
    }
   RBLOCK_RPOLY2_RES_750_760_OHM_INFO { @ INFO E01RB rpoly2 block resistor 750 to 760 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 18.75  <= 19 ))
    }
   RBLOCK_RPOLY2_RES_760_770_OHM_INFO { @ INFO E01RB rpoly2 block resistor 760 to 770 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 19  <= 19.25 ))
    }
   RBLOCK_RPOLY2_RES_770_780_OHM_INFO { @ INFO E01RB rpoly2 block resistor 770 to 780 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 19.25  <= 19.5 ))
    }
   RBLOCK_RPOLY2_RES_780_790_OHM_INFO { @ INFO E01RB rpoly2 block resistor 780 to 790 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 19.5  <= 19.75 ))
    }
   RBLOCK_RPOLY2_RES_790_800_OHM_INFO { @ INFO E01RB rpoly2 block resistor 790 to 800 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 19.75  <= 20 ))
    }
   RBLOCK_RPOLY2_RES_800_810_OHM_INFO { @ INFO E01RB rpoly2 block resistor 800 to 810 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 20  <= 20.25 ))
    }
   RBLOCK_RPOLY2_RES_810_820_OHM_INFO { @ INFO E01RB rpoly2 block resistor 810 to 820 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 20.25  <= 20.5 ))
    }
   RBLOCK_RPOLY2_RES_820_830_OHM_INFO { @ INFO E01RB rpoly2 block resistor 820 to 830 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 20.5  <= 20.75 ))
    }
   RBLOCK_RPOLY2_RES_830_840_OHM_INFO { @ INFO E01RB rpoly2 block resistor 830 to 840 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 20.75  <= 21 ))
    }
   RBLOCK_RPOLY2_RES_840_850_OHM_INFO { @ INFO E01RB rpoly2 block resistor 840 to 850 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 21  <= 21.25 ))
    }
   RBLOCK_RPOLY2_RES_850_860_OHM_INFO { @ INFO E01RB rpoly2 block resistor 850 to 860 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 21.25  <= 21.5 ))
    }
   RBLOCK_RPOLY2_RES_860_870_OHM_INFO { @ INFO E01RB rpoly2 block resistor 860 to 870 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 21.5  <= 21.75 ))
    }
   RBLOCK_RPOLY2_RES_870_880_OHM_INFO { @ INFO E01RB rpoly2 block resistor 870 to 880 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 21.75  <= 22 ))
    }
   RBLOCK_RPOLY2_RES_880_890_OHM_INFO { @ INFO E01RB rpoly2 block resistor 880 to 890 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 22  <= 22.25 ))
    }
   RBLOCK_RPOLY2_RES_890_900_OHM_INFO { @ INFO E01RB rpoly2 block resistor 890 to 900 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 22.25  <= 22.5 ))
    }
   RBLOCK_RPOLY2_RES_900_910_OHM_INFO { @ INFO E01RB rpoly2 block resistor 900 to 910 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 22.5  <= 22.75 ))
    }
   RBLOCK_RPOLY2_RES_910_920_OHM_INFO { @ INFO E01RB rpoly2 block resistor 910 to 920 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 22.75  <= 23 ))
    }
   RBLOCK_RPOLY2_RES_920_930_OHM_INFO { @ INFO E01RB rpoly2 block resistor 920 to 930 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 23  <= 23.25 ))
    }
   RBLOCK_RPOLY2_RES_930_940_OHM_INFO { @ INFO E01RB rpoly2 block resistor 930 to 940 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 23.25  <= 23.5 ))
    }
   RBLOCK_RPOLY2_RES_940_950_OHM_INFO { @ INFO E01RB rpoly2 block resistor 940 to 950 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 23.5  <= 23.75 ))
    }
   RBLOCK_RPOLY2_RES_950_960_OHM_INFO { @ INFO E01RB rpoly2 block resistor 950 to 960 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 23.75  <= 24 ))
    }
   RBLOCK_RPOLY2_RES_960_970_OHM_INFO { @ INFO E01RB rpoly2 block resistor 960 to 970 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 24  <= 24.25 ))
    }
   RBLOCK_RPOLY2_RES_970_980_OHM_INFO { @ INFO E01RB rpoly2 block resistor 970 to 980 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 24.25  <= 24.5 ))
    }
   RBLOCK_RPOLY2_RES_980_990_OHM_INFO { @ INFO E01RB rpoly2 block resistor 980 to 990 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 24.5  <= 24.75 ))
    }
   RBLOCK_RPOLY2_RES_990_1000_OHM_INFO { @ INFO E01RB rpoly2 block resistor 990 to 1000 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 24.75  <= 25 ))
    }
//
   RBLOCK_RPOLY2_RES_GT_1000_OHM_INFO { @ INFO E01RB rpoly2 block resistor gt 1000 Ohm ( RS min = 40.0)
    FLATTEN ( pre2 INTERACT( NET AREA RATIO pre2_lexp_net pre2_wexp_net > 25  ))
    }
//
// res for min 200/40  = 5 
//
   xblock_p2_lt_200 = pre2 INTERACT (NET AREA RATIO pre2_lexp_net pre2_wexp_net < 5.0)
//
   RBLOCK_RPOLY2_RES_LT200_OHM_E01RB { @ E01RB rpoly2 block resistor < 200 Ohm ( RS min = 40   )
        FLATTEN xblock_p2_lt_200
   }
   RBLOCK_RPOLY2_RES_GT200_OHM_INFO { @ INFO : rpoly2 block resistor > 200 Ohm ( RS min = 40   ) ok
        FLATTEN( pre2 NOT xblock_p2_lt_200 )
   }
//
// check for min width of blocking res (INFO only)
//
   RBLOCK_RPOLY2_WIDTH_RECRP2 { @  Minimum RPOLY2 RBLOCK connected to pad  width = 3.0
        INT pre2 < 3.0 ABUT>0<90 SINGULAR REGION
   }
//
//----------------------------------------------------------------
//  rpolyh blocking res 
//----------------------------------------------------------------
//
// _RPOLYH_typ_ _RPOLYH_typ
// _RPOLYH_min_ _RPOLYH_min
// _RPOLYH_max_ _RPOLYH_max
//
// min resistance of RBLOCK
//
// get rpolyh connected
//
// extra terminal
//
   preh = presh INTERACT restrmh_con_pad
   xblock_ph = COPY preh
//
   RBLOCK_RPOLYH_INFO { @ INFO : rpolyh rblock resistor found
      FLATTEN  preh
   }
//
// check for w/l
//
   preh_w           = preh COINCIDENT EDGE RESTRM
   preh_l           = preh NOT COINCIDENT EDGE RESTRM
   preh_wexp        = preh_w EXPAND EDGE OUTSIDE BY 0.1
   preh_lexp        = preh_l EXPAND EDGE OUTSIDE BY 0.1
   preh_exp         = SIZE preh BY 0.1
   preh_exp_net     = COPY    preh_exp
   CONNECT preh_exp_net
   //pre_exp_net     = POLYNET pre_exp
   preh_wexp_net    = STAMP preh_wexp BY preh_exp_net
   preh_lexp_net    = STAMP preh_lexp BY preh_exp_net
//
// _RPOLYH_typ_ 1.2k
// _RPOLYH_min_ 1k
// _RPOLYH_max_ 1.4k
//
   RBLOCK_RPOLYH_RES_0_10_OHM_INFO { @ INFO E01RB rpolyh block resistor 0 to 10 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.001  <= 0.01 ))
    }
   RBLOCK_RPOLYH_RES_10_20_OHM_INFO { @ INFO E01RB rpolyh block resistor 10 to 20 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.01  <= 0.02 ))
    }
   RBLOCK_RPOLYH_RES_20_30_OHM_INFO { @ INFO E01RB rpolyh block resistor 20 to 30 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.02  <= 0.03 ))
    }
   RBLOCK_RPOLYH_RES_30_40_OHM_INFO { @ INFO E01RB rpolyh block resistor 30 to 40 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.03  <= 0.04 ))
    }
   RBLOCK_RPOLYH_RES_40_50_OHM_INFO { @ INFO E01RB rpolyh block resistor 40 to 50 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.04  <= 0.05 ))
    }
   RBLOCK_RPOLYH_RES_50_60_OHM_INFO { @ INFO E01RB rpolyh block resistor 50 to 60 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.05  <= 0.06 ))
    }
   RBLOCK_RPOLYH_RES_60_70_OHM_INFO { @ INFO E01RB rpolyh block resistor 60 to 70 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.06  <= 0.07 ))
    }
   RBLOCK_RPOLYH_RES_70_80_OHM_INFO { @ INFO E01RB rpolyh block resistor 70 to 80 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.07  <= 0.08 ))
    }
   RBLOCK_RPOLYH_RES_80_90_OHM_INFO { @ INFO E01RB rpolyh block resistor 80 to 90 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.08  <= 0.09 ))
    }
   RBLOCK_RPOLYH_RES_90_100_OHM_INFO { @ INFO E01RB rpolyh block resistor 90 to 100 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.09  <= 0.1 ))
    }
   RBLOCK_RPOLYH_RES_100_110_OHM_INFO { @ INFO E01RB rpolyh block resistor 100 to 110 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.1  <= 0.11 ))
    }
   RBLOCK_RPOLYH_RES_110_120_OHM_INFO { @ INFO E01RB rpolyh block resistor 110 to 120 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.11  <= 0.12 ))
    }
   RBLOCK_RPOLYH_RES_120_130_OHM_INFO { @ INFO E01RB rpolyh block resistor 120 to 130 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.12  <= 0.13 ))
    }
   RBLOCK_RPOLYH_RES_130_140_OHM_INFO { @ INFO E01RB rpolyh block resistor 130 to 140 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.13  <= 0.14 ))
    }
   RBLOCK_RPOLYH_RES_140_150_OHM_INFO { @ INFO E01RB rpolyh block resistor 140 to 150 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.14  <= 0.15 ))
    }
   RBLOCK_RPOLYH_RES_150_160_OHM_INFO { @ INFO E01RB rpolyh block resistor 150 to 160 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.15  <= 0.16 ))
    }
   RBLOCK_RPOLYH_RES_160_170_OHM_INFO { @ INFO E01RB rpolyh block resistor 160 to 170 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.16  <= 0.17 ))
    }
   RBLOCK_RPOLYH_RES_170_180_OHM_INFO { @ INFO E01RB rpolyh block resistor 170 to 180 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.17  <= 0.18 ))
    }
   RBLOCK_RPOLYH_RES_180_190_OHM_INFO { @ INFO E01RB rpolyh block resistor 180 to 190 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.18  <= 0.19 ))
    }
   RBLOCK_RPOLYH_RES_190_200_OHM_INFO { @ INFO E01RB rpolyh block resistor 190 to 200 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.19  <= 0.2 ))
    }
   RBLOCK_RPOLYH_RES_200_210_OHM_INFO { @ INFO E01RB rpolyh block resistor 200 to 210 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.2  <= 0.21 ))
    }
   RBLOCK_RPOLYH_RES_210_220_OHM_INFO { @ INFO E01RB rpolyh block resistor 210 to 220 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.21  <= 0.22 ))
    }
   RBLOCK_RPOLYH_RES_220_230_OHM_INFO { @ INFO E01RB rpolyh block resistor 220 to 230 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.22  <= 0.23 ))
    }
   RBLOCK_RPOLYH_RES_230_240_OHM_INFO { @ INFO E01RB rpolyh block resistor 230 to 240 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.23  <= 0.24 ))
    }
   RBLOCK_RPOLYH_RES_240_250_OHM_INFO { @ INFO E01RB rpolyh block resistor 240 to 250 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.24  <= 0.25 ))
    }
   RBLOCK_RPOLYH_RES_250_260_OHM_INFO { @ INFO E01RB rpolyh block resistor 250 to 260 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.25  <= 0.26 ))
    }
   RBLOCK_RPOLYH_RES_260_270_OHM_INFO { @ INFO E01RB rpolyh block resistor 260 to 270 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.26  <= 0.27 ))
    }
   RBLOCK_RPOLYH_RES_270_280_OHM_INFO { @ INFO E01RB rpolyh block resistor 270 to 280 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.27  <= 0.28 ))
    }
   RBLOCK_RPOLYH_RES_280_290_OHM_INFO { @ INFO E01RB rpolyh block resistor 280 to 290 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.28  <= 0.29 ))
    }
   RBLOCK_RPOLYH_RES_290_300_OHM_INFO { @ INFO E01RB rpolyh block resistor 290 to 300 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.29  <= 0.3 ))
    }
   RBLOCK_RPOLYH_RES_300_310_OHM_INFO { @ INFO E01RB rpolyh block resistor 300 to 310 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.3  <= 0.31 ))
    }
   RBLOCK_RPOLYH_RES_310_320_OHM_INFO { @ INFO E01RB rpolyh block resistor 310 to 320 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.31  <= 0.32 ))
    }
   RBLOCK_RPOLYH_RES_320_330_OHM_INFO { @ INFO E01RB rpolyh block resistor 320 to 330 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.32  <= 0.33 ))
    }
   RBLOCK_RPOLYH_RES_330_340_OHM_INFO { @ INFO E01RB rpolyh block resistor 330 to 340 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.33  <= 0.34 ))
    }
   RBLOCK_RPOLYH_RES_340_350_OHM_INFO { @ INFO E01RB rpolyh block resistor 340 to 350 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.34  <= 0.35 ))
    }
   RBLOCK_RPOLYH_RES_350_360_OHM_INFO { @ INFO E01RB rpolyh block resistor 350 to 360 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.35  <= 0.36 ))
    }
   RBLOCK_RPOLYH_RES_360_370_OHM_INFO { @ INFO E01RB rpolyh block resistor 360 to 370 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.36  <= 0.37 ))
    }
   RBLOCK_RPOLYH_RES_370_380_OHM_INFO { @ INFO E01RB rpolyh block resistor 370 to 380 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.37  <= 0.38 ))
    }
   RBLOCK_RPOLYH_RES_380_390_OHM_INFO { @ INFO E01RB rpolyh block resistor 380 to 390 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.38  <= 0.39 ))
    }
   RBLOCK_RPOLYH_RES_390_400_OHM_INFO { @ INFO E01RB rpolyh block resistor 390 to 400 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.39  <= 0.4 ))
    }
   RBLOCK_RPOLYH_RES_400_410_OHM_INFO { @ INFO E01RB rpolyh block resistor 400 to 410 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.4  <= 0.41 ))
    }
   RBLOCK_RPOLYH_RES_410_420_OHM_INFO { @ INFO E01RB rpolyh block resistor 410 to 420 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.41  <= 0.42 ))
    }
   RBLOCK_RPOLYH_RES_420_430_OHM_INFO { @ INFO E01RB rpolyh block resistor 420 to 430 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.42  <= 0.43 ))
    }
   RBLOCK_RPOLYH_RES_430_440_OHM_INFO { @ INFO E01RB rpolyh block resistor 430 to 440 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.43  <= 0.44 ))
    }
   RBLOCK_RPOLYH_RES_440_450_OHM_INFO { @ INFO E01RB rpolyh block resistor 440 to 450 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.44  <= 0.45 ))
    }
   RBLOCK_RPOLYH_RES_450_460_OHM_INFO { @ INFO E01RB rpolyh block resistor 450 to 460 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.45  <= 0.46 ))
    }
   RBLOCK_RPOLYH_RES_460_470_OHM_INFO { @ INFO E01RB rpolyh block resistor 460 to 470 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.46  <= 0.47 ))
    }
   RBLOCK_RPOLYH_RES_470_480_OHM_INFO { @ INFO E01RB rpolyh block resistor 470 to 480 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.47  <= 0.48 ))
    }
   RBLOCK_RPOLYH_RES_480_490_OHM_INFO { @ INFO E01RB rpolyh block resistor 480 to 490 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.48  <= 0.49 ))
    }
   RBLOCK_RPOLYH_RES_490_500_OHM_INFO { @ INFO E01RB rpolyh block resistor 490 to 500 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.49  <= 0.5 ))
    }
// max
   RBLOCK_RPOLYH_RES_GT_500_OHM_INFO { @ INFO E01RB rpolyh block resistor gt 500 Ohm ( RS min = 1k)
    FLATTEN ( preh INTERACT( NET AREA RATIO preh_lexp_net preh_wexp_net > 0.5  ))
    }
//
// res for min 200/1000  = 0.2
//
   xblock_ph_lt_200 = preh INTERACT (NET AREA RATIO preh_lexp_net preh_wexp_net < 0.2)
//
   RBLOCK_RPOLYh_RES_LT200_OHM_E01RB { @ E01RB rpolyh block resistor < 200 Ohm ( RS min = 1k   )
        FLATTEN xblock_ph_lt_200
   }
   RBLOCK_RPOLYh_RES_GT200_OHM_INFO { @ INFO : rpolyh block resistor > 200 Ohm ( RS min = 1k   ) ok
        FLATTEN( preh NOT xblock_ph_lt_200 )
   }
//
// check for min width of blocking res (INFO only)
//
   RBLOCK_RPOLYH_WIDTH_RECRPH { @  Minimum RPOLYH RBLOCK connected to pad  width = 15.0
        INT preh < 15.0 ABUT>0<90 SINGULAR REGION
   }
// 
// get pads without blocking res
//
// <<<<<<<<<<<<<<<<<<
// modified for connectivity
   met1_con_pad_1 = COPY met1_con_pad
   met1_con_pad_2  = STAMP met1_con_pad_1 BY routingmet1
   restrm_con_pad_10  = COPY restrm_con_pad
   restrm_con_pad_20= STAMP restrm_con_pad_10 BY RESTRM 
// <<<<<<<<<<<<<<<<<<
//
// add rdiffp and rpoly1/2/h
//
   xblock_all = xblock OR (xblock_p OR (xblock_p2 OR xblock_ph))
//
   met1_pad_rd = NET AREA RATIO met1_con_pad_2 (restrm_con_pad_20 INTERACT xblock_all) > 0
   // met1_pad_rd { FLATTEN met1_pad_rd }
   PAD_NO_RBLOCK_E01RB { @ Warning : Unprotected input pad, pad with no rdiffp/rpoly1/rpoly2/rpolyh blocking resistor
      FLATTEN ( bondpad_nosupply NOT ( met1_pad_rd AND bondpad_nosupply))
   }
//
// rblock is shorted later
//
// internal node is pad node if rblock < 200 
// 
// for testing only
// gate_con_pad = NET AREA RATIO trans bondpad > 0
// gate_con_pad { COPY gate_con_pad }
//
//======================================================================
//
//                          ELEMENT RULES
//
//======================================================================
//
// SNAP is disabled in Doc Rev 2 .... onfo only
//======================================================================
//                    4.1 SNAP ELEMENT RULES
//======================================================================
//
// xeval(s_DF+ 0.05)
//
//
   ndiff_con_pad = ndiff ENCLOSE routingnwell 
// ndiff_con_pad { COPY ndiff_con_pad }
//
// only for debug
// get all ndiff at min diff connected to different bond pads
// ndiff_con_pad = NET AREA RATIO ndiff bondpad > 0
//
// E01SN Fixed min ndiff spacing used for device extraction
//-----------------------------------------------------------
// search up to 1 U
//
   snap_samepot_fill_1 = EXT ndiff_con_pad < 1.0 OPPOSITE PARA ONLY CONNECTED REGION
   snap_diffpot_fill_1 = EXT ndiff_con_pad < 1.0 OPPOSITE PARA ONLY NOT CONNECTED REGION
//
   esd_trans     = diff_cut AND routingpoly
   snap_diffpot_fill  = snap_diffpot_fill_1 NOT INTERACT esd_trans
   snap_samepot_fill  = snap_samepot_fill_1 NOT INTERACT esd_trans
//
   //snap_diffpot_fill { COPY snap_diffpot_fill } 
   //snap_samepot_fill { COPY snap_samepot_fill } 
   //SNAP_CONNECTED_INFO { @ SNAP INFO : snap device same potential
   //     COPY snap_samepot_fill  
   //}
   //SNAP_UNCONNECTED_INFO { @ SNAP INFO : snap device diff potential
   //     COPY snap_diffpot_fill  
   //}
   ILL_SNAP_OBSOLETE_DEVICE { @ SNAP INFO : snap device 
                              @ SNAP device deleted in Doc 236 Rev 2
      FLATTEN snap_diffpot_fill  
      FLATTEN snap_samepot_fill  
   }
   snap_all_fill = snap_diffpot_fill OR snap_samepot_fill
   //snap_all_fill { COPY snap_all_fill }
   SNAP_SPAC_NDIFF_FIXED_E01SN_INFO { @ SNAP Element rule E01SN : fixed ndiff spacing 0.6 U 
                              @ SNAP device deleted in Doc 236 Rev 2
      good = INT snap_all_fill == 0.6 OPPOSITE PARA ONLY REGION
      all = INT snap_all_fill < 1.0 OPPOSITE PARA ONLY REGION
      all NOT good
   }
// 
// get terms of snap
//
   snap_ndiff =  ndiff_con_pad TOUCH snap_all_fill
   // snap_ndiff { COPY snap_ndiff }
//
// get nwell enclosed by ndiff ( can also cut ndiff )
//
   snap_nwell_cut = snap_ndiff AND routingnwell
   // snap_nwell_cut { COPY snap_nwell_cut }
   snap_active_edge = snap_ndiff COINCIDENT OUTSIDE EDGE snap_all_fill
   snap_xx = (snap_active_edge EXPAND EDGE INSIDE BY 5.0) NOT snap_nwell_cut
   // snap_xx { COPY snap_xx }
   snap_test = snap_all_fill OR snap_xx
   // snap_test { COPY snap_test }
//
   snap_sym  = snap_test INTERACT snap_nwell_cut == 2
   snap_asym = snap_test INTERACT snap_nwell_cut == 1
   snap_bad  = (snap_test NOT snap_sym) NOT snap_asym
   // snap_sym { COPY snap_sym }
   SNAP_BAD_ASYMMETRICAL_INFO { @ SNAP Element Rule : asymmetrical snap not allowed 
                              @ SNAP device deleted in Doc 236 Rev 2
       COPY snap_asym 
   }
   SNAP_BAD_UNIDENTIFIED_INFO { @ SNAP Element rule : snap not identified
                              @ SNAP device deleted in Doc 236 Rev 2
       COPY snap_bad 
   }
   SNAP_EDGE_LENGTH135_E02SN_INFO { @ SNAP Element rule E02SN : edge length 135 degree
                              @ SNAP device deleted in Doc 236 Rev 2
      x = ANGLE snap_ndiff  > 44.9 < 45.1
      LENGTH x  < 1.4
   }
   SNAP_NDIFFANGLE135_E02SN_INFO { @ SNAP Element rule E02SN : must have ndiff corners
                              @ SNAP device deleted in Doc 236 Rev 2
     VERTEX snap_ndiff != 8
   }
   snap_ndiffcon = ndiffcon AND snap_ndiff
   SNAP_OVLP_MET1_CONT_E03SN_INFO { @ SNAP Element rule E03SN : met1 ovlp of diffcon 2.0 U
                              @ SNAP device deleted in Doc 236 Rev 2
      ENC snap_ndiffcon MET1 < 2.0 OVERLAP SINGULAR REGION
   }
// reduce error output
   SNAP_OVLP_DIFF_CONT_E04SN_INFO { @ SNAP Element rule E04SN : ndiff ovlp of diffcon 5.0 U
                                    @ SNAP device deleted in Doc 236 Rev 2
      x = ENC snap_ndiffcon ndiff < 5.0 OVERLAP SINGULAR REGION
      (SIZE x BY 0.3 OVERUNDER) NOT ( SIZE  snap_ndiffcon BY 0.3 OVERUNDER)
   }
//
// E05SN
// not checked
//
// E06SN
// not checked
//
   SNAP_SPAC_NDIFF_UNRELNDIFF_E07SN_INFO { @ SNAP Element rule E07SN : ndiff spacing to unrelated ndiff 4.5 U
                              @ SNAP device deleted in Doc 236 Rev 2
      EXT snap_ndiff (ndiff NOT snap_ndiff) < 4.5  SINGULAR REGION
   }
   SNAP_LENGTH_ACTIVE_EDGE_E08SN_INFO { @ SNAP Element rule E08SN : min active edge length 14.0 U   
                              @ SNAP device deleted in Doc 236 Rev 2
      LENGTH snap_active_edge  < 14.0
   }
//
// E09SN
// not checked
// E10SN
// close conts
   snap_ndiffcont_closed = SIZE snap_ndiffcon BY 0.6 OVERUNDER
   snap_yy = ENC snap_ndiffcont_closed snap_active_edge < 7.0 OPPOSITE PARA ONLY REGION 
   snap_cont_active_edge = snap_ndiffcont_closed COINCIDENT OUTSIDE EDGE snap_yy
   // snap_cont_active_edge { COPY snap_cont_active_edge }

   snap_active_edge_not_cont = snap_active_edge NOT COINCIDENT EDGE snap_yy
   //snap_active_edge_not_cont { COPY snap_active_edge_not_cont }

   SNAP_MINLENGTH_ACTIVE_EDGE_E10SN_INFO { @ SNAP Element rule E10SN : min cont length with active edge 9.0 U   
                              @ SNAP device deleted in Doc 236 Rev 2
      LENGTH snap_cont_active_edge  < 9.0
   }
   SNAP_MAXLENGTH_ACTIVE_EDGE_E11SN_INFO { @ SNAP Element rule E11SN : max length active edge without cont 20.0 U   
                              @ SNAP device deleted in Doc 236 Rev 2
      LENGTH snap_active_edge_not_cont > 20.0
   }
//
// E13SN not checked
//
// E14SN
//
// get edges, expand to area, do antenna check
   snap_cont_1 = snap_yy COINCIDENT EDGE snap_active_edge
   snap_with_cont = snap_cont_1 EXPAND EDGE INSIDE BY 0.1
   snap_active_edge_1 = snap_active_edge EXPAND EDGE INSIDE BY 0.1
   snap_without_cont = snap_active_edge_1 NOT snap_with_cont
   // snap_without_cont{ COPY snap_without_cont }
   // snap_with_cont{ COPY snap_with_cont }
//<<<<<<<<<<<<<<<<<<<<<<<<<<<
// modified for connectivity
     cont_net = COPY snap_with_cont
     CONNECT cont_net 
   SNAP_RATIO_DIFF_CONT_EDGE_E14SN_INFO { @ SNAP Element rule E14SN : min ratio cont length/diff length = 1
                              @ SNAP device deleted in Doc 236 Rev 2
     //cont_net = POLYNET snap_with_cont
     no_cont_net = STAMP snap_without_cont BY cont_net ABUT ALSO
     NET AREA RATIO no_cont_net cont_net > 1 
     //xx = NET AREA RATIO no_cont_net cont_net > 1 ACCUMULATE
     //NET AREA RATIO PRINT xx 'ratio_snap_contdiff.txt'
   }
//
//======================================================================
//                    3.4  DIFFCON SNAP
//======================================================================
// check for snaps
// size checked by DRC
//
   SNAP_SPAC_DIFFCONS_G02CT { @ SNAP Element rule G02CT : diffcons min spacing and size    
     good = EXT snap_ndiffcon == 0.5 OPPOSITE PARA ONLY REGION
     all = EXT snap_ndiffcon < 1.2 OPPOSITE PARA ONLY REGION
     all NOT good
   }
// not for subbus : checked
   SNAP_OVLP_NTUB_CONT_G03CT { @ SNAP Element rule G03CT : min ovlp ntub diffcons = 1.4
     ENC (snap_ndiffcon NOT met1_subbus) snap_nwell_cut < 1.4 OVERLAP SINGULAR REGION
   }
//======================================================================
//               4.1/4.2 LV NDRIVER/PDRIVER RULES
//======================================================================
//
   ngate_sd = ndiff INTERACT ngate
   pgate_sd = pdiff INTERACT pgate
   CONNECT ngate_sd ndiff
   CONNECT pgate_sd pdiff
//
//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
// met1_nosubbus_vddpad = met1_con_pad AND met1_nosubbus
// met1_nosubbus_vddpad { COPY met1_nosubbus_vddpad }
//
//
// get device connected to bond pad
// 
   bondpad_nosupply_1 = COPY bondpad_nosupply
   CONNECT bondpad_nosupply_1 bondpad
//
   pdr_pgate_sd_padc = NET AREA RATIO pgate_sd bondpad_nosupply_1 > 0
   ndr_ngate_sd_padc = NET AREA RATIO ngate_sd bondpad_nosupply_1 > 0
//
//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
#IFDEF debug
   ndr_ngate_sd_padc { COPY ndr_ngate_sd_padc }
   pdr_pgate_sd_padc { COPY pdr_pgate_sd_padc }
#ENDIF
// 
//
// 4.1  ndriver rules
//---------------------
   ndr_ngate_driver = ngate INTERACT ndr_ngate_sd_padc
   //ndr_ngate_driver { COPY ndr_ngate_driver }
// get source diff
   ndr_ndiff_source = (ndiff INTERACT ndr_ngate_driver) NOT ndr_ngate_sd_padc
   ndr_ndiff_source_cont = ndr_ndiff_source AND ndiffcon
   //ndr_ndiff_source_cont { COPY ndr_ndiff_source_cont }
   ndr_ndiff_drain_cont = ndr_ngate_sd_padc AND ndiffcon
   //ndr_ndiff_drain_cont { COPY ndr_ndiff_drain_cont }
//
// reduce error output
   NDRIVER_SPAC_SCON_GATE_E02M1 { @ LV NDRIVER Element rule E02M1 : min spacing gate source ndiffcon = 0.75
     x = EXT ndr_ndiff_source_cont ndr_ngate_driver <  0.75 SINGULAR REGION
     (SIZE x BY 0.3 OVERUNDER) NOT (SIZE ndr_ndiff_source_cont BY 0.3 OVERUNDER)
   }
//
// reduce error output
   NDRIVER_SPAC_DCON_GATE_E03M1 { @ LV NDRIVER Element rule E03M1 : min spacing gate drain ndiffcon = 5.0 
     x = EXT ndr_ndiff_drain_cont ndr_ngate_driver <  5.0 SINGULAR REGION 
     (SIZE x BY 0.3 OVERUNDER ) NOT ( SIZE ndr_ndiff_drain_cont BY 0.3)
   }
//
   NDRIVER_SPAC_MET1_GATE_E04M1 { @ LV NDRIVER Element rule E04M1 : min spacing gate drain met1 = 1.0 
     EXT (ndr_ngate_sd_padc AND MET1) ndr_ngate_driver <  1.0 SINGULAR REGION
   }
// no conts connected to subbus
   ndr_ndiff_ndriver_con = ndr_ndiff_drain_cont OR ndr_ndiff_source_cont
   ndr_nxcon =  ndr_ndiff_ndriver_con NOT met1_subbus
// reduce error output
   NDRIVER_OVLP_DIFF_CONT_E05M1 { @ LV NDRIVER Element rule E05M1 : min ovlp ndiff ndiffcon = 5.0         
     x = ENC ndr_nxcon ndiff < 5.0 SINGULAR REGION
     // cut conts
     (SIZE x BY 0.3 OVERUNDER) NOT (SIZE ndr_nxcon BY 0.3 OVERUNDER)
   }
// no conts connected to subbus
// reduce error output
   NDRIVER_OVLP_MET1_CONT_E06M1 { @ LV NDRIVER Element rule E06M1 : min ovlp met1 ndiffcon = 3.5         
     x = ENC ndr_nxcon MET1 < 3.5 SINGULAR REGION
     ( SIZE x BY 0.3 OVERUNDER) NOT (SIZE  ndr_nxcon BY 0.3 OVERUNDER)
   }
//  E07M1 not checked
//
//
// changed from 2.9 to 1.9
//
// E09M1
//
   ndr_ntub = ndr_ngate_sd_padc AND routingnwell
   NDRIVER_SPAC_NTUB_GATE_E09M1 { @ LV NDRIVER Element rule E09M1 : min spacing gate drain ntub = 1.9      
     EXT ndr_ntub ndr_ngate_driver < 1.9 SINGULAR REGION
   }
//
// E10M1
//
// check for both voltages
   ndr_ngate_driver_l = ndr_ngate_driver NOT COINCIDENT OUTSIDE EDGE ndiff
   ndr_ngate_driver_w = ndr_ngate_driver COINCIDENT OUTSIDE EDGE ndiff
   NDRIVER_GATE_LENGTH_33V_E10M1 { @ LV NDRIVER Element rule E10M1 : min gate length 3.3 V = 0.5      
      PATH LENGTH ndr_ngate_driver_l < 0.5
   }
//
// not checked
//   NDRIVER_GATE_LENGTH_5V_E13M1 { @ LV NDRIVER Element rule E13M1 : min gate length 5.0 V = 0.8      
//      PATH LENGTH ndr_ngate_driver_l < 0.8
//   }
//
// E12M1
// E13M1
//
   NDRIVER_FINGER_WIDTH_E12M1_E13M1 { @ LV NDRIVER Element rule E12M1/E13M1 : finger width >= 15.0 U <= 50   
      NOT LENGTH ndr_ngate_driver_w >= 15.0 <= 50.0
   }
//
// E14M1  not checked
//
// there may be diff sapcing between pdiff and substr diff (icck16p) 
   NDRIVER_MISS_PDIFF_E15M1 { @ LV NDRIVER Element rule E15M1 : miss pdiff between source diff
      (ndr_ndiff_source SIZE BY 0.6) NOT INTERACT pdiff
   }
//
// E01M1
//
// close area
   ndr_diff_all = SIZE (( ndr_ngate_sd_padc OR ndr_ndiff_source) OR ndr_ngate_driver) BY 1.0 OVERUNDER
   //ndr_diff_all { COPY ndr_diff_all }
// get center square size 0.1 X 0.1 U
   ndr_ndiff_center = EXTENTS ndr_diff_all CENTERS 0.1
   //ndr_ndiff_center { COPY ndr_ndiff_center }
// get edge and expand
   ndr_ngate_driver_w1 = ndr_ngate_driver COINCIDENT OUTSIDE EDGE ndr_ngate_sd_padc
   ndr_ngate_driver_w2 = ndr_ngate_driver_w1 EXPAND EDGE OUTSIDE By 0.1
   //ndr_ngate_driver_w2 { COPY ndr_ngate_driver_w2 }
// do antenna check, reference is 0.01 square
//<<<<<<<<<<<<<<<<<<<<<<<<<<<
// modified for connectivity
     ndr_diff_all_net = COPY    ndr_diff_all
     CONNECT ndr_diff_all_net
   NDRIVER_MIN_TRANS_WIDTH_E01M1 { @ LV NDRIVER Element rule E01M1 : min ndriver width = 500 U
     //ndr_diff_all_net = POLYNET ndr_diff_all
     ndr_ngate_edge_net = STAMP ndr_ngate_driver_w2 BY ndr_diff_all_net ABUT ALSO
     center_net = STAMP ndr_ndiff_center BY ndr_diff_all_net ABUT ALSO
     NET AREA RATIO ndr_ngate_edge_net center_net < 5000  
     xx = NET AREA RATIO ndr_ngate_edge_net center_net < 5000  ACCUMULATE
     NET AREA RATIO PRINT xx 'ndriver_width_lt_500_e01m1.txt'
   }
//
//  E08M1 
//  check squares
// 
// Bus concept of primary ESD paths
// 5.3 All primary ESD elements protecting an IO-Pad should be within 200 U of the pad window
//
   bondpad_oversize_200 = SIZE bondpad BY 200
   NDRIVER_SPACING200_PAD_REC { @ REC :  Bus concept of primary ESD paths
                                @ 5.3 All primary ESD elements protecting an IO-Pad should be within 200 U of the pad window
        x =  ndr_ngate_driver NOT INSIDE  bondpad_oversize_200
        x NOT bondpad_oversize_200
   }
//
// 4.2  pdriver rules
//---------------------
   pdr_pgate_driver = pgate INTERACT pdr_pgate_sd_padc
   //pdr_pgate_driver { COPY pdr_pgate_driver }
// get source diff
   pdr_pdiff_source = (pdiff INTERACT pdr_pgate_driver) NOT pdr_pgate_sd_padc
   pdr_pdiff_source_cont = pdr_pdiff_source AND pdiffcon
   //pdr_pdiff_source_cont { COPY pdr_pdiff_source_cont }
   pdr_pdiff_drain_cont = pdr_pgate_sd_padc AND pdiffcon
   //pdr_pdiff_drain_cont { COPY pdr_pdiff_drain_cont }
//
//  E01M2   not checked
//
// reduce error output
   PDRIVER_SPAC_SCON_GATE_E02M2 { @ LV PDRIVER Element rule E02M2 : min spacing gate source pdiffcon = 0.75
     x = EXT pdr_pdiff_source_cont pdr_pgate_driver <  0.75 SINGULAR REGION
     (SIZE x BY 0.3 OVERUNDER) NOT (SIZE  pdr_pdiff_source_cont BY 0.3 OVERUNDER)
   }
//
// reduce error output
   PDRIVER_SPAC_DCON_GATE_E03M2 { @ LV PDRIVER Element rule E03M2 : min spacing gate drain pdiffcon = 1.0 
     x = EXT pdr_pdiff_drain_cont pdr_pgate_driver <  1.0 SINGULAR REGION
     (SIZE X BY 0.3 OVERUNDER) NOT  (SIZE pdr_pdiff_drain_cont BY 0.3)
   }
//
   PDRIVER_SPAC_MET1_GATE_E04M2 { @ LV PDRIVER Element rule E04M2 : min spacing gate drain met1 = 0.45
     EXT (pdr_pgate_sd_padc AND MET1) pdr_pgate_driver < 0.45 SINGULAR REGION
   }
// no conts connected to vdd   
   pdr_pdiff_pdriver_con = pdr_pdiff_drain_cont OR pdr_pdiff_source_cont
//
// met1_vdd = NET routingmet1 "?VDD?" "?vdd?" 
//
   pdr_pxcon =  pdr_pdiff_pdriver_con NOT met1_nosubbus_vddtext
// reduce error output
   PDRIVER_OVLP_DIFF_CONT_E05M2 { @ LV PDRIVER Element rule E05M2 : min ovlp pdiff pdiffcon = 1.0         
     x = ENC pdr_pxcon pdiff < 1.0 SINGULAR REGION
     (SIZE x BY 0.3 OVERUNDER) NOT (SIZE pdr_pxcon BY 0.3 OVERUNDER)
   }
// no conts connected to vdd   
// reduce error output
   PDRIVER_OVLP_MET1_CONT_E06M2 { @ LV PDRIVER Element rule E06M2 : min ovlp met1 pdiffcon = 1.3         
     x = ENC pdr_pxcon MET1 < 1.3 SINGULAR REGION
     (SIZE x BY 0.3 OVERUNDER) NOT (SIZE pdr_pxcon BY 0.3 OVERUNDER)
   }
//
// E07M2 not checked
//
// check for both voltages
   pdr_pgate_driver_l = pdr_pgate_driver NOT COINCIDENT OUTSIDE EDGE pdiff
   pdr_pgate_driver_w = pdr_pgate_driver COINCIDENT OUTSIDE EDGE pdiff
   PDRIVER_GATE_LENGTH_33V_E09M2 { @ LV PDRIVER Element rule E09M2 : min gate length 3.3 V = 0.5      
      PATH LENGTH pdr_pgate_driver_l < 0.5
   }
// not checked
//   PDRIVER_GATE_LENGTH_5V_E13M2 { @ LV PDRIVER Element rule E13M2 : min gate length 5.0 V = 0.8      
//      PATH LENGTH pdr_pgate_driver_l < 0.8
//   }
   PDRIVER_FINGER_WIDTH_E11M2_E12M2 { @ LV PDRIVER Element rule E11M2/E12M2 : finger width >= 15.0 U <= 70   
      NOT LENGTH pdr_pgate_driver_w >= 15.0 <= 70.0
   }
// E13M2  not checked
   PDRIVER_MISS_PDIFF_E14M2 { @ LV PDRIVER Element rule E14M2 : miss ndiff between source pdiff
      pdr_pdiff_source NOT INTERACT ndiff
   }
//
// E01M2
//
// close area
   pdr_diff_all = SIZE (( pdr_pgate_sd_padc OR pdr_pdiff_source) OR pdr_pgate_driver) BY 1.0 OVERUNDER
   //pdr_diff_all { COPY pdr_diff_all }
// get center square size 0.1 X 0.1 U
   pdr_pdiff_center = EXTENTS pdr_diff_all CENTERS 0.1
   //pdr_pdiff_center { COPY pdr_pdiff_center }
// get edge and expand
   pdr_pgate_driver_w1 = pdr_pgate_driver COINCIDENT OUTSIDE EDGE pdr_pgate_sd_padc
   pdr_pgate_driver_w2 = pdr_pgate_driver_w1 EXPAND EDGE OUTSIDE By 0.1
   //pdr_pgate_driver_w2 { COPY pdr_pgate_driver_w2 }
// do antenna check, reference is 0.01 square
//<<<<<<<<<<<<<<<<<<<<<<<<<<<
// modified for connectivity
     pdr_diff_all_net = COPY    pdr_diff_all
     CONNECT pdr_diff_all_net 
   PDRIVER_MIN_TRANS_WIDTH_E01M2 { @ LV PDRIVER Element rule E01M2 : min pdriver width = 500 U
     //pdr_diff_all_net = POLYNET pdr_diff_all
     pdr_pgate_edge_net = STAMP pdr_pgate_driver_w2 BY pdr_diff_all_net  ABUT ALSO
     center_net = STAMP pdr_pdiff_center BY pdr_diff_all_net  ABUT ALSO
     NET AREA RATIO pdr_pgate_edge_net center_net < 5000  
     xx = NET AREA RATIO pdr_pgate_edge_net center_net < 5000  ACCUMULATE
     NET AREA RATIO PRINT xx 'pdriver_width_lt_500_e01m2.txt'
   }
//
// E08M2 : squares not checked
// 
// Bus concept of primary ESD paths
// 5.3 All primary ESD elements protecting an IO-Pad should be within 200 U of the pad window
//
   PDRIVER_SPACING200_PAD_REC { @ REC :  Bus concept of primary ESD paths
                             @ 5.3 All primary ESD elements protecting an IO-Pad should be within 200 U of the pad window
        x =  pdr_pgate_driver NOT INSIDE  bondpad_oversize_200
        x NOT bondpad_oversize_200
   }
//
//======================================================================
//                           4.3 GC_NMOS     
//======================================================================
// gate of nmos LV driver is connceted via rdiffp to vss
// check this 
//
//
// get restrm connected to ndriver gate pad
   ndr_ngate_driver_net = STAMP ndr_ngate_driver BY routingpoly 
   ndr_restrm_con = NET AREA RATIO RESTRM ndr_ngate_driver_net > 0
   //ndr_restrm_con { COPY ndr_restrm_con }
// get rdiff connected
   ndr_pdrepro = pdres INTERACT ndr_restrm_con 
   //ndr_pdrepro { COPY ndr_pdrepro }
//
// check for w/l
//
   ndr_pdrepro_w           = ndr_pdrepro COINCIDENT EDGE RESTRM
   ndr_pdrepro_l           = ndr_pdrepro NOT COINCIDENT EDGE RESTRM
   ndr_pdrepro_wexp        = ndr_pdrepro_w EXPAND EDGE OUTSIDE BY 0.1
   ndr_pdrepro_lexp        = ndr_pdrepro_l EXPAND EDGE OUTSIDE BY 0.1
   ndr_pdrepro_exp         = SIZE ndr_pdrepro BY 0.1
//<<<<<<<<<<<<<<<<<<<<<<<<<<<
// modified for connectivity
   ndr_pdrepro_exp_net     = COPY ndr_pdrepro_exp
   CONNECT ndr_pdrepro_exp_net
   //ndr_pdrepro_exp_net     = POLYNET ndr_pdrepro_exp
   ndr_pdrepro_wexp_net    = STAMP ndr_pdrepro_wexp BY ndr_pdrepro_exp_net
   ndr_pdrepro_lexp_net    = STAMP ndr_pdrepro_lexp BY ndr_pdrepro_exp_net
//
// rdiffp with 1.5 k found ?
//
   ndr_xprotrdiffp =  NET AREA RATIO ndr_pdrepro_lexp_net ndr_pdrepro_wexp_net > 9 <= 10 
   ndr_pdre15k = ndr_pdrepro INTERACT ndr_xprotrdiffp
   //ndr_pdre15k { COPY  ndr_pdre15k }
//
// rs typ = 140 
// R = L/W * RS
   GC_NMOS_RDIFFP_E02GN { @ GC_NMOS E02GN rdiffp resistor should be 1.5 k ( RS typ = 140 )
        x =   ndr_pdrepro INTERACT( NET AREA RATIO  ndr_pdrepro_lexp_net ndr_pdrepro_wexp_net > 9 <= 10)
        ndr_pdrepro NOT x 
   }
//
// rdiffp connected to vss (subbus)  yet not checked
//
// get gate used for protection
//
//<<<<<<<<<<<<<<<<<<<<<<<<<<<
// modified for connectivity
//
   ndr_restrm_con_1 = COPY ndr_restrm_con
   ndr_restrm_con_2 = STAMP ndr_restrm_con_1 BY RESTRM 
   ndr_pdr15k_net = STAMP ndr_pdre15k BY ndr_restrm_con_2 ABUT ALSO 
//
   ndr_ngate_driver_net_1 = COPY  ndr_ngate_driver
   ndr_ngate_driver_net_2 = STAMP ndr_ngate_driver_net_1 BY routingpoly 
//<<<<<<<<<<<<<<<<<<<<<<<<<<<
   ndr_ngate_prot = NET AREA RATIO ndr_ngate_driver_net_2 ndr_pdr15k_net > 0
   //ndr_ngate_prot { COPY ndr_ngate_prot }
//
//
   gc_nmos_ndr_ngate_prot =  ndr_ngate_prot NOT MIDOX
   gc_nmosm_ndr_ngate_prot = ndr_ngate_prot AND MIDOX
//
   GC_NMOS_INFO { @ INFO E01GN : GC_NMOS protection device found
        FLATTEN gc_nmos_ndr_ngate_prot
   }
   GC_NMOSM_INFO { @ INFO E01GN : GC_NMOSM protection device found
        FLATTEN gc_nmosm_ndr_ngate_prot
   }
//
//======================================================================
//                           4.4 GC_PMOS     
//======================================================================
// gate of pmos LV driver is connceted via rdiffp to vdd
// check this 
//
// get restrm connected to pdriver gate pad
   pdr_pgate_driver_net = STAMP pdr_pgate_driver BY routingpoly 
   pdr_restrm_con = NET AREA RATIO RESTRM pdr_pgate_driver_net > 0
   //pdr_restrm_con { COPY pdr_restrm_con }
// get rdiff connected
   pdr_pdrepro = pdres INTERACT pdr_restrm_con 
   //pdr_pdrepro { COPY pdr_pdrepro }
//
// check for w/l
//
   pdr_pdrepro_w           = pdr_pdrepro COINCIDENT EDGE RESTRM
   pdr_pdrepro_l           = pdr_pdrepro NOT COINCIDENT EDGE RESTRM
   pdr_pdrepro_wexp        = pdr_pdrepro_w EXPAND EDGE OUTSIDE BY 0.1
   pdr_pdrepro_lexp        = pdr_pdrepro_l EXPAND EDGE OUTSIDE BY 0.1
   pdr_pdrepro_exp         = SIZE pdr_pdrepro BY 0.1
//<<<<<<<<<<<<<<<<<<<<<<<<<<<
// modified for connectivity
   pdr_pdrepro_exp_net     = COPY pdr_pdrepro_exp
   CONNECT pdr_pdrepro_exp_net 
   //pdr_pdrepro_exp_net     = POLYNET pdr_pdrepro_exp
   pdr_pdrepro_wexp_net    = STAMP pdr_pdrepro_wexp BY pdr_pdrepro_exp_net
   pdr_pdrepro_lexp_net    = STAMP pdr_pdrepro_lexp BY pdr_pdrepro_exp_net
//
// rdiffp with 1.5 k found ?
//
   pdr_xprotrdiffp =  NET AREA RATIO pdr_pdrepro_lexp_net pdr_pdrepro_wexp_net > 9 <= 10 
   pdr_pdre15k = pdr_pdrepro INTERACT pdr_xprotrdiffp
   //pdr_pdre15k { COPY  pdr_pdre15k }
//
// rs typ = 140 
// R = L/W * RS
   GC_PMOS_RDIFFP_E02GP { @ GC_PMOS E02GP rdiffp resistor should be 1.5 k ( RS typ = 140 )
        x =   pdr_pdrepro INTERACT ( NET AREA RATIO pdr_pdrepro_lexp_net pdr_pdrepro_wexp_net > 9 <= 10)
        pdr_pdrepro NOT x 
   }
//
// rdiffp connected to vdd  yet not checked
//
// get gate used for protection
//
//<<<<<<<<<<<<<<<<,
// modified for connectivity
   pdr_restrm_con_1 = COPY pdr_restrm_con
   pdr_restrm_con_2 = STAMP pdr_restrm_con_1 BY RESTRM 
   pdr_pgate_driver_net_1 = COPY  pdr_pgate_driver_net
   pdr_pgate_driver_net_2 = STAMP pdr_pgate_driver_net_1 BY routingpoly 
//<<<<<<<<<<<<<<<<,
   pdr_pdr15k_net = STAMP pdr_pdre15k BY pdr_restrm_con_2 ABUT ALSO 
   pdr_pgate_prot = NET AREA RATIO pdr_pgate_driver_net_2 pdr_pdr15k_net > 0
   //pdr_pgate_prot { COPY pdr_pgate_prot }
//
   gc_pmos_pdr_pgate_prot =  pdr_pgate_prot NOT MIDOX
   gc_pmosm_pdr_pgate_prot = pdr_pgate_prot AND MIDOX
   GC_PMOS_INFO { @ INFO : GC_PMOS protection device found
        FLATTEN gc_pmos_pdr_pgate_prot
   }
   GC_PMOSM_INFO { @ INFO : GC_PMOSM protection device found
        FLATTEN gc_pmosm_pdr_pgate_prot
   }
//
//======================================================================
//                           4.5 FORWARD     
//======================================================================
//
// E01D1 min ndiff spacing to pdiff .... min ... check ok
// E02D1 min ndiff encl of cont ...      min ... check ok
//
// not checked
//
// E03D1 forward never used for reverse
//
//======================================================================
//                           4.6 LV_DIODE    
//======================================================================
//
//
// p-minus n-plus diode
//------------------------
//
// avoid false extract
// remove pnpvert10
//
// extract without diode layer
// add diode layer later
// ndiff in substrate surrounded by ptap 
//
//
   nd_diode_holes_1 = ((HOLES subtap INNER < 2000.0 ) NOT INTERACT routingpoly) NOT INTERACT RESDEF
   nd_diode_holes =   (nd_diode_holes_1 NOT INTERACT pnpvert10) INTERACT ( ndiff NOT routingnwell ) 
//
   //nd_diode_holes { COPY nd_diode_holes }
   nd_diode_ndiff = ((ndiff NOT INTERACT routingpoly) INSIDE nd_diode_holes) INTERACT nd_diode_holes == 1  
   nd_diode_pdiff = subtap TOUCH (nd_diode_holes ENCLOSE nd_diode_ndiff)
   //nd_diode_pdiff { COPY nd_diode_pdiff }
   //nd_diode_ndiff { COPY nd_diode_ndiff }
   nd_diode_all_diff = nd_diode_pdiff OR nd_diode_ndiff
   nd_all_nd = EXT nd_diode_pdiff nd_diode_ndiff < 1.2  OPPOSITE PARA ONLY REGION
//
// only large diodes
//
   nd_diode_body_diffedgex = nd_all_nd COINCIDENT OUTSIDE EDGE nd_diode_ndiff
   nd_diode_body_diffedge_lengthx = LENGTH  nd_diode_body_diffedgex > 15
   nd_diode_body_okx = nd_all_nd WITH EDGE  nd_diode_body_diffedge_lengthx
//
   nd_all_nd_forw = nd_all_nd INTERACT nd_diode_body_okx
   nd_diode_pdiff_forw = nd_diode_pdiff INTERACT nd_all_nd_forw 
   nd_diode_ndiff_forw = nd_diode_ndiff INTERACT nd_all_nd_forw 
   nd_diode_all_diff_forw = nd_diode_all_diff INTERACT nd_all_nd_forw
// 
   ND_FORWARD_INFO { @ INFO : FORWARD N-Diode 
       FLATTEN nd_all_nd_forw
   }
//
   ND_FORWARD_MISS_DIODE_LAYER_INFO { @ INFO : FORWARD N-Diode found, but no diode layer 
       nd_all_nd_forw NOT INTERACT DIODE
   }
//
// ndiff enclosed by diode layer ?
//
   ND_FORWARD_BAD_DIODE_LAYER_INFO { @ INFO : FORWARD N-Diode found, diode layer does not enclose ndiff
       ( nd_diode_ndiff INTERACT nd_all_nd_forw ) NOT INSIDE DIODE
   }
//
// min ndiff spacing to pdiff : MIN
   ND_FORWARD_SPAC_PNDIFF_E01D1 { @ Forward N-Diode Element rule E01D1 : no min ndiff/pdiff spacing 0.6 U 
      good_nd = EXT nd_diode_pdiff_forw nd_diode_ndiff_forw == 0.6 OPPOSITE PARA ONLY REGION
      nd_all_nd_forw NOT good_nd
   }
   nd_fill_forw = EXT nd_diode_pdiff_forw nd_diode_ndiff_forw < 1.2  OPPOSITE PARA ONLY REGION
   nd_diode_diffedge_forw = nd_diode_all_diff_forw COINCIDENT OUTSIDE EDGE nd_fill_forw 
   //nd_diode_diffedge { COPY nd_diode_diffedge }
//
// not in doc, check info only
//
   ND_FORWARD_LENGTH_DIFFEDGE_INFO { @ Forward N-Diode Element rule : active edge length <  20 U
      // NOT LENGTH nd_diode_diffedge_forw >= 9.0  <= 20.0
      LENGTH nd_diode_diffedge_forw  > 1.0 < 20.0
   }
//
// only near active edge
// change from 2 to 1.0
   nd_diode_diffedge_exp_forw = nd_diode_diffedge_forw EXPAND EDGE INSIDE BY 1.0
   nd_diffcon_forw = (diffcon AND nd_diode_all_diff_forw) INTERACT nd_diode_diffedge_exp_forw 
   //nd_diffcon_forw { COPY nd_diffcon_forw }
// use 0.5, min is 0.4 
   ND_FORWARD_SPAC_DIFFCONS_G02CT { @ LV N-Diode Element rule G02CT : diffcons min spacing and size    
     np_cont =  nd_diffcon_forw AND NPLUS 
     pp_cont =  nd_diffcon_forw AND PPLUS 
     good1 = EXT np_cont <= 0.5 OPPOSITE PARA ONLY REGION
     all1  = EXT np_cont < 1.2 OPPOSITE PARA ONLY REGION
     SIZE ( all1 NOT good1) BY 0.5 OVERUNDER
     good2 = EXT pp_cont <= 0.5 OPPOSITE PARA ONLY REGION
     all2  = EXT pp_cont < 1.2 OPPOSITE PARA ONLY REGION
     SIZE ( all2 NOT good2) BY 0.5 OVERUNDER
   }
// check for recommended min ovlp
// more rows of cont : make 2.0 smaller ... not good
// use 1 U
// cut cont and select error edges only touching diff edge
   ND_FORWARD_MINOVLP_DCONT_E02D1 { @ Forward N-Diode Element rule E02D1 : diff ovlp of cont should be min = 0.15
      good = ENC nd_diffcon_forw nd_diode_diffedge_forw == 0.15 OPPOSITE PARA ONLY REGION
      all = ENC nd_diffcon_forw nd_diode_diffedge_forw < 1.0 OPPOSITE PARA ONLY REGION
      x = (all NOT good) NOT nd_diffcon_forw
      y = x INTERACT ( EXPAND EDGE nd_diode_diffedge_forw BY 0.05)
      (SIZE y BY 0.3 OVERUNDER) AND nd_diode_all_diff_forw
   }
//
   ND_FORWARD_SPACING200_PAD_REC { @ REC :  Bus concept of primary ESD paths
                                   @ 5.3 All primary ESD elements protecting an IO-Pad should be within 200 U of the pad window
        x =  nd_all_nd NOT INSIDE  bondpad_oversize_200
        x NOT bondpad_oversize_200
   }
//
// p-plus n-minus diode
//------------------------
//
   // false pd  : 1.5k res enclosed by welltap
   // but analog cell has rblock inside
   // false device in bg06
   pd_diode_holes_1 = ((HOLES welltap INNER < 2000.0 ) NOT INTERACT routingpoly) NOT INTERACT (pdr_pdre15k OR ndr_pdre15k)
   pd_diode_holes =   pd_diode_holes_1 NOT INTERACT pnpvert10
//
   //pd_diode_holes { COPY pd_diode_holes }
// analog pads have rdiffp inside diode
   pd_diode_pdiff_1 = (pdiff INSIDE pd_diode_holes) INTERACT pd_diode_holes == 1
   pd_diode_pdiff_2 = (pdiff INSIDE pd_diode_holes) AND DIODE
   pd_diode_pdiff = pd_diode_pdiff_1 OR pd_diode_pdiff_2
//
   pd_diode_ndiff = welltap TOUCH (pd_diode_holes ENCLOSE pd_diode_pdiff)
   //pd_diode_pdiff { COPY pd_diode_pdiff }
   //pd_diode_ndiff { COPY pd_diode_ndiff }
   pd_diode_all_diff = pd_diode_pdiff OR pd_diode_ndiff
   pd_all_pd = EXT pd_diode_pdiff pd_diode_ndiff < 1.2  OPPOSITE PARA ONLY REGION
//
   pd_diode_body_diffedgex = pd_all_pd COINCIDENT OUTSIDE EDGE pd_diode_ndiff
   pd_diode_body_diffedge_lengthx = LENGTH  pd_diode_body_diffedgex > 15
   pd_diode_body_okx = pd_all_pd WITH EDGE  pd_diode_body_diffedge_lengthx
//
   pd_all_pd_forw = pd_all_pd INTERACT pd_diode_body_okx
   pd_diode_pdiff_forw = pd_diode_pdiff INTERACT pd_all_pd_forw
   pd_diode_ndiff_forw = pd_diode_ndiff INTERACT pd_all_pd_forw
   pd_diode_all_diff_forw = pd_diode_all_diff INTERACT pd_all_pd_forw
//
   PD_FORWARD_INFO { @ INFO : FORWARD P-Diode 
       FLATTEN pd_all_pd_forw
   }
//
   PD_FORWARD_MISS_DIODE_LAYER_INFO { @ INFO : FORWARD P-Diode found, but no diode layer 
       pd_all_pd_forw NOT INTERACT DIODE
   }
//
// pdiff enclosed by diode layer
//
   PD_FORWARD_BAD_DIODE_LAYER_INFO { @ INFO : FORWARD P-Diode found, diode layer does not enclose pdiff 
       (pd_diode_pdiff INTERACT pd_all_pd_forw) NOT INSIDE DIODE
   }
//
// check only near active diode edge too avoid too much false errors
   PD_FORWARD_OVLP_NTUB_NDIFF_G01NW { @ PD Forward G01NW : Ntub ovlp of ndiff for LV FORWARD  Diode < 1 U
     x = ndiff INTERACT pd_all_pd_forw
     y = ndiff COINCIDENT OUTSIDE EDGE pd_all_pd_forw
     z = EXPAND EDGE y INSIDE BY 8.0
     u = ENC x routingnwell < 1.0 ABUT == 0 REGION  
     u AND z
   }
//
// E01D1 checked by DRC
// E04D1 checked by DRC
//
// info, if not minimum used
// checked until 1.2 U
   PD_FORWARD_SPAC_PNDIFF_E01D1 { @ LV Forward P-Diode Element rule E01DN : no min ndiff/pdiff spacing 0.6 U 
      good_pd = EXT pd_diode_pdiff_forw pd_diode_ndiff_forw == 0.6 OPPOSITE PARA ONLY REGION
      pd_all_pd_forw NOT good_pd
   }
// 
   pd_fill_forw = EXT pd_diode_pdiff_forw pd_diode_ndiff_forw < 1.2  OPPOSITE PARA ONLY REGION
   pd_diode_diffedge_forw = pd_diode_all_diff COINCIDENT OUTSIDE EDGE pd_fill_forw 
   //pd_diode_diffedge_forw { COPY pd_diode_diffedge_forw }
//
// info only
//
   PD_FORWARD_LENGTH_DIFFEDGE_INFO { @ LV FORWARD P-Diode Element rule : active edge length < 20 U
      // NOT LENGTH pd_diode_diffedge >= 9.0  <= 20.0
      LENGTH pd_diode_diffedge_forw > 1.0 < 20.0
   }
// 
// only near active edge
// change from 2.0 to 1.0
//
   pd_diode_diffedge_exp_forw = pd_diode_diffedge_forw EXPAND EDGE INSIDE BY 1.0
   pd_diffcon_forw = (diffcon AND pd_diode_all_diff_forw) INTERACT pd_diode_diffedge_exp_forw 
   //pd_diffcon_forw { COPY pd_diffcon_forw }
//
// ATTENTION : relaxed use 05  
   PD_FORWARD_SPAC_DIFFCONS_G02CT { @ LV Forward P-Diode Element rule G02CT : diffcons min spacing and size    
     np_cont =  pd_diffcon_forw AND NPLUS 
     pp_cont =  pd_diffcon_forw AND PPLUS 
     good1 = EXT np_cont         <= 0.5 OPPOSITE PARA ONLY REGION
     all1 = EXT np_cont         < 1.2 OPPOSITE PARA ONLY REGION
     SIZE ( all1 NOT good1) BY 0.5 OVERUNDER
     good2 = EXT pp_cont         <= 0.5 OPPOSITE PARA ONLY REGION
     all2 = EXT pp_cont         < 1.2 OPPOSITE PARA ONLY REGION
     SIZE ( all2 NOT good2) BY 0.5 OVERUNDER
   }
//
// E02D1
// check for  min ovlp
   PD_FORWARD_MINOVLP_DCONT_E02D1 { @ LV Forward P-Diode Element rule E02D1 : diff ovlp of cont should be min = 0.15
      good = ENC pd_diffcon_forw pd_diode_diffedge_forw == 0.15 OPPOSITE PARA ONLY REGION
      all = ENC pd_diffcon_forw pd_diode_diffedge_forw < 1.0 OPPOSITE PARA ONLY REGION
      x = (all NOT good) NOT pd_diffcon_forw
      y = x INTERACT ( EXPAND EDGE pd_diode_diffedge_forw BY 0.05)
      (SIZE y BY 0.3 OVERUNDER) AND pd_diode_all_diff_forw
   }
//
   PD_FORWARD_SPACING200_PAD_REC { @ REC :  Bus concept of primary ESD paths
                             @ 5.3 All primary ESD elements protecting an IO-Pad should be within 200 U of the pad window
        x =  pd_all_pd NOT INSIDE  bondpad_oversize_200
        x NOT bondpad_oversize_200
   }
//
//======================================================================
//                           4.7 LV_CLAMP    
//======================================================================
//
// E01LV  ... min perimeter ... diff ovlp of 1 single cont
// E02LV  ... min cont size ... checked by DRC
// E03LV
// E04LV
//
// ATTENTION : add diode layer later
//
// nd diode
//-----------
//
   //nd_diode_ndiff = ((ndiff NOT INTERACT routingpoly) INSIDE nd_diode_holes) INTERACT nd_diode_holes == 1
   nd_cl_diode_ndiff =  nd_diode_ndiff INTERACT diffcon == 1 
   nd_cl_diode_pdiff = subtap TOUCH (nd_diode_holes ENCLOSE nd_cl_diode_ndiff)
   //nd_cl_diode_pdiff { COPY nd_cl_diode_pdiff }
   //nd_cl_diode_ndiff { COPY nd_cl_diode_ndiff }
   nd_cl_diode_all_diff = nd_cl_diode_pdiff OR nd_cl_diode_ndiff
   nd_cl_all_nd = EXT nd_cl_diode_pdiff nd_cl_diode_ndiff < 1.2  OPPOSITE PARA ONLY REGION
//
   nd_all_nd_clamp = nd_all_nd INTERACT nd_cl_all_nd
   nd_diode_pdiff_clamp = nd_diode_pdiff INTERACT nd_all_nd_clamp
   nd_diode_ndiff_clamp = nd_diode_ndiff INTERACT nd_all_nd_clamp
   nd_diode_all_diff_clamp = nd_diode_all_diff INTERACT nd_all_nd_clamp
//
   ND_CLAMP_INFO { @ INFO : CLAMP N-Diode
       FLATTEN nd_all_nd_clamp
   }
//
   ND_CLAMP_MISS_DIODE_LAYER_INFO { @ INFO : CLAMP N-Diode found, but no diode layer
       nd_all_nd_clamp NOT INTERACT DIODE
   }
//
   nd_diode_diffedge_clamp= nd_diode_all_diff_clamp COINCIDENT OUTSIDE EDGE nd_cl_all_nd 
   //nd_diode_diffedge_clamp { COPY nd_diode_diffedge_clamp }

// only near active edge
   nd_diode_diffedge_exp_clamp  = nd_diode_diffedge_clamp     EXPAND EDGE INSIDE BY 2.0
   nd_diffcon_clamp     = ( diffcon AND nd_diode_all_diff_clamp ) INTERACT nd_diode_diffedge_exp_clamp     
   //nd_diffcon_clamp     { COPY nd_diffcon_clamp }
   ND_CLAMP_MINOVLP_DCONT_E03LV { @ Clamp N-Diode Element rule E03LV : diff ovlp of cont should be min = 0.15
      good = ENC nd_diffcon_clamp  nd_diode_diffedge_clamp  == 0.15 OPPOSITE PARA ONLY REGION
      all = ENC nd_diffcon_clamp   nd_diode_diffedge_clamp  < 1.0 OPPOSITE PARA ONLY REGION
      x = (all NOT good) NOT nd_diffcon_clamp    
      y = x INTERACT ( EXPAND EDGE nd_diode_diffedge_clamp BY 0.05)
      (SIZE y BY 0.3 OVERUNDER) AND nd_diode_all_diff_clamp    
   }
//
// min ndiff spacing to pdiff : MIN
   ND_CLAMP_SPAC_PNDIFF_E04LV { @ Clamp N-Diode Element rule E04LV : no min ndiff/pdiff spacing 0.6 U
      good_nd = EXT nd_diode_pdiff_clamp nd_diode_ndiff_clamp == 0.6 OPPOSITE PARA ONLY REGION
      nd_all_nd_clamp NOT good_nd
   }
//
// pd diode
//----------
//
   pd_cl_diode_pdiff =  pd_diode_pdiff INTERACT diffcon == 1 
   pd_cl_diode_ndiff = welltap TOUCH (pd_diode_holes ENCLOSE pd_cl_diode_pdiff)
   //pd_diode_pdiff { COPY pd_diode_pdiff }
   //pd_diode_ndiff { COPY pd_diode_ndiff }
   pd_cl_diode_all_diff = pd_cl_diode_pdiff OR pd_cl_diode_ndiff
   pd_cl_all_pd = EXT pd_cl_diode_pdiff pd_cl_diode_ndiff < 1.2  OPPOSITE PARA ONLY REGION
//
   pd_all_pd_clamp= pd_all_pd INTERACT pd_cl_all_pd
   pd_diode_pdiff_clamp= pd_diode_pdiff INTERACT pd_all_pd_clamp
   pd_diode_ndiff_clamp= pd_diode_ndiff INTERACT pd_all_pd_clamp
   pd_diode_all_diff_clamp= pd_diode_all_diff INTERACT pd_all_pd_clamp
//
   PD_CLAMP_INFO { @ INFO : CLAMP P-Diode
       FLATTEN pd_all_pd_clamp
   }
//
   PD_CLAMP_MISS_DIODE_LAYER_INFO { @ INFO : CLAMP P-Diode found, but no diode layer
       pd_all_pd_clamp NOT INTERACT DIODE
   }
//
   pd_diode_diffedge_clamp= pd_diode_all_diff_clamp COINCIDENT OUTSIDE EDGE pd_cl_all_pd 
   //pd_diode_diffedge_clamp { COPY pd_diode_diffedge_clamp }
//
// only near active edge
   pd_diode_diffedge_exp_clamp  = pd_diode_diffedge_clamp     EXPAND EDGE INSIDE BY 2.0
   pd_diffcon_clamp     = (diffcon AND pd_diode_all_diff_clamp    ) INTERACT pd_diode_diffedge_exp_clamp     
   //pd_diffcon_clamp     { COPY pd_diffcon_clamp }
   PD_CLAMP_MINOVLP_DCONT_E03LV { @ Clamp P-Diode Element rule E03LV : diff ovlp of cont should be min = 0.15
      good = ENC pd_diffcon_clamp  pd_diode_diffedge_clamp  == 0.15 OPPOSITE PARA ONLY REGION
      all = ENC pd_diffcon_clamp   pd_diode_diffedge_clamp  < 1.0 OPPOSITE PARA ONLY REGION
      x = (all NOT good) NOT pd_diffcon_clamp    
      y = x INTERACT ( EXPAND EDGE pd_diode_diffedge_clamp BY 0.05)
      (SIZE y BY 0.3 OVERUNDER) AND pd_diode_all_diff_clamp    
   }
//
// min pdiff spacing to pdiff : MIN
   PD_CLAMP_SPAC_PNDIFF_E04LV { @ Clamp P-Diode Element rule E04LV : no min ndiff/pdiff spacing 0.6 U
      good_pd = EXT pd_diode_pdiff_clamp pd_diode_ndiff_clamp == 0.6 OPPOSITE PARA ONLY REGION
      pd_all_pd_clamp NOT good_pd
   }
//
//======================================================================
//                           4.8 RBLOCK    
//======================================================================
//
// already found
// check for diodes in pad side
//
   pd_diode_pdiff_area = pdiff INTERACT pd_all_pd
   //pd_diode_pdiff_area { COPY pd_diode_pdiff_area }

   nd_diode_ndiff_area = ndiff INTERACT nd_all_nd
   //nd_diode_ndiff_area { COPY nd_diode_ndiff_area }

   pd_diode_pad = NET AREA RATIO pd_diode_pdiff_area bondpad > 0
   nd_diode_pad = NET AREA RATIO nd_diode_ndiff_area bondpad > 0
//
   restrm_con_pad_1 = NET AREA RATIO RESTRM bondpad_nosupply_1 > 0
   //restrm_con_pad_1 { COPY restrm_con_pad_1 }
//
// get diodes connected to pad term of rblock
   pd_diode_pad_ok = NET AREA RATIO pd_diode_pad restrm_con_pad_1 > 0
   nd_diode_pad_ok = NET AREA RATIO nd_diode_pad restrm_con_pad_1 > 0
//
   //pd_diode_pad_ok { COPY pd_diode_pad_ok }
   //nd_diode_pad_ok { COPY nd_diode_pad_ok }
//
// internal node is pad node if rblock < 200
//
// shorted, if < 200 Ohm
//-----------------------
// do ndriver/pdiver check before to avoid trans errors from analog pad
//
// propagate pad node
//
//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
// connect pdiff res
//
   CONNECT xblock_lt_200 RESTRM
//
// connect poly1/2/h res
//
   CONNECT xblock_p_lt_200 RESTRM
   CONNECT xblock_p2_lt_200 RESTRM
   CONNECT xblock_ph_lt_200 preshterm
//
//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
// for debugging
//
#UNDEFINE AFTER_RBLOCK
#IFDEF AFTER_RBLOCK
//
// get all connected to rblock lt 200
//
   met2_rdiffp_rblock  = NET AREA RATIO routingmet2 routingmet1  routingpoly poly2_cut ndiff  pdiff  xblock_lt_200 > 0
   met1_rdiffp_rblock  = NET AREA RATIO routingmet1 routingmet2  routingpoly  poly2_cut ndiff  pdiff  xblock_lt_200 > 0
   poly1_rdiffp_rblock = NET AREA RATIO routingpoly routingmet1 routingmet2 poly2_cut ndiff  pdiff  xblock_lt_200 > 0
   poly2_rdiffp_rblock = NET AREA RATIO poly2_cut routingpoly routingmet1 routingmet2  ndiff  pdiff  xblock_lt_200 > 0
   ndiff_rdiffp_rblock = NET AREA RATIO poly2_cut ndiff routingpoly routingmet1 routingmet2  pdiff  xblock_lt_200 > 0
   pdiff_rdiffp_rblock = NET AREA RATIO poly2_cut pdiff routingpoly routingmet1 routingmet2  ndiff  xblock_lt_200 > 0
//
   met2_rdiffp_rblock  { FLATTEN met2_rdiffp_rblock }
   met1_rdiffp_rblock  { FLATTEN met1_rdiffp_rblock }
   poly1_rdiffp_rblock { FLATTEN poly1_rdiffp_rblock }
   poly2_rdiffp_rblock { FLATTEN poly2_rdiffp_rblock }
   ndiff_rdiffp_rblock { FLATTEN ndiff_rdiffp_rblock }
   pdiff_rdiffp_rblock { FLATTEN pdiff_rdiffp_rblock }
//
   met2_rpoly1_rblock  = NET AREA RATIO routingmet2 routingmet1  routingpoly poly2_cut ndiff  pdiff  xblock_p_lt_200 > 0
   met1_rpoly1_rblock  = NET AREA RATIO routingmet1 routingmet2  routingpoly  poly2_cut ndiff  pdiff  xblock_p_lt_200 > 0
   poly1_rpoly1_rblock = NET AREA RATIO routingpoly routingmet1 routingmet2 poly2_cut ndiff  pdiff  xblock_p_lt_200 > 0
   poly2_rpoly1_rblock = NET AREA RATIO poly2_cut routingpoly routingmet1 routingmet2  ndiff  pdiff  xblock_p_lt_200 > 0
   ndiff_rpoly1_rblock = NET AREA RATIO poly2_cut ndiff routingpoly routingmet1 routingmet2  pdiff  xblock_p_lt_200 > 0
   pdiff_rpoly1_rblock = NET AREA RATIO poly2_cut pdiff routingpoly routingmet1 routingmet2  ndiff  xblock_p_lt_200 > 0
//
   met2_rpoly1_rblock  { FLATTEN met2_rpoly1_rblock }
   met1_rpoly1_rblock  { FLATTEN met1_rpoly1_rblock }
   poly1_rpoly1_rblock { FLATTEN poly1_rpoly1_rblock }
   poly2_rpoly1_rblock { FLATTEN poly2_rpoly1_rblock }
   ndiff_rpoly1_rblock { FLATTEN ndiff_rpoly1_rblock }
   pdiff_rpoly1_rblock { FLATTEN pdiff_rpoly1_rblock }
#ENDIF
//
//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
// check for diodes after blocking res
//
   pd_diode_pdiff_area1 = pdiff INTERACT pd_all_pd
   nd_diode_ndiff_area1 = ndiff INTERACT nd_all_nd
   pd_diode_pad_clamp = NET AREA RATIO pd_diode_pdiff_area1 bondpad_nosupply_1 > 0
   nd_diode_pad_clamp = NET AREA RATIO nd_diode_ndiff_area1 bondpad_nosupply_1 > 0
//
   restrm_con_pad_2 = NET AREA RATIO RESTRM bondpad_nosupply_1 > 0
   //restrm_con_pad_2 { COPY restrm_con_pad_2 }
//
// get diodes connected to pad term of rblock
   pd_diode_pad_ok_clamp = (NET AREA RATIO pd_diode_pad_clamp restrm_con_pad_2 > 0) NOT pd_diode_pad_ok
   nd_diode_pad_ok_clamp = (NET AREA RATIO nd_diode_pad_clamp restrm_con_pad_2 > 0) NOT nd_diode_pad_ok
//
   //pd_diode_pad_ok_clamp { COPY pd_diode_pad_ok_clamp }
   //nd_diode_pad_ok_clamp { COPY nd_diode_pad_ok_clamp }
//
//
   ana_block = NET AREA RATIO bondpad_nosupply_1 xblock_lt_200 > 0
   ana_d1 = STAMP pd_diode_pad_ok BY pdiff 
   ana_d2 = STAMP nd_diode_pad_ok BY ndiff 
   ana_d3 = STAMP pd_diode_pad_ok_clamp BY pdiff 
   ana_d4 = STAMP nd_diode_pad_ok_clamp BY ndiff 
// get pad connected
   ana_pad1 = NET AREA RATIO bondpad_nosupply_1 ana_d1 > 0
   ana_pad2 = NET AREA RATIO bondpad_nosupply_1 ana_d2 > 0
   ana_pad3 = NET AREA RATIO bondpad_nosupply_1 ana_d3 > 0
   ana_pad4 = NET AREA RATIO bondpad_nosupply_1 ana_d4 > 0
   ana_padfor   = ana_pad1   AND ana_pad2
   ana_padclamp = ana_pad3   AND ana_pad4
   ana_all   = ana_padfor AND ana_padclamp
//
   bondpad_ana_diode_ok =  ana_block AND ana_all
//
   ANALOG_PAD_RBLK_LT200_E01RB { @ Analog pad with protection diodes, rblock < 200 Ohm
      FLATTEN bondpad_ana_diode_ok
   }
   ANALOG_PAD_RBLK_LT200_MISSFOR { @ Analog pad with missing forward diodes and rblock < 200 Ohm
     FLATTEN ( ana_block NOT ana_padfor)
   }
   ANALOG_PAD_RBLK_LT200_MISSCLAMP { @ Analog pad with missing clamp diodes and rblock < 200 Ohm
     FLATTEN ( ana_block NOT ana_padclamp)
   }
//
//======================================================================
//                        LATCHUP CHECKS              
//======================================================================
//   INCLUDE "/fsup04/prgsun/mentor/ams/calibre/esdcheck/latchup.run"
//======================================================================
//                      LATCHUP CHECK WITH TRIGGER 
//======================================================================
// 18-May-06 : use INSIDE EDGE for clusters
//             change SCR spacing for c35 to 15 U and LAT3 = 20 U
//======================================================================
//   P_TRIG_INFO_LATCHUP                                                                                      
//   N_TRIG_INFO_LATCHUP                                                                                      
//   P_TRIG_SCR_25_REGION_LATCHUP                                                                                      
//   P_TRIG_100_NOGUARD_LATCHUP                                                                                      
//   P_TRIG_100_MISS_PTAP_LATCHUP                                                                                      
//   P_TRIG_100_MISS_NTAP_LATCHUP                                                                                      
//   N_TRIG_SCR_25_REGION_LATCHUP                                                                                      
//   N_TRIG_100_NOGUARD_LATCHUP                                                                                      
//   N_TRIG_100_MISS_PTAP_LATCHUP                                                                                      
//   N_TRIG_100_MISS_NTAP_LATCHUP                                                                                      
// steps
// trigger
// - get trigger pdiff/ndiff , connected to pad
//   bulk diff net , rblock < 200
// - ntap ptap 25 U near by
// 
// Thyristor
// - get SCR p,n diff connected to pad
// - get pdiff in ntub and ndiff in substrate conn vdd/vss
// - do spacing check < 25 U output edges to avoid euclidean clustering ( crash)
// - expand these error edges
// - do spacing 100 U and select expanded error messages in range
// - get diff polygons back
// - remove edge to gate 
// - do spacing check 25 U euclidean, clean by sizing 
// - get ndiff/pdiff involved in 25 u
// - ger ntap/ptap guard with met1 and min cont
// - check for ptap/natp guard 
//   all missing, ntap missing, ptap missing
// - select ndiff/pdiff in error
// - do spacing to trigger 100 U again
//   cut erroro region again with ntap / ptap and
//   check for interactions
//
// attention error cluster can cause 
// FAILURE IN DRC POLYGON SEGMENTER
//
// check for trigger location
// get s/d diffusion
//
// check for s/d diff after blocking res
//
// pd_diode_pdiff_area1 = pdiff INTERACT pd_all_pd
// nd_diode_ndiff_area1 = ndiff INTERACT nd_all_nd
// pd_diode_pad_clamp = NET AREA RATIO pd_diode_pdiff_area1 bondpad_nosupply_1 > 0
// nd_diode_pad_clamp = NET AREA RATIO nd_diode_ndiff_area1 bondpad_nosupply_1 > 0
//
//
   //pgate_sd_padc_nosupply = NET AREA RATIO pgate_sd bondpad_nosupply_1 > 0
   //ngate_sd_padc_nosupply = NET AREA RATIO ngate_sd bondpad_nosupply_1 > 0
   //pgate_sd_padc_nosupply { FLATTEN pgate_sd_padc_nosupply }
   //ngate_sd_padc_nosupply { FLATTEN ngate_sd_padc_nosupply }
#UNDEFINE LATCHUP_DEBUG
//
// trigger condition 1
//-----------------------
// get s/d diff connected to pad via met1/poly with diffnet on bulk
// only if rblock < 200 
// all pads, supply also


#DEFINE ALLDIFF
#IFDEF ALLDIFF
//
// all diff
//
   pgate_sd_alldiff = pdiff AND routingnwell
   ngate_sd_alldiff = ndiff NOT routingnwell
//
   pgate_sd_padc_all = NET AREA RATIO pgate_sd_alldiff bondpad > 0
   ngate_sd_padc_all = NET AREA RATIO ngate_sd_alldiff bondpad > 0
#ELSE
//
   pgate_sd_padc_all = NET AREA RATIO pgate_sd bondpad > 0
   ngate_sd_padc_all = NET AREA RATIO ngate_sd bondpad > 0
#ENDIF
//
   pgate_sd_bulk_diffnet = EXT pgate_sd_padc_all routingnwell < 0.01 INSIDE ALSO NOT CONNECTED REGION
   pgate_sd_padc_all_trig1 = pgate_sd_padc_all INTERACT  pgate_sd_bulk_diffnet
//
   ngate_sd_bulk_diffnet = EXT ngate_sd_padc_all substrate < 0.01 INSIDE ALSO NOT CONNECTED REGION
   ngate_sd_padc_all_trig1 = ngate_sd_padc_all INTERACT  ngate_sd_bulk_diffnet
//
#IFDEF LATCHUP_DEBUG
   pgate_sd_padc_all { FLATTEN pgate_sd_padc_all }
   ngate_sd_padc_all { FLATTEN ngate_sd_padc_all }
   P_TRIGGER1 { FLATTEN  pgate_sd_padc_all_trig1 }
   N_TRIGGER1 { FLATTEN  ngate_sd_padc_all_trig1 }
#ENDIF
//
// trigger condition 2
//-----------------------
// is there a substrate cont near by within 25 U
// check for distance pgate pmos  to welltap > 25
// / if NOT, it is a trigger (LAT3 rule) !!!!!!!!!
//
   ntap_pmos_ntub_pgate = routingnwell INTERACT  pgate_sd_padc_all_trig1
   ntap_pmos_welltap_ovs_0 = SIZE welltap      BY 20.0 INSIDE OF ntap_pmos_ntub_pgate STEP 1.0
   pgate_sd_padc_all_trig2 = pgate_sd_padc_all_trig1 NOT INSIDE  ntap_pmos_welltap_ovs_0
   P_TRIG_INFO_LATCHUP {@ INFO LATCHUP : Possible p trigger for latchup (pdiff connected to pad)
        FLATTEN pgate_sd_padc_all_trig2 
   }
//
// store this welltap
//
   //ptrig_welltap = welltap INSIDE (ntap_pmos_welltap_ovs_0 INTERACT pgate_sd_padc_all_trig2)
    ptrig_welltap = welltap INSIDE ntap_pmos_ntub_pgate
   //ptrig_welltap { COPY ptrig_welltap }
//
// check for distance ngate nmos  to subtap > 25
//
   ptap_nmos_subtap_ovs_0  = SIZE subtap BY 20.0 OUTSIDE OF routingnwell STEP 1.0
   ngate_sd_padc_all_trig2 = ngate_sd_padc_all_trig1 NOT INSIDE ptap_nmos_subtap_ovs_0
   N_TRIG_INFO_LATCHUP {@ INFO LATCHUP : Possible n trigger for latchup (ndiff connected to pad)
        FLATTEN ngate_sd_padc_all_trig2 
   }

#UNDEFINE TRIG_DEBUG
#IFDEF TRIG_DEBUG
//
// get all connected to trigger pdiff
//
   met3_ptrig = NET AREA RATIO routingmet3 routingmet2 routingmet1 routingpoly pgate_sd_padc_all_trig2 > 0
   met2_ptrig = NET AREA RATIO routingmet2 routingmet1 routingmet3 routingpoly pgate_sd_padc_all_trig2 > 0
   met1_ptrig = NET AREA RATIO routingmet1 routingmet2 routingmet3 routingpoly pgate_sd_padc_all_trig2 > 0
   poly1_ptrig = NET AREA RATIO routingpoly routingmet1 routingmet2 routingmet3  pgate_sd_padc_all_trig2 > 0
//
   met3_ptrig { FLATTEN met3_ptrig }
   met2_ptrig { FLATTEN met2_ptrig }
   met1_ptrig { FLATTEN met1_ptrig }
   poly1_ptrig { FLATTEN poly1_ptrig }
//
   met3_ntrig = NET AREA RATIO routingmet3 routingmet2 routingmet1 routingpoly ngate_sd_padc_all_trig2 > 0
   met2_ntrig = NET AREA RATIO routingmet2 routingmet1 routingmet3 routingpoly ngate_sd_padc_all_trig2 > 0
   met1_ntrig = NET AREA RATIO routingmet1 routingmet2 routingmet3 routingpoly ngate_sd_padc_all_trig2 > 0
   poly1_ntrig = NET AREA RATIO routingpoly routingmet1 routingmet2 routingmet3  ngate_sd_padc_all_trig2 > 0
//
   met3_ntrig { FLATTEN met3_ntrig }
   met2_ntrig { FLATTEN met2_ntrig }
   met1_ntrig { FLATTEN met1_ntrig }
   poly1_ntrig { FLATTEN poly1_ntrig }
//
#ENDIF
//
// search for SCR 
//----------------------------
//
// search s/d pdiff nwell same potential
// search s/d ndiff substrate same potential
//------------------------------------------------
// this is s/d which is connected to same bulk (VDD/VSS)
//
   //ngate_sd = ndiff INTERACT ngate
   //pgate_sd = pdiff INTERACT pgate

#IFDEF ALLDIFF
   pgate_sd_bulk_scr_samenet = EXT pgate_sd_alldiff routingnwell < 0.01 INSIDE ALSO CONNECTED REGION
   ngate_sd_bulk_scr_samenet = EXT ngate_sd_alldiff substrate < 0.01 INSIDE ALSO CONNECTED REGION
#ELSE
   pgate_sd_bulk_scr_samenet = EXT pgate_sd routingnwell < 0.01 INSIDE ALSO CONNECTED REGION
   ngate_sd_bulk_scr_samenet = EXT ngate_sd substrate < 0.01 INSIDE ALSO CONNECTED REGION
#ENDIF
//
   ngate_sd_vss = COPY ngate_sd_bulk_scr_samenet 
   pgate_sd_vdd = COPY pgate_sd_bulk_scr_samenet 
//
// do spacing check 25 U 
// get edges in error, but expand to polygon
//
   spac25_ngate_sd_vss_edge_1 =  EXT [ngate_sd_vss] pgate_sd_vdd < 15.0
   spac25_ngate_sd_vss_edge   =  EXPAND EDGE spac25_ngate_sd_vss_edge_1 OUTSIDE BY 0.1
//
   spac25_pgate_sd_vdd_edge_1 =  EXT ngate_sd_vss [pgate_sd_vdd] < 15.0
   spac25_pgate_sd_vdd_edge   =  EXPAND EDGE spac25_pgate_sd_vdd_edge_1 OUTSIDE BY 0.1
#IFDEF LATCHUP_DEBUG
   pgate_sd_bulk_scr_samenet  { FLATTEN pgate_sd_bulk_scr_samenet }
   ngate_sd_bulk_scr_samenet  { FLATTEN ngate_sd_bulk_scr_samenet }
   spac25_ngate_sd_vss_edge  { FLATTEN  spac25_ngate_sd_vss_edge  }
   spac25_pgate_sd_vdd_edge  { FLATTEN  spac25_pgate_sd_vdd_edge  }
#ENDIF
//
// check from trigger in a circle of 100 U (euclidean check)
//------------------------------------------------------------
//
// check pdiff con pad to SCR
//
   ptrig_n_100_circle = EXT pgate_sd_padc_all_trig2  spac25_ngate_sd_vss_edge < 100.0 REGION 
   ptrig_p_100_circle = EXT pgate_sd_padc_all_trig2  spac25_pgate_sd_vdd_edge < 100.0 REGION 
//
// check ndiff con pad to SCR
//
   ntrig_n_100_circle = EXT ngate_sd_padc_all_trig2  spac25_ngate_sd_vss_edge < 100.0 REGION 
   ntrig_p_100_circle = EXT ngate_sd_padc_all_trig2  spac25_pgate_sd_vdd_edge < 100.0 REGION 
// 
// get ndiff/pdiff in this circle expanded edges in error ( remove trigger diff)
//
   ptrig_n_100_n_edge = spac25_ngate_sd_vss_edge  INTERACT  ptrig_n_100_circle
   ptrig_p_100_p_edge = spac25_pgate_sd_vdd_edge  INTERACT  ptrig_p_100_circle
   ntrig_n_100_n_edge = spac25_ngate_sd_vss_edge  INTERACT  ntrig_n_100_circle
   ntrig_p_100_p_edge = spac25_pgate_sd_vdd_edge  INTERACT  ntrig_p_100_circle
//
#IFDEF LATCHUP_DEBUG
//
   NTRIG_PDIFF_CIRCLE_100 { FLATTEN ntrig_p_100_circle }
   NTRIG_NDIFF_CIRCLE_100 { FLATTEN ntrig_n_100_circle }
   PTRIG_PDIFF_CIRCLE_100 { FLATTEN ptrig_p_100_circle }
   PTRIG_NDIFF_CIRCLE_100 { FLATTEN ptrig_n_100_circle }
//
// edges, but expanded 
//
   ptrig_n_100_n_edge { COPY ptrig_n_100_n_edge }
   ptrig_p_100_p_edge { COPY ptrig_p_100_p_edge }
   ntrig_n_100_n_edge { COPY ntrig_n_100_n_edge }
   ntrig_p_100_p_edge { COPY ntrig_p_100_p_edge }
//
#ENDIF
//
// get original diffs in error and get diff edge again and remove edge to gate
// to make error cluster simpler
//
// >>>>>>>>>>>>>>>>>>>>>  use this later
#IFDEF ALLDIFF
//------------------------------------------------------------------------
   ptrig_n_100_n_polyg_1 = ngate_sd_alldiff INTERACT ptrig_n_100_n_edge
   ptrig_p_100_p_polyg_1 = pgate_sd_alldiff INTERACT ptrig_p_100_p_edge
   ntrig_n_100_n_polyg_1 = ngate_sd_alldiff INTERACT ntrig_n_100_n_edge
   ntrig_p_100_p_polyg_1 = pgate_sd_alldiff INTERACT ntrig_p_100_p_edge
//------------------------------------------------------------------------
#ELSE
   ptrig_n_100_n_polyg_1 = ngate_sd INTERACT ptrig_n_100_n_edge
   ptrig_p_100_p_polyg_1 = pgate_sd INTERACT ptrig_p_100_p_edge
   ntrig_n_100_n_polyg_1 = ngate_sd INTERACT ntrig_n_100_n_edge
   ntrig_p_100_p_polyg_1 = pgate_sd INTERACT ntrig_p_100_p_edge
#ENDIF
//
// not gate edge
   ptrig_n_100_n_polyg = ptrig_n_100_n_polyg_1 NOT COIN EDGE routingpoly
   ptrig_p_100_p_polyg = ptrig_p_100_p_polyg_1 NOT COIN EDGE routingpoly
   ntrig_n_100_n_polyg = NOT COIN EDGE ntrig_n_100_n_polyg_1 routingpoly
   ntrig_p_100_p_polyg = ntrig_p_100_p_polyg_1 NOT COIN EDGE routingpoly
//
#IFDEF LATCHUP_DEBUG
   ntrig_n_100_n_polygx  { COPY ntrig_n_100_n_polyg_1 }
   ntrig_p_100_p_polygx  { COPY ntrig_p_100_p_polyg_1 }
   ptrig_n_100_n_polygx  { COPY ptrig_n_100_n_polyg_1 }
   ptrig_p_100_p_polygx  { COPY ptrig_p_100_p_polyg_1 }
#ENDIF
//
// no advantage, idea only
   //ptrig_spac_25_cc_1 = EXT ptrig_n_100_n_polyg ptrig_p_100_p_polyg < 25.0 CORNER TO CORNER REGION
   //ptrig_spac_25_nc_1 = EXT ptrig_n_100_n_polyg ptrig_p_100_p_polyg < 25.0 NOT CORNER REGION
   //ntrig_spac_25_cc_1 = EXT ntrig_n_100_n_polyg ntrig_p_100_p_polyg < 25.0 CORNER TO CORNER REGION
   //ntrig_spac_25_nc_1 = EXT ntrig_n_100_n_polyg ntrig_p_100_p_polyg < 25.0 NOT CORNER REGION
//
// no , use all regions
// this are the error regions 25 U
//
   ptrig_spac_25_nc_1 = EXT ptrig_n_100_n_polyg ptrig_p_100_p_polyg < 15.0 REGION
   ntrig_spac_25_nc_1 = EXT ntrig_n_100_n_polyg ntrig_p_100_p_polyg < 15.0 REGION
//
   //gate_diff = ngate_sd OR pgate_sd
//
// clean error region
//
// oversize to make sure overlaps diff ( rounding)
//
   //ptrig_spac_25_cc = ptrig_spac_25_cc_1 NOT taps_all 
   //ntrig_spac_25_cc = ntrig_spac_25_cc_1 NOT taps_all 
   //ptrig_spac_25_cc { FLATTEN ptrig_spac_25_cc }
   //ntrig_spac_25_cc { FLATTEN ntrig_spac_25_cc }
//
// this is the final clustster, cleaned
// cleaned for cutting wit taps
   ptrig_spac_25_nc = SIZE (SIZE ptrig_spac_25_nc_1 BY 0.9 OVERUNDER) BY 0.1 
   ntrig_spac_25_nc = SIZE (SIZE ntrig_spac_25_nc_1 BY 0.9 OVERUNDER) BY 0.1 
//
#IFDEF LATCHUP_DEBUG
   ptrig_spac_25_nc { FLATTEN ptrig_spac_25_nc }
   ntrig_spac_25_nc { FLATTEN ntrig_spac_25_nc }
#ENDIF
//
// process taps
//-----------------
// check for double guard
//
   taps_all = subtap OR welltap
//
// get met1 over subtap
//---------------------
// close conts
// hard wired taps ( metal1 and conts )
// 0.8 is relaxed, 0.5 min
//
   ptap_conts = subtap AND pdiffcon
   //ptap_conts { COPY ptap_conts }
   met1_ptap_all = ( MET1 AND subtap ) ENCLOSE ptap_conts
   met1_ptap =  (SIZE( ptap_conts INSIDE met1_ptap_all ) BY 0.8 OVERUNDER) AND met1_ptap_all
//
// get met1 over ntap
//--------------------
   ntap_conts = welltap AND ndiffcon
   //ntap_conts { COPY ntap_conts }
   met1_ntap_all = ( MET1 AND welltap ) ENCLOSE ntap_conts
   met1_ntap =  (SIZE( ntap_conts INSIDE met1_ntap_all ) BY 0.8 OVERUNDER) AND met1_ntap_all
   //met1_ntap { FLATTEN met1_ntap }
   //met1_ptap { FLATTEN met1_ptap }
//
   met1_taps = met1_ntap OR met1_ptap
//
// p-trigger condition, check for missing guards 25 U
//======================================================
// error region 
// cehck for nu guard or ntap or ptap missing
//
   ptrig_spac_25_a =  (ptrig_spac_25_nc NOT met1_taps) INTERACT ptrig_p_100_p_polyg_1 
   ptrig_spac_25_noguard = ptrig_spac_25_a INTERACT ptrig_n_100_n_polyg_1
// not sufficient taps 
//
// cut out error region with p - guard
// does it touch pdiff ? 
// check if p sees n and n sees p  
   ptrig_spac_25_b = ptrig_spac_25_nc  NOT  met1_ptap 
   ptrig_spac_25_miss_ptap = (ptrig_spac_25_b INTERACT ptrig_p_100_p_polyg_1) INTERACT ptrig_n_100_n_polyg_1
// cut out error region with n - guard
// does it touch ndiff
   ptrig_spac_25_c = ptrig_spac_25_nc  NOT  met1_ntap 
   ptrig_spac_25_miss_ntap = (ptrig_spac_25_c INTERACT ptrig_n_100_n_polyg_1) INTERACT ptrig_p_100_p_polyg_1
//
   ptrig_spac_25_bad_tap_1 = ptrig_spac_25_noguard OR (ptrig_spac_25_miss_ntap OR ptrig_spac_25_miss_ptap)
   ptrig_spac_25_bad_tap = ptrig_spac_25_bad_tap_1 NOT met1_taps
// 
// this is scr without guard or bad guard
   P_TRIG_SCR_25_REGION_LATCHUP { @ INFO LATCHUP : SCR (15 U)  near p Trigger (100), check guards 
                                  @ must have p and n guard, met1 connected
                                  @ guard missing, met1 and/or diffconts missing
      FLATTEN ptrig_spac_25_bad_tap 
   }
//
#IFDEF LATCHUP_DEBUG
   ptrig_spac_25_noguard { FLATTEN ptrig_spac_25_noguard }
   ptrig_spac_25_miss_ptap { FLATTEN ptrig_spac_25_miss_ptap } 
   ptrig_spac_25_miss_ntap { FLATTEN ptrig_spac_25_miss_ntap } 
#ENDIF
//
// get pdiff/ndiff scr with bad guard or missing
//-----------------------------------------------
//
   ptrig_p_100_p_xx = ptrig_p_100_p_polyg_1 INTERACT  ptrig_spac_25_bad_tap
   ptrig_n_100_n_xx = ptrig_n_100_n_polyg_1 INTERACT  ptrig_spac_25_bad_tap
   ptrig_pn_100_xx =  ptrig_p_100_p_xx  OR ptrig_n_100_n_xx
//
   ptrig_pn_100_circle = EXT pgate_sd_padc_all_trig2   ptrig_pn_100_xx < 100.0 REGION 
//
#IFDEF LATCHUP_DEBUG
   ptrig_p_100_p_xx { FLATTEN ptrig_p_100_p_xx }
   ptrig_n_100_n_xx { FLATTEN ptrig_n_100_n_xx }
   ptrig_pn_100_xx { FLATTEN ptrig_pn_100_xx }
   ptrig_pn_100_circle { FLATTEN ptrig_pn_100_circle }
#ENDIF
//
// check if 100 U circle is cut by double guard
//-----------------------------------------------
// double guard consists of ptap and ntap connected to ptrig substrate diff
//
// ntap should have same potential than trigger pdiff ntap
// check if same potential ptrig_welltap
//
   welltap_conn_ptrig_welltap = NET AREA RATIO welltap ptrig_welltap > 0
//
   // welltap_conn_ptrig_welltap { FLATTEN welltap_conn_ptrig_welltap }
   met1_ntap_conn_ptrig = welltap_conn_ptrig_welltap AND met1_ntap
//
   ptrig_spac_100_a = (ptrig_pn_100_circle NOT (met1_ptap OR met1_ntap_conn_ptrig )) INTERACT pgate_sd_padc_all_trig2
   ptrig_spac_100_noguard =  ptrig_spac_100_a INTERACT ptrig_pn_100_xx
//
   P_TRIG_100_NOGUARD_LATCHUP { @ P Trigger latchup problem (100U) , missing double guard or guard incomplete
                                @ or n-guard not connected to P-Trigger ntap 
       uu = FLATTEN ptrig_spac_100_noguard 
       INSIDE EDGE uu substrate_all
       FLATTEN (SIZE (ptrig_pn_100_xx INTERACT ptrig_spac_100_noguard) BY -0.2)
       x = pgate_sd_padc_all_trig2 INTERACT ptrig_spac_100_noguard
       u = EXTENTS x CENTERS 0.2
       FLATTEN (((SIZE x BY -0.2) NOT (SIZE x BY -0.4)) OR u)
   }
//
   ptrig_spac_100_b = ptrig_pn_100_circle NOT met1_ptap
   ptrig_spac_100_miss_ptap = (ptrig_spac_100_b INTERACT ptrig_pn_100_xx) INTERACT pgate_sd_padc_all_trig2
//
   P_TRIG_100_MISS_PTAP_LATCHUP { @ P Trigger latchup problem (100U), missing ptap guard or guard incomplete
                                  @ or n-guard not connected to P-Trigger ntap 
       uu = FLATTEN ptrig_spac_100_miss_ptap 
       INSIDE EDGE uu substrate_all
       FLATTEN (SIZE (ptrig_pn_100_xx INTERACT ptrig_spac_100_miss_ptap) BY -0.2)
       x = pgate_sd_padc_all_trig2 INTERACT ptrig_spac_100_miss_ptap
       u = EXTENTS x CENTERS 0.2
       FLATTEN (((SIZE x BY -0.2) NOT (SIZE x BY -0.4)) OR u)
   }
//
   ptrig_spac_100_c = ptrig_pn_100_circle NOT met1_ntap_conn_ptrig
   ptrig_spac_100_miss_ntap = (ptrig_spac_100_c INTERACT ptrig_pn_100_xx) INTERACT pgate_sd_padc_all_trig2
//
   P_TRIG_100_MISS_NTAP_LATCHUP { @ P Trigger latchup problem (100U), missing ntap guard or guard incomplete
                                  @ or n-guard not connected to P-Trigger ntap 
       uu = FLATTEN ptrig_spac_100_miss_ntap 
       INSIDE EDGE uu substrate_all
       FLATTEN (SIZE (ptrig_pn_100_xx INTERACT ptrig_spac_100_miss_ntap) BY -0.2)
       x = pgate_sd_padc_all_trig2 INTERACT ptrig_spac_100_miss_ntap
       u = EXTENTS x CENTERS 0.2
       FLATTEN (((SIZE x BY -0.2) NOT (SIZE x BY -0.4)) OR u)
   }
//
// n-trigger condition, check for missing guards 25 U
//======================================================
// error region 
//
   ntrig_spac_25_a =  (ntrig_spac_25_nc NOT met1_taps) INTERACT ntrig_p_100_p_polyg_1 
   ntrig_spac_25_noguard = ntrig_spac_25_a INTERACT ntrig_n_100_n_polyg_1
// not sufficient taps 
//
// cut out error region with p - guard
// does it touch pdiff ? 
// check if p sees n and n sees p  
   ntrig_spac_25_b = ntrig_spac_25_nc  NOT  met1_ptap 
   ntrig_spac_25_miss_ptap = (ntrig_spac_25_b INTERACT ntrig_p_100_p_polyg_1) INTERACT ntrig_n_100_n_polyg_1
// cut out error region with n - guard
// does it touch ndiff
   ntrig_spac_25_c = ntrig_spac_25_nc  NOT  met1_ntap 
   ntrig_spac_25_miss_ntap = (ntrig_spac_25_c INTERACT ntrig_n_100_n_polyg_1) INTERACT ntrig_p_100_p_polyg_1
//
   ntrig_spac_25_bad_tap_1 = ntrig_spac_25_noguard OR (ntrig_spac_25_miss_ntap OR ntrig_spac_25_miss_ptap)
   ntrig_spac_25_bad_tap = ntrig_spac_25_bad_tap_1 NOT met1_taps
// 
   N_TRIG_SCR_25_REGION_LATCHUP { @ INFO LATCHUP : SCR (15 U) near n Trigger (100 U), check guards 
                                  @ must have p and n guard, met1 connected
                                  @ guard missing, met1 and/or diffconts missing
       FLATTEN ntrig_spac_25_bad_tap
   }
//
#IFDEF LATCHUP_DEBUG
   ntrig_spac_25_noguard { FLATTEN ntrig_spac_25_noguard }
   ntrig_spac_25_miss_ptap { FLATTEN ntrig_spac_25_miss_ptap } 
   ntrig_spac_25_miss_ntap { FLATTEN ntrig_spac_25_miss_ntap } 
#ENDIF
//
// get pdiff/ndiff scr with bad guard or missing
//-----------------------------------------------
   ntrig_p_100_p_xx = ntrig_p_100_p_polyg_1 INTERACT  ntrig_spac_25_bad_tap
   ntrig_n_100_n_xx = ntrig_n_100_n_polyg_1 INTERACT  ntrig_spac_25_bad_tap
   ntrig_pn_100_xx =  ntrig_p_100_p_xx  OR ntrig_n_100_n_xx
//
   ntrig_pn_100_circle = EXT ngate_sd_padc_all_trig2   ntrig_pn_100_xx < 100.0 REGION
#IFDEF LATCHUP_DEBUG
   ntrig_p_100_p_xx { FLATTEN ntrig_p_100_p_xx }
   ntrig_n_100_n_xx { FLATTEN ntrig_n_100_n_xx }
   ntrig_pn_100_xx { FLATTEN ntrig_pn_100_xx }
   ntrig_pn_100_circle { FLATTEN ntrig_pn_100_circle }
#ENDIF
//
// check if 100 U circle is cut by double guard
//-----------------------------------------------
//
   ntrig_spac_100_a = (ntrig_pn_100_circle NOT met1_taps) INTERACT ngate_sd_padc_all_trig2
   ntrig_spac_100_noguard =  ntrig_spac_100_a INTERACT ntrig_pn_100_xx
   N_TRIG_100_NOGUARD_LATCHUP { @ N Trigger latchup problem (100U), missing double guard or bad guard
       uu=FLATTEN ntrig_spac_100_noguard
       INSIDE EDGE uu substrate_all
       FLATTEN (SIZE (ntrig_pn_100_xx INTERACT ntrig_spac_100_noguard) BY -0.2)
       x = ngate_sd_padc_all_trig2 INTERACT ntrig_spac_100_noguard
       u = EXTENTS x CENTERS 0.2
       FLATTEN (((SIZE x BY -0.2) NOT (SIZE x BY -0.4)) OR u)
   }
//
   ntrig_spac_100_b = ntrig_pn_100_circle NOT met1_ptap
   ntrig_spac_100_miss_ptap = (ntrig_spac_100_b INTERACT ntrig_pn_100_xx) INTERACT ngate_sd_padc_all_trig2
   N_TRIG_100_MISS_PTAP_LATCHUP { @ N Trigger latchup problem (100U), missing double guard
       uu=FLATTEN ntrig_spac_100_miss_ptap
       INSIDE EDGE uu substrate_all
       FLATTEN (SIZE (ntrig_pn_100_xx INTERACT ntrig_spac_100_miss_ptap) BY -0.2)
       x = ngate_sd_padc_all_trig2 INTERACT ntrig_spac_100_miss_ptap
       u = EXTENTS x CENTERS 0.2
       FLATTEN (((SIZE x BY -0.2) NOT (SIZE x BY -0.4)) OR u)
   }
//
   ntrig_spac_100_c = ntrig_pn_100_circle NOT met1_ntap
   ntrig_spac_100_miss_ntap = (ntrig_spac_100_c INTERACT ntrig_pn_100_xx) INTERACT ngate_sd_padc_all_trig2
   N_TRIG_100_MISS_NTAP_LATCHUP { @ N Trigger latchup problem (100U), missing double guard
       uu=FLATTEN ntrig_spac_100_miss_ntap
       INSIDE EDGE uu substrate_all
       FLATTEN (SIZE (ntrig_pn_100_xx INTERACT ntrig_spac_100_miss_ntap) BY -0.2)
       x = ngate_sd_padc_all_trig2 INTERACT ntrig_spac_100_miss_ntap
       u = EXTENTS x CENTERS 0.2
       FLATTEN (((SIZE x BY -0.2) NOT (SIZE x BY -0.4)) OR u)
   }
///////////////////////////////////////////////////////////////////////
//
// for testing only
// gate_con_pad = NET AREA RATIO trans bondpad > 0
// gate_con_pad { COPY gate_con_pad }
//
//
//======================================================================
//                         3.4 POLY1/POLY2       
//======================================================================
//
   poly1_con_pad        = NET AREA RATIO routingpoly  bondpad > 0
   poly2_con_pad        = NET AREA RATIO routingpoly2 bondpad > 0
   routingnwell_con_pad = NET AREA RATIO routingnwell bondpad > 0 
   substrate_con_pad    = NET AREA RATIO substrate bondpad > 0 
//
   //ngate = trans NOT NTUB
   //pgate = trans AND NTUB
//
// G02P1 
// gate and bulk must be diffrerent pad nodes !!!
   pgate_net = STAMP pgate BY poly1_con_pad
// any nwell node !!!
   bad_pgate = EXT pgate_net routingnwell < 0.01 INSIDE ALSO NOT CONNECTED REGION
   //bad_pgate = EXT pgate_net routingnwell_con_pad < 0.01 INSIDE ALSO NOT CONNECTED REGION
   ILL_PGATE_BONDPAD_G02P1 { @ G02P1 : pgate must not be connected to pad node
      COPY bad_pgate
   }
   ngate_net = STAMP ngate BY poly1_con_pad
   bad_ngate = EXT ngate_net substrate_con_pad < 0.01 INSIDE ALSO NOT CONNECTED REGION
   ILL_NGATE_BONDPAD_G02P1 { @ G02P1 : ngate must not be connected to pad node
      COPY bad_ngate
   }
//
// deleted rev 2
// G01P1
//
// do not flag device poly
//   ILL_POLY1_BONDPAD_G01P1 { @ G01P1 : poly1 must not be connected to pad node
//      poly1_con_pad NOT (routingpoly INTERACT gate)
//   }
//
//
// G02P2
//
   ILL_CPOLY_BONDPAD_G02P2 { @ G02P2 : cpoly must not be connected between 2 pad nodes
      EXT poly1_con_pad poly2_con_pad < 0.01 INSIDE ALSO NOT CONNECTED REGION
   }
//
// deleted doc rev 2
// G01P2
// no cap top plate on supply ?
//
//  ILL_POLY2_BONDPAD_G01P2 { @ G01P2 : poly2 must not be connected between to pad nodes
//     COPY poly2_con_pad
//  }
//======================================================================
//                            3.5 CMIM       
//======================================================================
// not checked yet
//
//======================================================================
//                           3.1  NDIFF            
//======================================================================
//
// do not check if psub between ndiffs
// do not check if ntub overlap > 1
//  - find diff spacing < 4.5
//  - pdiff_substrate & diff spacing polygon
//  - oversize
//  - subract from diff
//  - nwell pverlap < 1
//  - touching ndiff
//  - do spacing check
//
// algorithm: 
//  - do spacing ndiff connected pad diffnet < 4.5 U and fill region
//    (this identifies areas) 
//  - do AND of error regions with vss guard diff
//     ( do NOT oversize , beacause this may cause
//     confusion if ndiff is cut out) 
//  - do spacing from ANDED region to ndiff edge, mark edge 
//     min guard is 0.3, do spacing 2.1
//  - get ndiff edge not coincident with this error regions
//  - check ovlp ntub <1, mark ndiff edge
//  - do spacing to ntub
//  - for g01dn : edges have lost node info : get ndiff edges in
//    error outside ntub and merge (AND) edges with original ndiff
//    edges in error (node info for edges is lost) . Expand edges
//    to get rects, stamp by ndiff und do final spacing with diffnet
//    ( this should avoid all false errors)
//  - do final spacing < 4.5 U between edges ( subtract subtap, make
//    corrections if subtap separates error region in 2 parts
//
//  The main problem for this check is, that the check should work
//  correctly in all angle situations . Thus spacing check must be done all angle
//  and shieldung should be also all angle. CALIBRE does not have any shadow
//  checking. Since all angle spacing check is done between ndiff - ndiff and
//  between ndiff - subtap the ndiff edges are marked differently and
//  and corrections are necessary
//
//
// a.) get all ndiff < 4.5 U spacing connected to different bond pads
//     remove snap diff
//----------------------------------------------------------------------
//
   ndiff_con_pad_net = NET AREA RATIO ndiff bondpad > 0
   //ndiff_con_pad_net { COPY ndiff_con_pad_net }
   ndiff_nosnap = ndiff_con_pad_net NOT INTERACT snap_ndiff 
   //ndiff_nosnap { COPY ndiff_nosnap }
   ndiff_pad_fill = EXT ndiff_nosnap < 4.5 NOT CONNECTED REGION
// remove false error over gate ndriver
// remove error over gate, not diff
// ndiff_pad_fill11 = ndiff_pad_fill NOT INTERACT ndr_ngate_sd_padc
//
   ndiff_pad_fill11 = ndiff_pad_fill NOT INTERACT ndr_ngate_prot
   ndiff_check_edge_1 = ndiff_nosnap COIN OUTSIDE EDGE ndiff_pad_fill11
#IFDEF debug
   ndiff_pad_fill11 { COPY ndiff_pad_fill11 }
   ndiff_check_edge_1 { COPY ndiff_check_edge_1 }
#ENDIF
//
//
// b.) check, if pdiff connected to vss separates ndiff
// shielding by p-diffusion
// select fill polygons touching pdiff-vss ( = subtap)
//------------------------------------------------------
//
// merge area of spacing error region and subtap
//
   ndiff_pad_fill22 = ndiff_pad_fill11 AND subtap
//
// c.) expand area of violation, do not use touch
//     to cut out this areas
//     min diff spacing 0.6, min pdiff width = 0.3
//     (4.5 - 0.3 )/2 = 2.1 
//--------------------------------------------------
//
// do spacing check to ndiff edge and remove edge
   ndiff_pad_sep = EXT ndiff_pad_fill22 ndiff_nosnap < 2.15 OPPOSITE PARA ONLY REGION
   //ndiff_pad_sep = EXT ndiff_pad_fill22 ndiff_nosnap < 2.15 PARA ONLY REGION
   ndiff_pad_edge = ( ndiff_nosnap INTERACT ndiff_pad_fill11) NOT COINCIDENT OUTSIDE EDGE ndiff_pad_sep 
#IFDEF debug
   ndiff_pad_sep { COPY ndiff_pad_sep }
   ndiff_pad_edge { COPY ndiff_pad_edge }
#ENDIF
//
// problem : shieldung is parallel opposite, ndiff spacing < 4.5 must be all angle
//           all angle errors should not be suppressed
//           this is the remaining area, if subtap shields error, but not on
//           end of guerd ring
// this region is the area, where shieldung of subtap should flag no error !!
// but there is a difference between all angle and para opposite
// this is used to make some correction of false errors
   ndiff_subtap_shield_angle = ( ndiff_pad_fill11 NOT ndiff_pad_sep) NOT subtap 
#IFDEF debug
   ndiff_subtap_shield_angle { COPY ndiff_subtap_shield_angle }
#ENDIF
//
// d) check if nwell overlaps ndiff < 1 U
//------------------------------------------
//
// get diff edge with nwell ovlp too small
   ndiff_pad_4 = ENC ndiff_pad_edge routingnwell < 1.0 OPPOSITE PARA ONLY REGION 
   ndiff_pad_4_edge = ndiff_pad_edge COINCIDENT OUTSIDE EDGE ndiff_pad_4 
#IFDEF debug
   ndiff_pad_4_edge { COPY ndiff_pad_4_edge }
#ENDIF
//
// G01DN min. ndiff spacing
//--------------------------
//
// nwell ovlp on both sides too small
//
// 8-May-2007 : false error suppression : ntap involved in spacing, but divided by substrate causes
// false error on other side of ntaps
// spacing region must overlap first 4.5 U spacing region
// ( not point to point, use and, not interact)
//
   SPAC_NDIFF_2_NTUB_G01DN { @ G01DN : ndiff spacing with nwell ovlp 2 sides < 1 U ( 4.5 U )
     x = EXT ndiff_pad_4_edge < 4.5 REGION
     y = ndiff_pad_fill11 AND x
     x INTERACT y
   }
//
// no nwell overlap on both sides
// diff edge not in nwell
// 
   ndiff_pad_3_edge = ndiff_pad_edge OUTSIDE EDGE routingnwell 
// make shape and propagate get node info
// need spacing between diff nodes
// only edges coincident with original 4.5 spacing errors !!
// (problems with narrow diff stripes (GDT conts))
//
   xndiff_pad_3_edge = ndiff_pad_3_edge COINCIDENT EDGE ndiff_check_edge_1
   ndiff_pad_3_edge_ex = xndiff_pad_3_edge EXPAND EDGE INSIDE BY 0.05
#IFDEF debug
   xndiff_pad_3_edge {COPY xndiff_pad_3_edge }
#ENDIF
   ndiff_pad_3_edge_net = STAMP ndiff_pad_3_edge_ex BY ndiff_nosnap
//
  //SPAC_NDIFF_NO_NTUB_G01DN { @ G01DN : ndiff spacing with no nwell ovlp <  4.5 U 
  // y = EXT ndiff_pad_3_edge_net  < 4.5 NOT CONNECTED REGION
  // d = y NOT subtap
  // d INTERACT ndiff_nosnap >= 2 
  //}
//
// improvement : only edges
//               perpendicular
//               by net : if touching more polygons
//                        on same side of subtap
//
   SPAC_NDIFF_NO_NTUB_G01DN { @ G01DN : ndiff spacing with no nwell ovlp <  4.5 U
     x2 = LENGTH (ndiff_pad_3_edge_net COINCIDENT EDGE  ndiff_nosnap) > 0.05
     // y = EXT x2 < 4.5 NOT CONNECTED REGION
     y = EXT x2 < 4.5 NOT CONNECTED PERPENDICULAR ALSO REGION
     d = y NOT subtap
     d INTERACT ndiff_nosnap >= 2 BY NET
   }
//
// nwell overlap on one side only
// use polygons, but does not make any difference
// stamping needs polygon
// edge has node info also, use edge to avoid false errors
//
   ndiff_pad_4_edge_ex = ndiff_pad_4_edge EXPAND EDGE INSIDE BY 0.05
   SPAC_NDIFF_1_NTUB_G01DN { @ G01DN : ndiff spacing with nwell ovlp one side < 1 U ( 4.5 U )
     ndiff_pad_4_edge_net = STAMP ndiff_pad_4_edge_ex BY ndiff_nosnap
     x1 = LENGTH (ndiff_pad_4_edge_net COINCIDENT EDGE  ndiff_nosnap) > 0.05
     x2 = LENGTH (ndiff_pad_3_edge_net COINCIDENT EDGE  ndiff_nosnap) > 0.05
     c = EXT x1 x2 < 4.5 NOT CONNECTED PERPENDICULAR ALSO REGION
     d = c NOT subtap
     d INTERACT ndiff_nosnap >= 2
   }
//
// G02DN min. ndiff spacing to ntub
//----------------------------------
//
// remove some false errors if subtap shields
   SPAC_NDIFF_NTUB_G02DN { @ G02DN : ndiff/ntub spacing with nwell ovlp one side < 1 U ( 4.5 U ) 
     x = EXT ndiff_pad_4_edge routingnwell < 4.5 MEASURE ALL REGION
     y = x NOT subtap
     z = ndiff_subtap_shield_angle INTERACT ndiff_nosnap >=2
     y INTERACT z
   }
//
// what has been tested :
//------------------------
// attention : the check is triggered if ndiff spac < 4.5 U !!!
//
//  ndiff-ndiff with no nwell ovlp + subbus ..ok
//  ndiff-ndiff 1 side ovlp < 1  + subbus ..ok ..all angle ok
//  ndiff-ndiff 2 side ovlp > 1 ..ok  ..all angle ok
//  ndiff-ndiff 2 side ovlp < 1 + subbus ...ok  ( is this possible ?)
//
//======================================================================
//                           3.2  PDIFF            
//======================================================================
// for algorithm see ndiff
// 
// only pdiff inside well
//
   // pdiff_ntub = pdiff INSIDE routingnwell
//
// allow crossing
//
// a.) get pdiff
//
   pdiff_ntub = pdiff AND routingnwell
   pdiff_ntub_con_pad_net = NET AREA RATIO pdiff_ntub bondpad > 0
//
// pdiff on diff net
//
   pdiff_pad_fill = EXT pdiff_ntub_con_pad_net < 4.5 NOT CONNECTED REGION
// remove false error over gate pdriver
   pdiff_pad_fill11 = pdiff_pad_fill NOT INTERACT pdr_pgate_sd_padc
   pdiff_check_edge_1 = pdiff_ntub_con_pad_net COIN OUTSIDE EDGE pdiff_pad_fill11
#IFDEF debug
   pdiff_ntub_con_pad_net { COPY pdiff_ntub_con_pad_net }
   pdiff_pad_fill11 { COPY pdiff_pad_fill11 }
   pdiff_check_edge_1 { COPY pdiff_check_edge_1 }
#ENDIF
//
// b.) check, if ntap separates pdiff
// shielding by n-diffusion
// select fill polygons touching ndiff-vdd ( = welltap)
//------------------------------------------------------
   welltap_vdd  = NET AREA RATIO  welltap text_vdd > 0
//
// merge area of spacing error region and subtap
//
   pdiff_pad_fill22 = pdiff_pad_fill11 AND welltap_vdd
//
// c.) expand area of violation, do not use touch
//     to cut out this areas
//     min diff spacing 0.6, min pdiff width = 0.3
//     (4.5 - 0.3 )/2 = 2.1 
//--------------------------------------------------
// do spacing check to pdiff edge and remove edge
//
   pdiff_pad_sep = EXT pdiff_pad_fill22 pdiff_ntub_con_pad_net < 2.15 OPPOSITE PARA ONLY REGION
   pdiff_pad_edge = ( pdiff_ntub_con_pad_net INTERACT pdiff_pad_fill11) NOT COINCIDENT OUTSIDE EDGE pdiff_pad_sep 
#IFDEF debug
   pdiff_pad_sep { COPY pdiff_pad_sep }
   pdiff_pad_edge { COPY pdiff_pad_edge }
   welltap_vdd { COPY welltap_vdd }
#ENDIF
//
   xpdiff_pad_edge = pdiff_pad_edge COINCIDENT EDGE pdiff_check_edge_1
   pdiff_pad_edge_ex = xpdiff_pad_edge EXPAND EDGE INSIDE BY 0.05
#IFDEF debug
   pdiff_pad_edge_ex { COPY pdiff_pad_edge_ex }
#ENDIF
   pdiff_pad_edge_net = STAMP pdiff_pad_edge_ex BY pdiff_ntub_con_pad_net
   SPAC_PDIFF_IN_NTUB_G01DP { @ G01DP : pdiff spacing <  4.5 U 
     y = EXT pdiff_pad_edge_net  < 4.5 NOT CONNECTED REGION
     d = y NOT welltap_vdd
     d INTERACT pdiff_ntub_con_pad_net >= 2 
   }
//
//
//======================================================================
//                           3.3 DIFFCON          
//======================================================================
// already checked for elements
// current flow direction not checked
//
//======================================================================
//                           5.0 BUS RULES 
//======================================================================
// most rules are currently not checked
//
//======================================================================
//                         6.0 PERIPHERY RULES
//======================================================================
// P05G :  rblock checked
//
// INPUT PAD
//-----------
//
// OUTPUT PAD
//------------
//
// 6.5 ANALOG PAD
//----------------
// RBLOCK checked
// check for forwards and clamp diodes
//
//======================================================================
//                           5.0 BUS RULES 
//======================================================================
//
// create a new connectivity set without substrate
// cannot disconnect substrate, because of bulk of nmos device
// this connectivity can check bus rules, because gnd buses are not connected
// via substrate
//
#IFDEF fourmetal
   routingmet4_c1 = COPY routingmet4
   routingvia3_c1 = COPY routingvia3
#ENDIF
   routingmet3_c1 = COPY routingmet3
   routingmet2_c1 = COPY routingmet2
   routingmet1_c1 = COPY routingmet1
   routingvia2_c1 = COPY routingvia2
   routingvia_c1  = COPY routingvia
   ndiff_c1       = COPY ndiff
   pdiff_c1       = COPY pdiff
   subtap_c1      = COPY subtap
   ndiffcon_c1    = COPY ndiffcon
   pdiffcon_c1    = COPY pdiffcon
   text_vdd_c1    = COPY text_vdd
   text_vss_c1    = COPY text_vss
#IFDEF fourmetal
   CONNECT routingmet4_c1  routingmet3_c1    BY routingvia3_c1     
#ENDIF
   CONNECT routingmet3_c1  routingmet2_c1    BY routingvia2_c1     
   CONNECT routingmet2_c1  routingmet1_c1    BY routingvia_c1      
   CONNECT routingmet1_c1  ndiff_c1          BY ndiffcon_c1        
   CONNECT routingmet1_c1  pdiff_c1          BY pdiffcon_c1        
   CONNECT pdiff_c1  subtap_c1                                     
//
   bondpad_supply = bondpad NOT bondpad_nosupply
   CONNECT bondpad_supply routingmet2_c1
   CONNECT text_vdd_c1 bondpad_supply
   CONNECT text_vss_c1 bondpad_supply
//
// do spacing check between met3 busses different nets
// is there a snap ??
// only long busses
//
// GND busses :
//---------------
// find bus via subtap and via gnd txt
// this is necessary for chips with GND without subtap
//
   met3_subbus_subtap_c1    = NET AREA RATIO routingmet3_c1 subtap_c1 > 0
   met3_subbus_c1 = COPY met3_subbus_subtap_c1
   met3_subbus_gnd_only_c1  = NET AREA RATIO routingmet3_c1 text_vss_c1 > 0
   met3_subbus_all_c1 = met3_subbus_subtap_c1 OR met3_subbus_gnd_only_c1
// met3_subbus_c1 { COPY met3_subbus_c1 }
   met3_con_pad_c1 = NET AREA RATIO routingmet3_c1 bondpad_supply > 0
   met3_subbus_gndpad_c1 = met3_con_pad_c1 AND met3_subbus_all_c1
//
// get long edge > 300 and width > 18
//
   met3_subbus_long = met3_subbus_gndpad_c1 LENGTH > 300.0
   met3_subbus_gndpad_long_c1 = ENCLOSE RECTANGLE( met3_subbus_gndpad_c1 WITH EDGE met3_subbus_long) 18 300
   // met3_subbus_gndpad_long_c1 { FLATTEN met3_subbus_gndpad_long_c1 }
//
// does not make sense 
   //spac_met3_gnd = EXT met3_subbus_gndpad_long_c1 < 5.0 NOT CONNECTED REGION
   //MISS_SNAP_2GNDBUS_B01G { @ B01G : reverse recommended between gnd busses
   //   spac_met3_gnd NOT INTERACT snap_ndiff
   //}
//
// VDD busses : 
//--------------
   met3_nosubbus_vddtext_c1  = NET AREA RATIO routingmet3_c1 text_vdd_c1 > 0
   met3_nosubbus_vdd_c1 = met3_nosubbus_vddtext_c1 AND met3_con_pad_c1
//
// check for spacing of met3 different Power pad
// is there a snap between busses ?
//
   // met3_nosubbus_vdd_c1 { FLATTEN met3_nosubbus_vdd_c1 }
//
// get long edge > 300 and width > 18
//
   met3_nosubbus_long = met3_nosubbus_vdd_c1 LENGTH > 300.0
   met3_nosubbus_vdd_long_c1 = ENCLOSE RECTANGLE (met3_nosubbus_vdd_c1 WITH EDGE met3_nosubbus_long) 18 300
   // met3_nosubbus_vdd_long_c1 { FLATTEN met3_nosubbus_vdd_long_c1 }
   
// does not make sense 
   //spac_met3_vdd_c1 = EXT met3_nosubbus_vdd_long_c1 < 5.0 NOT CONNECTED REGION
   //MISS_SNAP_2VDDBUS_B01G { @ B01G : reverse recommended between vdd busses
   //   spac_met3_vdd_c1 NOT INTERACT snap_ndiff
   //} 
// 
   snap_ndiff_c1 = COPY snap_ndiff
   CONNECT snap_ndiff_c1 ndiffcon_c1
//
// disabled
//
   empty = AREA (EXTENT) == 0
   MISS_SNAP_GNDBUS_B01G { @ dummy check                          
      COPY empty
   }
//
   MISS_SNAP_VDDBUS_B01G { @ dummy check
      COPY empty
   }
//
#UNDEFINE SKIP
#IFDEF SKIP
//
// all snaps connected
//
   snap_fill_diffnet1 = EXT snap_ndiff_c1 < 0.7 NOT CONNECTED PARA OPPOSITE REGION
   SNAP_BUS_DIFFNET_INFO { @ INFO : snap between different busses or subbuses
       FLATTEN snap_fill_diffnet1 
   }
   snap_connected = snap_ndiff_c1 INTERACT snap_fill_diffnet1
//   
// lost net info, add again
   met3_nosubbus_vdd_long_c1_net = STAMP met3_nosubbus_vdd_long_c1 BY routingmet3_c1
// bus does not have any snap
   miss_snap_nosubbus = NET AREA RATIO met3_nosubbus_vdd_long_c1_net snap_connected == 0
   //miss_snap_nosubbus { FLATTEN miss_snap_nosubbus }
   MISS_SNAP_VDDBUS_B01G { @ B01G : no snap on this vdd bus found
      FLATTEN miss_snap_nosubbus
   }
//
// lost net info, add again
//
   met3_subbus_gndpad_long_c1_net = STAMP met3_subbus_gndpad_long_c1 BY routingmet3_c1
//
// subbus does not have any snap
//
   miss_snap_subbus = NET AREA RATIO met3_subbus_gndpad_long_c1_net snap_connected ==  0
   // miss_snap_subbus { FLATTEN miss_snap_subbus }
   MISS_SNAP_GNDBUS_B01G { @ B01G : no snap on this gnd bus found
      FLATTEN miss_snap_subbus
   }
#ENDIF
//
///////////////////////////////////////////////////////////////////////
//
//           end of standard CALIBRE technology file 
//
///////////////////////////////////////////////////////////////////////
//
//
//
///////////////////////////////////////////////////////////////////////
//
//                       BUS WIDTH CHECKS            
//
///////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////
//
//  check bus width from vdd forward diode to vdd pad  and vss forward 
//                   diode to vss pad
//
///////////////////////////////////////////////////////////////////////
//
//  n diode : kathode ndiff, anode pdiff
//            ndiff is substrate, pdiff subtap
//
    //nd_diode_body = EXT nd_diode_pdiff nd_diode_ndiff == 0.6 OPPOSITE PARA ONLY REGION
    nd_diode_body_all = EXT nd_diode_pdiff nd_diode_ndiff < 1.1  OPPOSITE PARA ONLY REGION
//
// only large diodes
//
    nd_diode_body_diffedge = nd_diode_body_all COINCIDENT OUTSIDE EDGE nd_diode_ndiff
    nd_diode_body_diffedge_length = LENGTH  nd_diode_body_diffedge > 15
    nd_diode_body_ok = nd_diode_body_all WITH EDGE  nd_diode_body_diffedge_length
//
    n_diode_a = nd_diode_pdiff TOUCH nd_diode_body_ok
    n_diode_k = nd_diode_ndiff TOUCH nd_diode_body_ok
//
#UNDEFINE BUSDEBUG
#IFDEF BUSDEBUG
    n_diode_a { FLATTEN n_diode_a }
    n_diode_k { FLATTEN n_diode_k }
#ENDIF
//
//-------------------------------------------------------------------------------
//
// p diode : kathode pdiff in ntub, anode ndiff connecting ntub
//
    //pd_diode_body = EXT pd_diode_pdiff pd_diode_ndiff == 0.6 OPPOSITE PARA ONLY REGION
    pd_diode_body_all = EXT pd_diode_pdiff pd_diode_ndiff < 1.1  OPPOSITE PARA ONLY REGION
//
    pd_diode_body_diffedge = pd_diode_body_all COINCIDENT OUTSIDE EDGE pd_diode_ndiff
    pd_diode_body_diffedge_length = LENGTH  pd_diode_body_diffedge > 15
    pd_diode_body_ok = pd_diode_body_all WITH EDGE  pd_diode_body_diffedge_length
//
    p_diode_a = pd_diode_pdiff TOUCH pd_diode_body_ok
    p_diode_k = pd_diode_ndiff TOUCH pd_diode_body_ok
//
#IFDEF BUSDEBUG
    p_diode_a { FLATTEN p_diode_a }
    p_diode_k { FLATTEN p_diode_k }
#ENDIF
//
///////////////////////////////////////////////////////////////////////
//  diode connections check
///////////////////////////////////////////////////////////////////////
//
//CONNECT routingmet1_c1  ndiff_c1          BY ndiffcon_c1        
//CONNECT routingmet1_c1  pdiff_c1          BY pdiffcon_c1        
//
// does bondpad see a p diode
//
   p_diode_a_net = STAMP  p_diode_a BY  pdiff_c1
   p_diode_k_net = STAMP  p_diode_k BY  ndiff_c1
//
   n_diode_a_net = STAMP  n_diode_a BY  pdiff_c1
   n_diode_k_net = STAMP  n_diode_k BY  ndiff_c1
//
   bondpad_nosupply_net = STAMP bondpad_nosupply BY  routingmet2_c1
//
// search anode of p diode on io side
//--------------------------------------------
//
   pdiode_a_iopadside = NET AREA RATIO  p_diode_a_net bondpad_nosupply_net > 0 
#IFDEF BUSDEBUG
   pdiode_a_iopadside { FLATTEN pdiode_a_iopadside }
#ENDIF
   ESDPATH_IOPAD_MISS_VDD_PFORWARD {@ IO cell does not have path to VDD  P forward diode
       x = NET AREA RATIO bondpad_nosupply_net p_diode_a_net == 0
       FLATTEN x
   }
//
// search kathode of n diode on io side
//--------------------------------------------
//
   ndiode_k_iopadside = NET AREA RATIO  n_diode_k_net bondpad_nosupply_net > 0 
#IFDEF BUSDEBUG
   ndiode_k_iopadside { FLATTEN ndiode_k_iopadside }
#ENDIF
   ESDPATH_IOPAD_MISS_VSS_NFORWARD {@ IO cell does not have path to VSS N forward diode
       x = NET AREA RATIO bondpad_nosupply_net n_diode_k_net == 0
       FLATTEN x
   }
//
// search anode of p diode on ivdd pad side
//--------------------------------------------
//   GNDPAD_INFO { @ INFO : GND pad
//    FLATTEN ( met1_subbus_gndpad AND bondpad )
//   }
//   VDDPAD_INFO { @ INFO : VDD pad
//    FLATTEN ( met1_nosubbus_vddtext AND bondpad )
//   }
   bondpad_gnd = met1_subbus_gndpad    AND bondpad 
#IFDEF BUSDEBUG
   bondpad_gnd { COPY bondpad_gnd }
#ENDIF
//
   bondpad_vdd = met1_nosubbus_vddtext AND bondpad 
#IFDEF BUSDEBUG
   bondpad_vdd { COPY bondpad_vdd }
#ENDIF
//
   bondpad_vdd_net = STAMP bondpad_vdd BY routingmet2_c1
   bondpad_gnd_net = STAMP bondpad_gnd BY routingmet2_c1
//
// trace to terminal and check to vdd
//-------------------------------------
//
   pdiode_k_vddpadside = p_diode_k_net TOUCH ( pd_diode_body_ok TOUCH  pdiode_a_iopadside)
#IFDEF BUSDEBUG
   pdiode_k_vddpadside { FLATTEN pdiode_k_vddpadside }
#ENDIF
//
// connected ?
//
   pdiode_k_vddpadside_pathvdd = NET AREA RATIO pdiode_k_vddpadside bondpad_vdd_net > 0 
   ESDPATH_IOPAD_VDDFORWARD_INFO {@ VDD FORWARD connected to vdd pad found 
       FLATTEN pdiode_k_vddpadside_pathvdd 
   }
//
#IFDEF BUSDEBUG
   pdiode_k_vddpadside_pathvdd { FLATTEN  pdiode_k_vddpadside_pathvdd }
#ENDIF
//
   ESDPATH_IOPAD_VDD_PFORWARD_NOPATHVDD {@ P forward diode connected to IO cell does not have path to VDD pad
                                         @  on cathode side
       x = NET AREA RATIO pdiode_k_vddpadside bondpad_vdd_net == 0 
       FLATTEN x
   }
//
// trace to terminal and check to gnd
//-------------------------------------
//
   ndiode_a_gndpadside = n_diode_a_net TOUCH ( nd_diode_body_ok TOUCH  ndiode_k_iopadside)
#IFDEF BUSDEBUG
   ndiode_a_gndpadside { FLATTEN ndiode_a_gndpadside }
#ENDIF
//
// connected ?
//
   ndiode_a_gndpadside_pathgnd = NET AREA RATIO ndiode_a_gndpadside bondpad_gnd_net > 0 
   ESDPATH_IOPAD_VSSFORWARD_INFO {@ VSS FORWARD connected to vss pad found 
         FLATTEN  ndiode_a_gndpadside_pathgnd
   }
#IFDEF BUSDEBUG
    ndiode_a_gndpadside_pathgnd { FLATTEN  ndiode_a_gndpadside_pathgnd }
#ENDIF
//
   ESDPATH_IOPAD_VSS_NFORWARD_NOPATHVSS {@  N forward diode connected to IO cell does not have path to VSS pad
                                         @  on anode side
       x = NET AREA RATIO ndiode_a_gndpadside bondpad_gnd_net == 0
       FLATTEN x
   }
///////////////////////////////////////////////////////////////////////
//
//  check bus width from gc_pmos source to vdd pad and gc_nmos source to
//                           vss pad
//
///////////////////////////////////////////////////////////////////////
//
//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
// check path to VSS
// nmos and nmosm !!
   gc_nmos_ndr_ndiff_source =  ndr_ndiff_source TOUCH  ndr_ngate_prot
//
//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
// pmos and pmosm !!
   gc_pmos_pdr_pdiff_source =  pdr_pdiff_source TOUCH  pdr_pgate_prot
//
#IFDEF BUSDEBUG
// debug more
//
   ndr_ndiff_source { FLATTEN ndr_ndiff_source }
   pdr_pdiff_source { FLATTEN pdr_pdiff_source }
//
   gc_nmos_ndr_ngate_prot { FLATTEN  gc_nmos_ndr_ngate_prot }
   gc_nmosm_ndr_ngate_prot { FLATTEN  gc_nmosm_ndr_ngate_prot }
//
   gc_pmos_pdr_pgate_prot { FLATTEN  gc_pmos_pdr_pgate_prot }
   gc_pmosm_pdr_pgate_prot { FLATTEN  gc_pmosm_pdr_pgate_prot }
//
   pdr_pgate_prot { FLATTEN pdr_pgate_prot }
   ndr_ngate_prot { FLATTEN ndr_ngate_prot }
//
   gc_pmos_pdr_pdiff_source { FLATTEN gc_pmos_pdr_pdiff_source }
   gc_nmos_ndr_ndiff_source { FLATTEN gc_nmos_ndr_ndiff_source }
#ENDIF
//
//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
   gc_pmos_pdr_pdiff_source_net = STAMP gc_pmos_pdr_pdiff_source BY pdiff_c1
   gc_pmos_vddpadside_pathvdd = NET AREA RATIO  gc_pmos_pdr_pdiff_source_net  bondpad_vdd_net > 0
   ESDPATH_IOPAD_VDDGCPMOS_INFO {@ VDD GC_PMOS connected to vdd pad found
       FLATTEN  gc_pmos_vddpadside_pathvdd
   }
//
#IFDEF BUSDEBUG
   bondpad_vdd_net { COPY  bondpad_vdd_net }
#ENDIF
//   ESDPATH_IOPAD_GC_PMOS_NOPATHVDD {@ GC_PMOS connected to IO cell does not have path to VDD pad
//       x = NET AREA RATIO  gc_pmos_pdr_pdiff_source_net  bondpad_vdd_net == 0
//       FLATTEN x
//   }
//
//============
//
   gc_nmos_ndr_ndiff_source_net = STAMP gc_nmos_ndr_ndiff_source BY ndiff_c1
   gc_nmos_gndpadside_pathgnd = NET AREA RATIO  gc_nmos_ndr_ndiff_source_net  bondpad_gnd_net > 0
   ESDPATH_IOPAD_VSSGCNMOS_INFO {@ VSS GC_NMOS connected to gnd pad found
       FLATTEN  gc_nmos_gndpadside_pathgnd
   }
//
#IFDEF BUSDEBUG
   bondpad_gnd_net { COPY  bondpad_gnd_net }
#ENDIF
//   ESDPATH_IOPAD_GC_NMOS_NOPATHGND {@ GC_NMOS connected to IO cell does not have path to GND pad
//       x = NET AREA RATIO  gc_nmos_ndr_ndiff_source_net  bondpad_gnd_net == 0
//       FLATTEN x
//   }
//
// above check does not work if terminal not found
// no error if no path to supply pad
// because gc_nmos_ndr_ndiff_source_net is already selected by not to supply
// and is empty
//
// add this check to make sure driver has connection to vdd or gnd pad
//------------------------------------------------------------------------
//
   ndr_ndiff_source_net = STAMP ndr_ndiff_source BY ndiff_c1
   ESDPATH_IOPAD_NDRIVER_NOPATHGND {@ NDRIVER NMOS connected to IO cell does not have path to GND pad
      x =  NET AREA RATIO  ndr_ndiff_source_net  bondpad_gnd_net == 0
      FLATTEN x 
   }
// gc_nmos and gc_nmosm
   ESDPATH_IOPAD_GC_NMOS_NOPATHGND {@ GC_NMOS connected to IO cell does not have path to GND pad
      x =  NET AREA RATIO  ndr_ndiff_source_net  bondpad_gnd_net == 0
      FLATTEN (x TOUCH (gc_nmos_ndr_ngate_prot OR gc_nmosm_ndr_ngate_prot))
   }
//
   pdr_pdiff_source_net = STAMP pdr_pdiff_source BY pdiff_c1
   ESDPATH_IOPAD_PDRIVER_NOPATHVDD {@ PDRIVER PMOS connected to IO cell does not have path to VDD pad
       y =  NET AREA RATIO  pdr_pdiff_source_net  bondpad_vdd_net == 0
       FLATTEN y
   }
// gc_pmos and gc_pmosm
   ESDPATH_IOPAD_GC_PMOS_NOPATHVDD {@ GC_PMOS connected to IO cell does not have path to VDD pad
       y =  NET AREA RATIO  pdr_pdiff_source_net  bondpad_vdd_net == 0
       FLATTEN (y TOUCH (gc_pmos_pdr_pgate_prot OR gc_pmosm_pdr_pgate_prot))
   }
//
///////////////////////////////////////////////////////////////////////
//
//  check with of met2/met3/met4 bus metal for pathes from Forward diode
//  to vdd/gnd pad
//
///////////////////////////////////////////////////////////////////////
//
#DEFINE BUS_METAL_WITH_CHECK
#IFDEF BUS_METAL_WITH_CHECK
//
// trace metal first and then close holes
//
// pdiode_a_iopadside = NET AREA RATIO  p_diode_a_net bondpad_nosupply_net > 0 
//
// all checks concurrent
//
//-----------------------------------------------------------------------------------
// extract parts of met1/2/3/4  connected to diodes
//-----------------------------------------------------------------------------------
//-------------------------------------------------------------------
// get all parts of net connected to p diode anode on iopad side
//-------------------------------------------------------------------
//
   met4_pdiode_a_iopadside = NET AREA RATIO routingmet4_c1 routingmet3_c1 routingmet2_c1 routingmet1_c1 pdiode_a_iopadside > 0 
   met3_pdiode_a_iopadside = NET AREA RATIO routingmet3_c1 routingmet4_c1 routingmet2_c1 routingmet1_c1 pdiode_a_iopadside > 0 
   met2_pdiode_a_iopadside = NET AREA RATIO routingmet2_c1 routingmet1_c1 routingmet3_c1 routingmet4_c1 pdiode_a_iopadside > 0
   met1_pdiode_a_iopadside = NET AREA RATIO routingmet1_c1 routingmet2_c1 routingmet3_c1 routingmet4_c1 pdiode_a_iopadside > 0
//
   via3_pdiode_a_iopadside = NET AREA RATIO routingvia3_c1 routingvia2_c1 routingvia_c1 pdiffcon_c1 pdiode_a_iopadside > 0
   via2_pdiode_a_iopadside = NET AREA RATIO routingvia2_c1 routingvia3_c1 routingvia_c1 pdiffcon_c1 pdiode_a_iopadside > 0
   via_pdiode_a_iopadside  = NET AREA RATIO routingvia_c1 routingvia2_c1 routingvia3_c1 pdiffcon_c1 pdiode_a_iopadside > 0
   pdiffcon_pdiode_a_iopadside = NET AREA RATIO pdiffcon_c1 routingvia3_c1 routingvia2_c1 routingvia_c1 pdiode_a_iopadside > 0
//
#UNDEFINE BUSWIDTHDEBUG
#IFDEF BUSWIDTHDEBUG
   met1_pdiode_a_iopadside { FLATTEN  met1_pdiode_a_iopadside }
   met2_pdiode_a_iopadside { FLATTEN  met2_pdiode_a_iopadside }
   met3_pdiode_a_iopadside { FLATTEN  met3_pdiode_a_iopadside }
   met4_pdiode_a_iopadside { FLATTEN  met4_pdiode_a_iopadside }
   via3_pdiode_a_iopadside { FLATTEN  via3_pdiode_a_iopadside }
   via2_pdiode_a_iopadside { FLATTEN  via2_pdiode_a_iopadside }
   via_pdiode_a_iopadside  { FLATTEN  via_pdiode_a_iopadside }
   pdiffcon_pdiode_a_iopadside { FLATTEN  pdiffcon_pdiode_a_iopadside }
#ENDIF
//
// overlapping areas
//
   met1_pdiff_pdiode_a_iopadside     = met1_pdiode_a_iopadside AND pdiode_a_iopadside
   met1_met2_via_pdiode_a_iopadside  = (met1_pdiode_a_iopadside AND met2_pdiode_a_iopadside ) ENCLOSE via_pdiode_a_iopadside
   met2_met3_via2_pdiode_a_iopadside = (met2_pdiode_a_iopadside AND met3_pdiode_a_iopadside ) ENCLOSE via2_pdiode_a_iopadside
   met3_met4_via3_pdiode_a_iopadside = (met3_pdiode_a_iopadside AND met4_pdiode_a_iopadside ) ENCLOSE via3_pdiode_a_iopadside
//
//-------------------------------------------------------------------
// get all parts of net connected to n diode cathode on iopad side
//-------------------------------------------------------------------
//
   met4_ndiode_k_iopadside = NET AREA RATIO routingmet4_c1 routingmet3_c1 routingmet2_c1 routingmet1_c1 ndiode_k_iopadside > 0 
   met3_ndiode_k_iopadside = NET AREA RATIO routingmet3_c1 routingmet4_c1 routingmet2_c1 routingmet1_c1 ndiode_k_iopadside > 0 
   met2_ndiode_k_iopadside = NET AREA RATIO routingmet2_c1 routingmet1_c1 routingmet3_c1 routingmet4_c1 ndiode_k_iopadside > 0
   met1_ndiode_k_iopadside = NET AREA RATIO routingmet1_c1 routingmet2_c1 routingmet3_c1 routingmet4_c1 ndiode_k_iopadside > 0
//
   via3_ndiode_k_iopadside = NET AREA RATIO routingvia3_c1 routingvia2_c1 routingvia_c1 ndiffcon_c1 ndiode_k_iopadside > 0
   via2_ndiode_k_iopadside = NET AREA RATIO routingvia2_c1 routingvia3_c1 routingvia_c1 ndiffcon_c1 ndiode_k_iopadside > 0
   via_ndiode_k_iopadside  = NET AREA RATIO routingvia_c1 routingvia2_c1 routingvia3_c1 ndiffcon_c1 ndiode_k_iopadside > 0
   ndiffcon_ndiode_k_iopadside = NET AREA RATIO ndiffcon_c1 routingvia3_c1 routingvia2_c1 routingvia_c1 ndiode_k_iopadside > 0
//
// not used on pad side
//
// overlapping areas
//
//   met1_ndiff_ndiode_k_iopadside     = met1_ndiode_k_iopadside AND ndiode_k_iopadside
//   met1_met2_via_ndiode_k_iopadside  = (met1_ndiode_k_iopadside AND met2_ndiode_k_iopadside ) ENCLOSE via_ndiode_k_iopadside
//   met2_met3_via2_ndiode_k_iopadside = (met2_ndiode_k_iopadside AND met3_ndiode_k_iopadside ) ENCLOSE via2_ndiode_k_iopadside
//   met3_met4_via3_ndiode_k_iopadside = (met3_ndiode_k_iopadside AND met4_ndiode_k_iopadside ) ENCLOSE via3_ndiode_k_iopadside
//
//   met1_ndiff_ndiode_k_iopadside { FLATTEN  met1_ndiff_ndiode_k_iopadside }
//   met1_met2_via_ndiode_k_iopadside { FLATTEN  met1_met2_via_ndiode_k_iopadside }
//   met2_met3_via2_ndiode_k_iopadside { FLATTEN met2_met3_via2_ndiode_k_iopadside }
//   met3_met4_via3_ndiode_k_iopadside { FLATTEN  met3_met4_via3_ndiode_k_iopadside }
//
#IFDEF BUSWIDTHDEBUG
   met1_ndiode_k_iopadside { FLATTEN  met1_ndiode_k_iopadside }
   met2_ndiode_k_iopadside { FLATTEN  met2_ndiode_k_iopadside }
   met3_ndiode_k_iopadside { FLATTEN  met3_ndiode_k_iopadside }
   met4_ndiode_k_iopadside { FLATTEN  met4_ndiode_k_iopadside }
#ENDIF
// 
//==============================================================================
//
//    get all parts of net connected to p diode cathode on vdd pad side
//
//==============================================================================
// check for width of met on path
//
// path to vddpad must exits, already checked
// get all metal connected to correct diode
//
   met4_pdiode_k_vddpadside = NET AREA RATIO routingmet4_c1 routingmet3_c1 routingmet2_c1 routingmet1_c1 pdiode_k_vddpadside_pathvdd > 0 
   met3_pdiode_k_vddpadside = NET AREA RATIO routingmet3_c1 routingmet4_c1 routingmet2_c1 routingmet1_c1 pdiode_k_vddpadside_pathvdd > 0 
   met2_pdiode_k_vddpadside = NET AREA RATIO routingmet2_c1 routingmet1_c1 routingmet3_c1 routingmet4_c1 pdiode_k_vddpadside_pathvdd > 0
   met1_pdiode_k_vddpadside = NET AREA RATIO routingmet1_c1 routingmet2_c1 routingmet3_c1 routingmet4_c1 pdiode_k_vddpadside_pathvdd > 0
//
   via3_pdiode_k_vddpadside = NET AREA RATIO routingvia3_c1 routingvia2_c1 routingvia_c1 ndiffcon_c1 pdiode_k_vddpadside_pathvdd > 0
   via2_pdiode_k_vddpadside = NET AREA RATIO routingvia2_c1 routingvia3_c1 routingvia_c1 ndiffcon_c1 pdiode_k_vddpadside_pathvdd > 0
   via_pdiode_k_vddpadside  = NET AREA RATIO routingvia_c1 routingvia2_c1 routingvia3_c1 ndiffcon_c1 pdiode_k_vddpadside_pathvdd > 0
   ndiffcon_pdiode_k_vddpadside = NET AREA RATIO ndiffcon_c1 routingvia3_c1 routingvia2_c1 routingvia_c1 pdiode_k_vddpadside_pathvdd > 0
//
// overlapping areas
//
   met1_pdiff_pdiode_k_vddpadside     = met1_pdiode_k_vddpadside AND pdiode_k_vddpadside
   met1_met2_via_pdiode_k_vddpadside  = (met1_pdiode_k_vddpadside AND met2_pdiode_k_vddpadside ) ENCLOSE via_pdiode_k_vddpadside
   met2_met3_via2_pdiode_k_vddpadside = (met2_pdiode_k_vddpadside AND met3_pdiode_k_vddpadside ) ENCLOSE via2_pdiode_k_vddpadside
   met3_met4_via3_pdiode_k_vddpadside = (met3_pdiode_k_vddpadside AND met4_pdiode_k_vddpadside ) ENCLOSE via3_pdiode_k_vddpadside
//
#IFDEF BUSWIDTHDEBUG
   met1_pdiode_k_vddpadside  { FLATTEN  met1_pdiode_k_vddpadside }
   met2_pdiode_k_vddpadside { FLATTEN  met2_pdiode_k_vddpadside }
   met3_pdiode_k_vddpadside { FLATTEN  met3_pdiode_k_vddpadside }
   met4_pdiode_k_vddpadside { FLATTEN  met4_pdiode_k_vddpadside }
   met1_pdiff_pdiode_k_vddpadside { FLATTEN  met1_pdiff_pdiode_k_vddpadside }
   met1_met2_via_pdiode_k_vddpadside { FLATTEN  met1_met2_via_pdiode_k_vddpadside }
   met2_met3_via2_pdiode_k_vddpadside { FLATTEN met2_met3_via2_pdiode_k_vddpadside }
   met3_met4_via3_pdiode_k_vddpadside { FLATTEN  met3_met4_via3_pdiode_k_vddpadside }
#ENDIF
//
//==============================================================================
//
//    get all parts of net connected to n diode anode  on gnd pad side
//
//==============================================================================
// check for width of met on path
//
// path to gndpad must exits, already checked
// get all metal connected to correct diode
//
   met4_ndiode_a_gndpadside = NET AREA RATIO routingmet4_c1 routingmet3_c1 routingmet2_c1 routingmet1_c1 ndiode_a_gndpadside_pathgnd > 0
   met3_ndiode_a_gndpadside = NET AREA RATIO routingmet3_c1 routingmet4_c1 routingmet2_c1 routingmet1_c1 ndiode_a_gndpadside_pathgnd > 0
   met2_ndiode_a_gndpadside = NET AREA RATIO routingmet2_c1 routingmet1_c1 routingmet3_c1 routingmet4_c1 ndiode_a_gndpadside_pathgnd > 0
   met1_ndiode_a_gndpadside = NET AREA RATIO routingmet1_c1 routingmet2_c1 routingmet3_c1 routingmet4_c1 ndiode_a_gndpadside_pathgnd > 0
//
   via3_ndiode_a_gndpadside = NET AREA RATIO routingvia3_c1 routingvia2_c1 routingvia_c1 pdiffcon_c1 ndiode_a_gndpadside_pathgnd > 0
   via2_ndiode_a_gndpadside = NET AREA RATIO routingvia2_c1 routingvia3_c1 routingvia_c1 pdiffcon_c1 ndiode_a_gndpadside_pathgnd > 0
   via_ndiode_a_gndpadside  = NET AREA RATIO routingvia_c1 routingvia2_c1 routingvia3_c1 pdiffcon_c1 ndiode_a_gndpadside_pathgnd > 0
   pdiffcon_ndiode_a_gndpadside = NET AREA RATIO pdiffcon_c1 routingvia3_c1 routingvia2_c1 routingvia_c1 ndiode_a_gndpadside_pathgnd > 0
//
// overlapping areas
//
   met1_pdiff_ndiode_a_gndpadside     = met1_ndiode_a_gndpadside AND ndiode_a_gndpadside
   met1_met2_via_ndiode_a_gndpadside  = (met1_ndiode_a_gndpadside AND met2_ndiode_a_gndpadside ) ENCLOSE via_ndiode_a_gndpadside
   met2_met3_via2_ndiode_a_gndpadside = (met2_ndiode_a_gndpadside AND met3_ndiode_a_gndpadside ) ENCLOSE via2_ndiode_a_gndpadside
   met3_met4_via3_ndiode_a_gndpadside = (met3_ndiode_a_gndpadside AND met4_ndiode_a_gndpadside ) ENCLOSE via3_ndiode_a_gndpadside
//
#UNDEFINE GCBUSWIDTHDEBUG
#IFDEF GCBUSWIDTHDEBUG
   met1_ndiode_a_gndpadside  { FLATTEN  met1_ndiode_a_gndpadside }
   met2_ndiode_a_gndpadside { FLATTEN  met2_ndiode_a_gndpadside }
   met3_ndiode_a_gndpadside { FLATTEN  met3_ndiode_a_gndpadside }
   met4_ndiode_a_gndpadside { FLATTEN  met4_ndiode_a_gndpadside }
   met1_pdiff_ndiode_a_gndpadside { FLATTEN  met1_pdiff_ndiode_a_gndpadside }
   met1_met2_via_ndiode_a_gndpadside { FLATTEN  met1_met2_via_ndiode_a_gndpadside }
   met2_met3_via2_ndiode_a_gndpadside { FLATTEN met2_met3_via2_ndiode_a_gndpadside }
   met3_met4_via3_ndiode_a_gndpadside { FLATTEN  met3_met4_via3_ndiode_a_gndpadside }
#ENDIF
//
#IFDEF GET_MET_DI_PATH
//
// attention : only output if path from diode to pad found !!!!
// no output if not !!!!
// is existing net, no undersize, any width
//
   met1_ndiode_a_gndpadside  { FLATTEN  met1_ndiode_a_gndpadside }
   met2_ndiode_a_gndpadside { FLATTEN  met2_ndiode_a_gndpadside }
   met3_ndiode_a_gndpadside { FLATTEN  met3_ndiode_a_gndpadside }
   met4_ndiode_a_gndpadside { FLATTEN  met4_ndiode_a_gndpadside }
//
   met1_pdiode_k_vddpadside  { FLATTEN  met1_pdiode_k_vddpadside }
   met2_pdiode_k_vddpadside { FLATTEN  met2_pdiode_k_vddpadside }
   met3_pdiode_k_vddpadside { FLATTEN  met3_pdiode_k_vddpadside }
   met4_pdiode_k_vddpadside { FLATTEN  met4_pdiode_k_vddpadside }
#ENDIF
//
//==============================================================================
//
//    get all parts of net connected to gc_pmos drain on vdd pad side
//    this is the path to vdd pad
//
//==============================================================================
//
// path to vddpad must exits, already checked
//
   gcpmos_s_vddpadside = COPY  gc_pmos_pdr_pdiff_source_net
//
   met4_gcpmos_s_vddpadside = NET AREA RATIO routingmet4_c1 routingmet3_c1 routingmet2_c1 routingmet1_c1 gcpmos_s_vddpadside > 0
   met3_gcpmos_s_vddpadside = NET AREA RATIO routingmet3_c1 routingmet4_c1 routingmet2_c1 routingmet1_c1 gcpmos_s_vddpadside > 0
   met2_gcpmos_s_vddpadside = NET AREA RATIO routingmet2_c1 routingmet1_c1 routingmet3_c1 routingmet4_c1 gcpmos_s_vddpadside > 0
   met1_gcpmos_s_vddpadside = NET AREA RATIO routingmet1_c1 routingmet2_c1 routingmet3_c1 routingmet4_c1 gcpmos_s_vddpadside > 0
//
   via3_gcpmos_s_vddpadside = NET AREA RATIO routingvia3_c1 routingvia2_c1 routingvia_c1 ndiffcon_c1 gcpmos_s_vddpadside > 0
   via2_gcpmos_s_vddpadside = NET AREA RATIO routingvia2_c1 routingvia3_c1 routingvia_c1 ndiffcon_c1 gcpmos_s_vddpadside > 0
   via_gcpmos_s_vddpadside  = NET AREA RATIO routingvia_c1 routingvia2_c1 routingvia3_c1 ndiffcon_c1 gcpmos_s_vddpadside > 0
   pdiffcon_gcpmos_s_vddpadside = NET AREA RATIO pdiffcon_c1 routingvia3_c1 routingvia2_c1 routingvia_c1 gcpmos_s_vddpadside > 0
//
// overlapping areas
//
   met1_pdiff_gcpmos_s_vddpadside     = met1_gcpmos_s_vddpadside AND gcpmos_s_vddpadside
   met1_met2_via_gcpmos_s_vddpadside  = (met1_gcpmos_s_vddpadside AND met2_gcpmos_s_vddpadside ) ENCLOSE via_gcpmos_s_vddpadside
   met2_met3_via2_gcpmos_s_vddpadside = (met2_gcpmos_s_vddpadside AND met3_gcpmos_s_vddpadside ) ENCLOSE via2_gcpmos_s_vddpadside
   met3_met4_via3_gcpmos_s_vddpadside = (met3_gcpmos_s_vddpadside AND met4_gcpmos_s_vddpadside ) ENCLOSE via3_gcpmos_s_vddpadside
//
#IFDEF GCBUSWIDTHDEBUG
   met1_gcpmos_s_vddpadside  { FLATTEN  met1_gcpmos_s_vddpadside }
   met2_gcpmos_s_vddpadside { FLATTEN  met2_gcpmos_s_vddpadside }
   met3_gcpmos_s_vddpadside { FLATTEN  met3_gcpmos_s_vddpadside }
   met4_gcpmos_s_vddpadside { FLATTEN  met4_gcpmos_s_vddpadside }
   met1_pdiff_gcpmos_s_vddpadside { FLATTEN  met1_pdiff_gcpmos_s_vddpadside }
   met1_met2_via_gcpmos_s_vddpadside { FLATTEN  met1_met2_via_gcpmos_s_vddpadside }
   met2_met3_via2_gcpmos_s_vddpadside { FLATTEN met2_met3_via2_gcpmos_s_vddpadside }
   met3_met4_via3_gcpmos_s_vddpadside { FLATTEN  met3_met4_via3_gcpmos_s_vddpadside }
#ENDIF

//==============================================================================
//
//    get all parts of net connected to gc_nmos drain on gnd pad side
//    this is the path to gnd pad
//
//==============================================================================
//
// path to gndpad must exits, already checked
//
   gcnmos_s_gndpadside = COPY  gc_nmos_ndr_ndiff_source_net
//
   met4_gcnmos_s_gndpadside = NET AREA RATIO routingmet4_c1 routingmet3_c1 routingmet2_c1 routingmet1_c1 gcnmos_s_gndpadside > 0
   met3_gcnmos_s_gndpadside = NET AREA RATIO routingmet3_c1 routingmet4_c1 routingmet2_c1 routingmet1_c1 gcnmos_s_gndpadside > 0
   met2_gcnmos_s_gndpadside = NET AREA RATIO routingmet2_c1 routingmet1_c1 routingmet3_c1 routingmet4_c1 gcnmos_s_gndpadside > 0
   met1_gcnmos_s_gndpadside = NET AREA RATIO routingmet1_c1 routingmet2_c1 routingmet3_c1 routingmet4_c1 gcnmos_s_gndpadside > 0
//
   via3_gcnmos_s_gndpadside = NET AREA RATIO routingvia3_c1 routingvia2_c1 routingvia_c1 ndiffcon_c1 gcnmos_s_gndpadside > 0
   via2_gcnmos_s_gndpadside = NET AREA RATIO routingvia2_c1 routingvia3_c1 routingvia_c1 ndiffcon_c1 gcnmos_s_gndpadside > 0
   via_gcnmos_s_gndpadside  = NET AREA RATIO routingvia_c1 routingvia2_c1 routingvia3_c1 ndiffcon_c1 gcnmos_s_gndpadside > 0
   ndiffcon_gcnmos_s_gndpadside = NET AREA RATIO ndiffcon_c1 routingvia3_c1 routingvia2_c1 routingvia_c1 gcnmos_s_gndpadside > 0
//
// overlapping areas
//
   met1_ndiff_gcnmos_s_gndpadside     = met1_gcnmos_s_gndpadside AND gcnmos_s_gndpadside
   met1_met2_via_gcnmos_s_gndpadside  = (met1_gcnmos_s_gndpadside AND met2_gcnmos_s_gndpadside ) ENCLOSE via_gcnmos_s_gndpadside
   met2_met3_via2_gcnmos_s_gndpadside = (met2_gcnmos_s_gndpadside AND met3_gcnmos_s_gndpadside ) ENCLOSE via2_gcnmos_s_gndpadside
   met3_met4_via3_gcnmos_s_gndpadside = (met3_gcnmos_s_gndpadside AND met4_gcnmos_s_gndpadside ) ENCLOSE via3_gcnmos_s_gndpadside
//
#IFDEF GCBUSWIDTHDEBUG
   met1_gcnmos_s_gndpadside  { FLATTEN  met1_gcnmos_s_gndpadside }
   met2_gcnmos_s_gndpadside { FLATTEN  met2_gcnmos_s_gndpadside }
   met3_gcnmos_s_gndpadside { FLATTEN  met3_gcnmos_s_gndpadside }
   met4_gcnmos_s_gndpadside { FLATTEN  met4_gcnmos_s_gndpadside }
   met1_ndiff_gcnmos_s_gndpadside { FLATTEN  met1_ndiff_gcnmos_s_gndpadside }
   met1_met2_via_gcnmos_s_gndpadside { FLATTEN  met1_met2_via_gcnmos_s_gndpadside }
   met2_met3_via2_gcnmos_s_gndpadside { FLATTEN met2_met3_via2_gcnmos_s_gndpadside }
   met3_met4_via3_gcnmos_s_gndpadside { FLATTEN  met3_met4_via3_gcnmos_s_gndpadside }
#ENDIF
//
///////////////////////////////////////////////////////////////////////
//
//  check with of met2/met3/met4 bus metal for pathes from Forward diode
//  to vdd/gnd pad
//
///////////////////////////////////////////////////////////////////////
//
// debug
//
#IFDEF GET_MET_GC_PATH
   met1_gcnmos_s_gndpadside  { FLATTEN  met1_gcnmos_s_gndpadside }
   met2_gcnmos_s_gndpadside { FLATTEN  met2_gcnmos_s_gndpadside }
   met3_gcnmos_s_gndpadside { FLATTEN  met3_gcnmos_s_gndpadside }
   met4_gcnmos_s_gndpadside { FLATTEN  met4_gcnmos_s_gndpadside }
//
   met1_gcpmos_s_vddpadside  { FLATTEN  met1_gcpmos_s_vddpadside }
   met2_gcpmos_s_vddpadside { FLATTEN  met2_gcpmos_s_vddpadside }
   met3_gcpmos_s_vddpadside { FLATTEN  met3_gcpmos_s_vddpadside }
   met4_gcpmos_s_vddpadside { FLATTEN  met4_gcpmos_s_vddpadside }
#ENDIF
//
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
//                   process path vdd forward to vdd pad  m3
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
//
// Fixed slot width = 3.0 3.0
//
//   WIDTH_M1SLOT_AMW1 { @ AMW1 metal1 Fixed slot width = 3.0
//   WIDTH_M2SLOT_AMW1 { @ AMW1 metal2 Fixed slot width = 3.0
//   WIDTH_M3SLOT_AMW1 { @ AMW1 metal3 Fixed slot width = 3.0
//   WIDTH_M4SLOT_AMW1 { @ AMW1 metal4 Fixed slot width = 3.0
//
   m3_pd_k_vdd_m234ovlp = met2_met3_via2_pdiode_k_vddpadside OR met3_met4_via3_pdiode_k_vddpadside
   m3_pd_k_vdd_x = COPY met3_pdiode_k_vddpadside
//
// close slots 
//
   m3_pd_k_vdd_x1_holes = HOLES  m3_pd_k_vdd_x INNER < 1000.0  // max slot 300 * 3 U
   m3_pd_k_vdd_x1_holes_width = INT  m3_pd_k_vdd_x1_holes <= 4.0 REGION
   m3_pd_k_vdd_0 = m3_pd_k_vdd_x OR  (m3_pd_k_vdd_x1_holes INTERACT m3_pd_k_vdd_x1_holes_width)
//
   m3_pd_k_vdd_1  = ( SIZE m3_pd_k_vdd_0 BY -1 ) OR m3_pd_k_vdd_m234ovlp
   m3_pd_k_vdd_2  = ( SIZE m3_pd_k_vdd_1 BY -1 ) OR m3_pd_k_vdd_m234ovlp
   m3_pd_k_vdd_3  = ( SIZE m3_pd_k_vdd_2 BY -1 ) OR m3_pd_k_vdd_m234ovlp
   m3_pd_k_vdd_4  = ( SIZE m3_pd_k_vdd_3 BY -1 ) OR m3_pd_k_vdd_m234ovlp
   m3_pd_k_vdd_5  = ( SIZE m3_pd_k_vdd_4 BY -1 ) OR m3_pd_k_vdd_m234ovlp
   m3_pd_k_vdd_6  = ( SIZE m3_pd_k_vdd_5 BY -1 ) OR m3_pd_k_vdd_m234ovlp
   m3_pd_k_vdd_7  = ( SIZE m3_pd_k_vdd_6 BY -1 ) OR m3_pd_k_vdd_m234ovlp
   m3_pd_k_vdd_8  = ( SIZE m3_pd_k_vdd_7 BY -1 ) OR m3_pd_k_vdd_m234ovlp
   m3_pd_k_vdd_9  = ( SIZE m3_pd_k_vdd_8 BY -1 ) OR m3_pd_k_vdd_m234ovlp
   m3_pd_k_vdd_10 = ( SIZE m3_pd_k_vdd_9 BY -1 ) OR m3_pd_k_vdd_m234ovlp
   m3_pd_k_vdd_11 = ( SIZE m3_pd_k_vdd_10 BY -1 ) OR m3_pd_k_vdd_m234ovlp
   m3_pd_k_vdd_12 = ( SIZE m3_pd_k_vdd_11 BY -1 ) OR m3_pd_k_vdd_m234ovlp
   m3_pd_k_vdd_13 = ( SIZE m3_pd_k_vdd_12 BY -1 ) OR m3_pd_k_vdd_m234ovlp
   m3_pd_k_vdd_14 = ( SIZE m3_pd_k_vdd_13 BY -1 ) OR m3_pd_k_vdd_m234ovlp
   m3_pd_k_vdd_15 = ( SIZE m3_pd_k_vdd_14 BY -0.9 ) OR m3_pd_k_vdd_m234ovlp
//
// 
   DISCONNECT

   CONNECT  met4_pdiode_k_vddpadside  m3_pd_k_vdd_15               BY via3_pdiode_k_vddpadside
   CONNECT  m3_pd_k_vdd_15                met2_pdiode_k_vddpadside BY via2_pdiode_k_vddpadside
   CONNECT  met2_pdiode_k_vddpadside  met1_pdiode_k_vddpadside BY via_pdiode_k_vddpadside
   CONNECT  met1_pdiode_k_vddpadside  pdiode_k_vddpadside      BY ndiffcon_pdiode_k_vddpadside 
   CONNECT  met2_pdiode_k_vddpadside  bondpad_vdd
//
// connected ?
//
   m3_pdiode_k_vddpadside_pathvdd_open = NET AREA RATIO pdiode_k_vddpadside bondpad_vdd == 0
   m3_pd_k_vdd_15_open =  NET AREA RATIO m3_pd_k_vdd_15  m3_pdiode_k_vddpadside_pathvdd_open > 0
// get edge 
   m3_pd_k_vdd_15_openx = SIZE  m3_pd_k_vdd_15_open BY 15 INSIDE OF  met3_pdiode_k_vddpadside STEP 1
   m3_pd_k_vdd_15_openy = EXPAND EDGE (m3_pd_k_vdd_15_openx INSIDE EDGE  met3_pdiode_k_vddpadside) BY 0.5
//
#IFDEF BUSWIDTHDEBUG
   m3_pd_k_vdd_0 { FLATTEN m3_pd_k_vdd_0 }
   m3_pd_k_vdd_15 { FLATTEN m3_pd_k_vdd_15 }
   m3_pdiode_k_vddpadside_pathvdd_open { FLATTEN  m3_pdiode_k_vddpadside_pathvdd_open }
   met3_pdiode_k_vddpadside_open { FLATTEN  m3_pd_k_vdd_15_open  }
   m3_pd_k_vdd_15_openy { COPY m3_pd_k_vdd_15_openy }
#ENDIF
//
   ESDPATH_IOPAD_VDD_PFORWARD_WIDTHPATHVDD_M3_30 {@ P forward diode connected to IO cell does not have correct path with to VDD pad
                                               @  on cathode side
                                               @  met3 power bus smaller than 30 U
       x = NET AREA RATIO pdiode_k_vddpadside bondpad_vdd == 0
       FLATTEN x
       FLATTEN  m3_pd_k_vdd_15_openy
   }
//
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
//                process path vdd forward to vdd pad  m4
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
//
   m4_pd_k_vdd_m34ovlp = COPY met3_met4_via3_pdiode_k_vddpadside
   m4_pd_k_vdd_x = COPY met4_pdiode_k_vddpadside
//
// close slots
//
   m4_pd_k_vdd_x1_holes = HOLES  m4_pd_k_vdd_x INNER < 1000.0  // max slot 300 * 3 U
   m4_pd_k_vdd_x1_holes_width = INT  m4_pd_k_vdd_x1_holes <= 4.0 REGION
   m4_pd_k_vdd_0 = m4_pd_k_vdd_x OR  (m4_pd_k_vdd_x1_holes INTERACT m4_pd_k_vdd_x1_holes_width)
//
   m4_pd_k_vdd_1  = ( SIZE m4_pd_k_vdd_0 BY -1 ) OR m4_pd_k_vdd_m34ovlp
   m4_pd_k_vdd_2  = ( SIZE m4_pd_k_vdd_1 BY -1 ) OR m4_pd_k_vdd_m34ovlp
   m4_pd_k_vdd_3  = ( SIZE m4_pd_k_vdd_2 BY -1 ) OR m4_pd_k_vdd_m34ovlp
   m4_pd_k_vdd_4  = ( SIZE m4_pd_k_vdd_3 BY -1 ) OR m4_pd_k_vdd_m34ovlp
   m4_pd_k_vdd_5  = ( SIZE m4_pd_k_vdd_4 BY -1 ) OR m4_pd_k_vdd_m34ovlp
   m4_pd_k_vdd_6  = ( SIZE m4_pd_k_vdd_5 BY -1 ) OR m4_pd_k_vdd_m34ovlp
   m4_pd_k_vdd_7  = ( SIZE m4_pd_k_vdd_6 BY -1 ) OR m4_pd_k_vdd_m34ovlp
   m4_pd_k_vdd_8  = ( SIZE m4_pd_k_vdd_7 BY -1 ) OR m4_pd_k_vdd_m34ovlp
   m4_pd_k_vdd_9  = ( SIZE m4_pd_k_vdd_8 BY -1 ) OR m4_pd_k_vdd_m34ovlp
   m4_pd_k_vdd_10 = ( SIZE m4_pd_k_vdd_9 BY -1 ) OR m4_pd_k_vdd_m34ovlp
   m4_pd_k_vdd_11 = ( SIZE m4_pd_k_vdd_10 BY -1 ) OR m4_pd_k_vdd_m34ovlp
   m4_pd_k_vdd_12 = ( SIZE m4_pd_k_vdd_11 BY -1 ) OR m4_pd_k_vdd_m34ovlp
   m4_pd_k_vdd_13 = ( SIZE m4_pd_k_vdd_12 BY -1 ) OR m4_pd_k_vdd_m34ovlp
   m4_pd_k_vdd_14 = ( SIZE m4_pd_k_vdd_13 BY -1 ) OR m4_pd_k_vdd_m34ovlp
   m4_pd_k_vdd_15 = ( SIZE m4_pd_k_vdd_14 BY -0.9 ) OR m4_pd_k_vdd_m34ovlp
//
   DISCONNECT
   CONNECT  met3_pdiode_k_vddpadside  m4_pd_k_vdd_15           BY via3_pdiode_k_vddpadside
   CONNECT  met3_pdiode_k_vddpadside  met2_pdiode_k_vddpadside BY via2_pdiode_k_vddpadside
   CONNECT  met2_pdiode_k_vddpadside  met1_pdiode_k_vddpadside BY via_pdiode_k_vddpadside
   CONNECT  met1_pdiode_k_vddpadside  pdiode_k_vddpadside      BY ndiffcon_pdiode_k_vddpadside
   CONNECT  met2_pdiode_k_vddpadside  bondpad_vdd
//
// connected ?
//
   m4_pdiode_k_vddpadside_pathvdd_open = NET AREA RATIO pdiode_k_vddpadside bondpad_vdd == 0
   m4_pd_k_vdd_15_open =  NET AREA RATIO m4_pd_k_vdd_15  m4_pdiode_k_vddpadside_pathvdd_open > 0
// get edge
   m4_pd_k_vdd_15_openx = SIZE  m4_pd_k_vdd_15_open BY 15 INSIDE OF  met4_pdiode_k_vddpadside STEP 1
   m4_pd_k_vdd_15_openy = EXPAND EDGE (m4_pd_k_vdd_15_openx INSIDE EDGE  met4_pdiode_k_vddpadside) BY 0.5
//
#IFDEF BUSWIDTHDEBUG
   m4_pd_k_vdd_0 { FLATTEN m4_pd_k_vdd_0 }
   m4_pd_k_vdd_15 { FLATTEN m4_pd_k_vdd_15 }
   m4_pdiode_k_vddpadside_pathvdd_open { FLATTEN  m4_pdiode_k_vddpadside_pathvdd_open }
   m4_pd_k_vdd_15_openy { COPY m4_pd_k_vdd_15_openy }
   met4_pdiode_k_vddpadside_open { FLATTEN  m4_pd_k_vdd_15_open  }
#ENDIF
//
   ESDPATH_IOPAD_VDD_PFORWARD_WIDTHPATHVDD_M4_30 {@ P forward diode connected to IO cell does not have correct path width  to VDD pad
                                               @  on cathode side
                                               @  met4 power bus smaller than 30 U
       x = NET AREA RATIO pdiode_k_vddpadside bondpad_vdd == 0
       FLATTEN x
       FLATTEN  m4_pd_k_vdd_15_openy
   }
//
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
//                  process path vdd forward to vdd pad  m2
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
//
   m2_pd_k_vdd_m123ovlp = met2_met3_via2_pdiode_k_vddpadside OR met1_met2_via_pdiode_k_vddpadside
   m2_pd_k_vdd_x = COPY met2_pdiode_k_vddpadside
//
// close slots
//
   m2_pd_k_vdd_x1_holes = HOLES  m2_pd_k_vdd_x INNER < 1000.0  // max slot 300 * 3 U
   m2_pd_k_vdd_x1_holes_width = INT  m2_pd_k_vdd_x1_holes <= 4.0 REGION
   m2_pd_k_vdd_0 = m2_pd_k_vdd_x OR  (m2_pd_k_vdd_x1_holes INTERACT m2_pd_k_vdd_x1_holes_width)
//
   m2_pd_k_vdd_1  = ( SIZE m2_pd_k_vdd_0 BY -1 ) OR m2_pd_k_vdd_m123ovlp
   m2_pd_k_vdd_2  = ( SIZE m2_pd_k_vdd_1 BY -1 ) OR m2_pd_k_vdd_m123ovlp
   m2_pd_k_vdd_3  = ( SIZE m2_pd_k_vdd_2 BY -1 ) OR m2_pd_k_vdd_m123ovlp
   m2_pd_k_vdd_4  = ( SIZE m2_pd_k_vdd_3 BY -1 ) OR m2_pd_k_vdd_m123ovlp
   m2_pd_k_vdd_5  = ( SIZE m2_pd_k_vdd_4 BY -1 ) OR m2_pd_k_vdd_m123ovlp
   m2_pd_k_vdd_6  = ( SIZE m2_pd_k_vdd_5 BY -1 ) OR m2_pd_k_vdd_m123ovlp
   m2_pd_k_vdd_7  = ( SIZE m2_pd_k_vdd_6 BY -1 ) OR m2_pd_k_vdd_m123ovlp
   m2_pd_k_vdd_8  = ( SIZE m2_pd_k_vdd_7 BY -1 ) OR m2_pd_k_vdd_m123ovlp
   m2_pd_k_vdd_9  = ( SIZE m2_pd_k_vdd_8 BY -1 ) OR m2_pd_k_vdd_m123ovlp
   m2_pd_k_vdd_10 = ( SIZE m2_pd_k_vdd_9 BY -1 ) OR m2_pd_k_vdd_m123ovlp
   m2_pd_k_vdd_11 = ( SIZE m2_pd_k_vdd_10 BY -1 ) OR m2_pd_k_vdd_m123ovlp
   m2_pd_k_vdd_12 = ( SIZE m2_pd_k_vdd_11 BY -1 ) OR m2_pd_k_vdd_m123ovlp
   m2_pd_k_vdd_13 = ( SIZE m2_pd_k_vdd_12 BY -1 ) OR m2_pd_k_vdd_m123ovlp
   m2_pd_k_vdd_14 = ( SIZE m2_pd_k_vdd_13 BY -1 ) OR m2_pd_k_vdd_m123ovlp
   m2_pd_k_vdd_15 = ( SIZE m2_pd_k_vdd_14 BY -0.9 ) OR m2_pd_k_vdd_m123ovlp
//
#IFDEF  BUSWIDTHDEBUG
// original and undersized metal
   m2_pd_k_vdd_0 { FLATTEN m2_pd_k_vdd_0 }
   m2_pd_k_vdd_15 { FLATTEN m2_pd_k_vdd_15 }
#ENDIF
//
   DISCONNECT
   CONNECT  met4_pdiode_k_vddpadside  met3_pdiode_k_vddpadside BY via3_pdiode_k_vddpadside
   CONNECT  m2_pd_k_vdd_15            met3_pdiode_k_vddpadside BY via2_pdiode_k_vddpadside
   CONNECT  m2_pd_k_vdd_15            met1_pdiode_k_vddpadside BY via_pdiode_k_vddpadside
   CONNECT  met1_pdiode_k_vddpadside  pdiode_k_vddpadside      BY ndiffcon_pdiode_k_vddpadside
   CONNECT  m2_pd_k_vdd_15            bondpad_vdd
//
// connected ?
//
   m2_pdiode_k_vddpadside_pathvdd_open = NET AREA RATIO pdiode_k_vddpadside bondpad_vdd == 0
   m2_pd_k_vdd_15_open =  NET AREA RATIO m2_pd_k_vdd_15  m2_pdiode_k_vddpadside_pathvdd_open > 0
// get edge
   m2_pd_k_vdd_15_openx = SIZE  m2_pd_k_vdd_15_open BY 15 INSIDE OF  met2_pdiode_k_vddpadside STEP 1
   m2_pd_k_vdd_15_openy = EXPAND EDGE (m2_pd_k_vdd_15_openx INSIDE EDGE  met2_pdiode_k_vddpadside) BY 0.5
//
#IFDEF BUSWIDTHDEBUG
   m2_pdiode_k_vddpadside_pathvdd_open { FLATTEN  m2_pdiode_k_vddpadside_pathvdd_open }
   met2_pdiode_k_vddpadside_open { FLATTEN  m2_pd_k_vdd_15_open  }
   m2_pd_k_vdd_15_openy { COPY m2_pd_k_vdd_15_openy }
#ENDIF
//
   ESDPATH_IOPAD_VDD_PFORWARD_WIDTHPATHVDD_M2_30 {@ P forward diode connected to IO cell does not have correct path width to VDD pad
                                               @  on cathode side
                                               @  met2 power bus smaller than 30 U
       x = NET AREA RATIO pdiode_k_vddpadside bondpad_vdd == 0
       FLATTEN x
       FLATTEN  m2_pd_k_vdd_15_openy
   }
//
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
//                process path vss forward to gnd pad m3
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
//
   m3_nd_a_gnd_m234ovlp = met2_met3_via2_ndiode_a_gndpadside OR met3_met4_via3_ndiode_a_gndpadside
   m3_nd_a_gnd_x = COPY met3_ndiode_a_gndpadside
//
// close slots
//
   m3_nd_a_gnd_x1_holes = HOLES  m3_nd_a_gnd_x INNER < 1000.0  // max slot 300 * 3 U
   m3_nd_a_gnd_x1_holes_width = INT  m3_nd_a_gnd_x1_holes <= 4.0 REGION
   m3_nd_a_gnd_0 = m3_nd_a_gnd_x OR  (m3_nd_a_gnd_x1_holes INTERACT m3_nd_a_gnd_x1_holes_width)
//
   m3_nd_a_gnd_1  = ( SIZE m3_nd_a_gnd_0 BY -1 ) OR m3_nd_a_gnd_m234ovlp
   m3_nd_a_gnd_2  = ( SIZE m3_nd_a_gnd_1 BY -1 ) OR m3_nd_a_gnd_m234ovlp
   m3_nd_a_gnd_3  = ( SIZE m3_nd_a_gnd_2 BY -1 ) OR m3_nd_a_gnd_m234ovlp
   m3_nd_a_gnd_4  = ( SIZE m3_nd_a_gnd_3 BY -1 ) OR m3_nd_a_gnd_m234ovlp
   m3_nd_a_gnd_5  = ( SIZE m3_nd_a_gnd_4 BY -1 ) OR m3_nd_a_gnd_m234ovlp
   m3_nd_a_gnd_6  = ( SIZE m3_nd_a_gnd_5 BY -1 ) OR m3_nd_a_gnd_m234ovlp
   m3_nd_a_gnd_7  = ( SIZE m3_nd_a_gnd_6 BY -1 ) OR m3_nd_a_gnd_m234ovlp
   m3_nd_a_gnd_8  = ( SIZE m3_nd_a_gnd_7 BY -1 ) OR m3_nd_a_gnd_m234ovlp
   m3_nd_a_gnd_9  = ( SIZE m3_nd_a_gnd_8 BY -1 ) OR m3_nd_a_gnd_m234ovlp
   m3_nd_a_gnd_10 = ( SIZE m3_nd_a_gnd_9 BY -1 ) OR m3_nd_a_gnd_m234ovlp
   m3_nd_a_gnd_11 = ( SIZE m3_nd_a_gnd_10 BY -1 ) OR m3_nd_a_gnd_m234ovlp
   m3_nd_a_gnd_12 = ( SIZE m3_nd_a_gnd_11 BY -1 ) OR m3_nd_a_gnd_m234ovlp
   m3_nd_a_gnd_13 = ( SIZE m3_nd_a_gnd_12 BY -1 ) OR m3_nd_a_gnd_m234ovlp
   m3_nd_a_gnd_14 = ( SIZE m3_nd_a_gnd_13 BY -1 ) OR m3_nd_a_gnd_m234ovlp
   m3_nd_a_gnd_15 = ( SIZE m3_nd_a_gnd_14 BY -0.9 ) OR m3_nd_a_gnd_m234ovlp
//
   DISCONNECT
//                                                                                                                                              
   CONNECT  met4_ndiode_a_gndpadside  m3_nd_a_gnd_15               BY via3_ndiode_a_gndpadside
   CONNECT  m3_nd_a_gnd_15                met2_ndiode_a_gndpadside BY via2_ndiode_a_gndpadside
   CONNECT  met2_ndiode_a_gndpadside  met1_ndiode_a_gndpadside     BY via_ndiode_a_gndpadside
   CONNECT  met1_ndiode_a_gndpadside  ndiode_a_gndpadside          BY pdiffcon_ndiode_a_gndpadside
   CONNECT  met2_ndiode_a_gndpadside  bondpad_gnd
//
// connected ?
//
   m3_ndiode_a_gndpadside_pathgnd_open = NET AREA RATIO ndiode_a_gndpadside bondpad_gnd == 0
   m3_nd_a_gnd_15_open =  NET AREA RATIO m3_nd_a_gnd_15  m3_ndiode_a_gndpadside_pathgnd_open > 0
// get edge
   m3_nd_a_gnd_15_openx = SIZE  m3_nd_a_gnd_15_open BY 15 INSIDE OF  met3_ndiode_a_gndpadside STEP 1
   m3_nd_a_gnd_15_openy = EXPAND EDGE (m3_nd_a_gnd_15_openx INSIDE EDGE  met3_ndiode_a_gndpadside) BY 0.5
//
#IFDEF BUSWIDTHDEBUG
   m3_nd_a_gnd_0 { FLATTEN m3_nd_a_gnd_0 }
   m3_nd_a_gnd_15 { FLATTEN m3_nd_a_gnd_15 }
   m3_ndiode_a_gndpadside_pathgnd_open { FLATTEN  m3_ndiode_a_gndpadside_pathgnd_open }
   met3_ndiode_a_gndpadside_open { FLATTEN  m3_nd_a_gnd_15_open  }
   m3_nd_a_gnd_15_openy { COPY m3_nd_a_gnd_15_openy }
#ENDIF
//
   ESDPATH_IOPAD_VSS_NFORWARD_WIDTHPATHVSS_M3_30 {@ N forward diode connected to IO cell does not have path >=30 U to GND pad
                                               @  on anode side
                                               @  met3 power bus smaller than 30 U
       x = NET AREA RATIO ndiode_a_gndpadside bondpad_gnd == 0
       FLATTEN x
       FLATTEN  m3_nd_a_gnd_15_openy
   }
//
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
//                process path vss forward to gnd pad m4
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
//
   m4_nd_a_gnd_m34ovlp = COPY met3_met4_via3_ndiode_a_gndpadside
   m4_nd_a_gnd_x = COPY met4_ndiode_a_gndpadside
//
// close slots
//
   m4_nd_a_gnd_x1_holes = HOLES  m4_nd_a_gnd_x INNER < 1000.0  // max slot 300 * 3 U
   m4_nd_a_gnd_x1_holes_width = INT  m4_nd_a_gnd_x1_holes <= 4.0 REGION
   m4_nd_a_gnd_0 = m4_nd_a_gnd_x OR  (m4_nd_a_gnd_x1_holes INTERACT m4_nd_a_gnd_x1_holes_width)
//
   m4_nd_a_gnd_1  = ( SIZE m4_nd_a_gnd_0 BY -1 ) OR m4_nd_a_gnd_m34ovlp
   m4_nd_a_gnd_2  = ( SIZE m4_nd_a_gnd_1 BY -1 ) OR m4_nd_a_gnd_m34ovlp
   m4_nd_a_gnd_3  = ( SIZE m4_nd_a_gnd_2 BY -1 ) OR m4_nd_a_gnd_m34ovlp
   m4_nd_a_gnd_4  = ( SIZE m4_nd_a_gnd_3 BY -1 ) OR m4_nd_a_gnd_m34ovlp
   m4_nd_a_gnd_5  = ( SIZE m4_nd_a_gnd_4 BY -1 ) OR m4_nd_a_gnd_m34ovlp
   m4_nd_a_gnd_6  = ( SIZE m4_nd_a_gnd_5 BY -1 ) OR m4_nd_a_gnd_m34ovlp
   m4_nd_a_gnd_7  = ( SIZE m4_nd_a_gnd_6 BY -1 ) OR m4_nd_a_gnd_m34ovlp
   m4_nd_a_gnd_8  = ( SIZE m4_nd_a_gnd_7 BY -1 ) OR m4_nd_a_gnd_m34ovlp
   m4_nd_a_gnd_9  = ( SIZE m4_nd_a_gnd_8 BY -1 ) OR m4_nd_a_gnd_m34ovlp
   m4_nd_a_gnd_10 = ( SIZE m4_nd_a_gnd_9 BY -1 ) OR m4_nd_a_gnd_m34ovlp
   m4_nd_a_gnd_11 = ( SIZE m4_nd_a_gnd_10 BY -1 ) OR m4_nd_a_gnd_m34ovlp
   m4_nd_a_gnd_12 = ( SIZE m4_nd_a_gnd_11 BY -1 ) OR m4_nd_a_gnd_m34ovlp
   m4_nd_a_gnd_13 = ( SIZE m4_nd_a_gnd_12 BY -1 ) OR m4_nd_a_gnd_m34ovlp
   m4_nd_a_gnd_14 = ( SIZE m4_nd_a_gnd_13 BY -1 ) OR m4_nd_a_gnd_m34ovlp
   m4_nd_a_gnd_15 = ( SIZE m4_nd_a_gnd_14 BY -0.9 ) OR m4_nd_a_gnd_m34ovlp
//
   DISCONNECT
   CONNECT  met3_ndiode_a_gndpadside  m4_nd_a_gnd_15           BY via3_ndiode_a_gndpadside
   CONNECT  met3_ndiode_a_gndpadside  met2_ndiode_a_gndpadside BY via2_ndiode_a_gndpadside
   CONNECT  met2_ndiode_a_gndpadside  met1_ndiode_a_gndpadside BY via_ndiode_a_gndpadside
   CONNECT  met1_ndiode_a_gndpadside  ndiode_a_gndpadside      BY pdiffcon_ndiode_a_gndpadside
   CONNECT  met2_ndiode_a_gndpadside  bondpad_gnd
//
// connected ?
//
   m4_ndiode_a_gndpadside_pathgnd_open = NET AREA RATIO ndiode_a_gndpadside bondpad_gnd == 0
   m4_nd_a_gnd_15_open =  NET AREA RATIO m4_nd_a_gnd_15  m4_ndiode_a_gndpadside_pathgnd_open > 0
// get edge
   m4_nd_a_gnd_15_openx = SIZE  m4_nd_a_gnd_15_open BY 15 INSIDE OF  met4_ndiode_a_gndpadside STEP 1
   m4_nd_a_gnd_15_openy = EXPAND EDGE (m4_nd_a_gnd_15_openx INSIDE EDGE  met4_ndiode_a_gndpadside) BY 0.5
//
#IFDEF BUSWIDTHDEBUG
   m4_nd_a_gnd_0 { FLATTEN m4_nd_a_gnd_0 }
   m4_nd_a_gnd_15 { FLATTEN m4_nd_a_gnd_15 }
   m4_ndiode_a_gndpadside_pathgnd_open { FLATTEN  m4_ndiode_a_gndpadside_pathgnd_open }
   m4_nd_a_gnd_15_openy { COPY m4_nd_a_gnd_15_openy }
   met4_ndiode_a_gndpadside_open { FLATTEN  m4_nd_a_gnd_15_open  }
#ENDIF
//
   ESDPATH_IOPAD_VSS_NFORWARD_WIDTHPATHVSS_M4_30 {@ N forward diode connected to IO cell does not have path >=30 to GND pad
                                               @  on anode side
                                               @  met4 power bus smaller than 30 U
       x = NET AREA RATIO ndiode_a_gndpadside bondpad_gnd == 0
       FLATTEN x
       FLATTEN  m4_nd_a_gnd_15_openy
   }

//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
//                   process path vss forward to gnd pad m2
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
//
   m2_nd_a_gnd_m123ovlp = met2_met3_via2_ndiode_a_gndpadside OR met1_met2_via_ndiode_a_gndpadside
   m2_nd_a_gnd_x = COPY met2_ndiode_a_gndpadside
//
// close slots
//
   m2_nd_a_gnd_x1_holes = HOLES  m2_nd_a_gnd_x INNER < 1000.0  // max slot 300 * 3 U
   m2_nd_a_gnd_x1_holes_width = INT  m2_nd_a_gnd_x1_holes <= 4.0 REGION
   m2_nd_a_gnd_0 = m2_nd_a_gnd_x OR  (m2_nd_a_gnd_x1_holes INTERACT m2_nd_a_gnd_x1_holes_width)
//
   m2_nd_a_gnd_1  = ( SIZE m2_nd_a_gnd_0 BY -1 ) OR m2_nd_a_gnd_m123ovlp
   m2_nd_a_gnd_2  = ( SIZE m2_nd_a_gnd_1 BY -1 ) OR m2_nd_a_gnd_m123ovlp
   m2_nd_a_gnd_3  = ( SIZE m2_nd_a_gnd_2 BY -1 ) OR m2_nd_a_gnd_m123ovlp
   m2_nd_a_gnd_4  = ( SIZE m2_nd_a_gnd_3 BY -1 ) OR m2_nd_a_gnd_m123ovlp
   m2_nd_a_gnd_5  = ( SIZE m2_nd_a_gnd_4 BY -1 ) OR m2_nd_a_gnd_m123ovlp
   m2_nd_a_gnd_6  = ( SIZE m2_nd_a_gnd_5 BY -1 ) OR m2_nd_a_gnd_m123ovlp
   m2_nd_a_gnd_7  = ( SIZE m2_nd_a_gnd_6 BY -1 ) OR m2_nd_a_gnd_m123ovlp
   m2_nd_a_gnd_8  = ( SIZE m2_nd_a_gnd_7 BY -1 ) OR m2_nd_a_gnd_m123ovlp
   m2_nd_a_gnd_9  = ( SIZE m2_nd_a_gnd_8 BY -1 ) OR m2_nd_a_gnd_m123ovlp
   m2_nd_a_gnd_10 = ( SIZE m2_nd_a_gnd_9 BY -1 ) OR m2_nd_a_gnd_m123ovlp
   m2_nd_a_gnd_11 = ( SIZE m2_nd_a_gnd_10 BY -1 ) OR m2_nd_a_gnd_m123ovlp
   m2_nd_a_gnd_12 = ( SIZE m2_nd_a_gnd_11 BY -1 ) OR m2_nd_a_gnd_m123ovlp
   m2_nd_a_gnd_13 = ( SIZE m2_nd_a_gnd_12 BY -1 ) OR m2_nd_a_gnd_m123ovlp
   m2_nd_a_gnd_14 = ( SIZE m2_nd_a_gnd_13 BY -1 ) OR m2_nd_a_gnd_m123ovlp
   m2_nd_a_gnd_15 = ( SIZE m2_nd_a_gnd_14 BY -0.9 ) OR m2_nd_a_gnd_m123ovlp
//
   DISCONNECT
   CONNECT  met4_ndiode_a_gndpadside  met3_ndiode_a_gndpadside BY via3_ndiode_a_gndpadside
   CONNECT  m2_nd_a_gnd_15            met3_ndiode_a_gndpadside BY via2_ndiode_a_gndpadside
   CONNECT  m2_nd_a_gnd_15            met1_ndiode_a_gndpadside BY via_ndiode_a_gndpadside
   CONNECT  met1_ndiode_a_gndpadside  ndiode_a_gndpadside      BY pdiffcon_ndiode_a_gndpadside
   CONNECT  m2_nd_a_gnd_15            bondpad_gnd
//
// connected ?
//
   m2_ndiode_a_gndpadside_pathgnd_open = NET AREA RATIO ndiode_a_gndpadside bondpad_gnd == 0
   m2_nd_a_gnd_15_open =  NET AREA RATIO m2_nd_a_gnd_15  m2_ndiode_a_gndpadside_pathgnd_open > 0
// get edge
   m2_nd_a_gnd_15_openx = SIZE  m2_nd_a_gnd_15_open BY 15 INSIDE OF  met2_ndiode_a_gndpadside STEP 1
   m2_nd_a_gnd_15_openy = EXPAND EDGE (m2_nd_a_gnd_15_openx INSIDE EDGE  met2_ndiode_a_gndpadside) BY 0.5
//
#IFDEF BUSWIDTHDEBUG
// original and undersized metal
   m2_nd_a_gnd_0 { FLATTEN m2_nd_a_gnd_0 }
   m2_nd_a_gnd_15 { FLATTEN m2_nd_a_gnd_15 }
   m2_ndiode_a_gndpadside_pathgnd_open { FLATTEN  m2_ndiode_a_gndpadside_pathgnd_open }
   met2_ndiode_a_gndpadside_open { FLATTEN  m2_nd_a_gnd_15_open  }
   m2_nd_a_gnd_15_openy { COPY m2_nd_a_gnd_15_openy }
#ENDIF
//
   ESDPATH_IOPAD_VSS_NFORWARD_WIDTHPATHVSS_M2_30 {@ N forward diode connected to IO cell does not have path >=30 U to GND pad
                                               @ on cathode side
                                               @ met2 power bus smaller than 30 U
       x = NET AREA RATIO ndiode_a_gndpadside bondpad_gnd == 0
       FLATTEN x
       FLATTEN  m2_nd_a_gnd_15_openy
   }
//
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
//
//        check for via count on transition of path vdd/vss forward to pad
//
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
//
#DEFINE BUS_METAL_VIA_CHECK
#IFDEF BUS_METAL_VIA_CHECK 
//
// get big metal and check density on overlapping areas only
//
// close slots before width check
//
   met1_pdiode_k_vddpadside_h   =  HOLES  met1_pdiode_k_vddpadside INNER < 1000.0  // max slot 300 * 3 U
   met1_pdiode_k_vddpadside_h1  =  INT met1_pdiode_k_vddpadside_h <= 4.0 REGION 
   met1_pdiode_k_vddpadside_c   = met1_pdiode_k_vddpadside OR (met1_pdiode_k_vddpadside_h INTERACT  met1_pdiode_k_vddpadside_h1)
//
   met3_pdiode_k_vddpadside_h   =  HOLES  met3_pdiode_k_vddpadside INNER < 1000.0  // max slot 300 * 3 U
   met3_pdiode_k_vddpadside_h1  =  INT met3_pdiode_k_vddpadside_h <= 4.0 REGION 
   met3_pdiode_k_vddpadside_c   = met3_pdiode_k_vddpadside OR (met3_pdiode_k_vddpadside_h INTERACT  met3_pdiode_k_vddpadside_h1)
//
   met2_pdiode_k_vddpadside_h   =  HOLES  met2_pdiode_k_vddpadside INNER < 1000.0  // max slot 300 * 3 U
   met2_pdiode_k_vddpadside_h1  =  INT met2_pdiode_k_vddpadside_h <= 4.0 REGION 
   met2_pdiode_k_vddpadside_c   = met2_pdiode_k_vddpadside OR (met2_pdiode_k_vddpadside_h INTERACT  met2_pdiode_k_vddpadside_h1)
//
   met4_pdiode_k_vddpadside_h   =  HOLES  met4_pdiode_k_vddpadside INNER < 1000.0  // max slot 300 * 3 U
   met4_pdiode_k_vddpadside_h1  =  INT met4_pdiode_k_vddpadside_h <= 4.0 REGION 
   met4_pdiode_k_vddpadside_c   = met4_pdiode_k_vddpadside OR (met4_pdiode_k_vddpadside_h INTERACT  met4_pdiode_k_vddpadside_h1)
//
// closed slots
//
   met4_pdiode_k_vddpadside_ge30 = WITH WIDTH met4_pdiode_k_vddpadside_c >= 30
   met3_pdiode_k_vddpadside_ge30 = WITH WIDTH met3_pdiode_k_vddpadside_c >= 30
   met2_pdiode_k_vddpadside_ge30 = WITH WIDTH met2_pdiode_k_vddpadside_c >= 30
   met1_pdiode_k_vddpadside_ge30 = WITH WIDTH met1_pdiode_k_vddpadside_c >= 30
//
// overlapping
//
   met43_pdiode_k_vddpadside_ge30 =  met4_pdiode_k_vddpadside_ge30 AND  met3_pdiode_k_vddpadside_ge30
   met32_pdiode_k_vddpadside_ge30 =  met3_pdiode_k_vddpadside_ge30 AND  met2_pdiode_k_vddpadside_ge30
   met21_pdiode_k_vddpadside_ge30 =  met2_pdiode_k_vddpadside_ge30 AND  met1_pdiode_k_vddpadside_ge30
//
#IFDEF  GET_MET_DI_PATH
   met4_pdiode_k_vddpadside_ge30  { FLATTEN  met4_pdiode_k_vddpadside_ge30 }
   met3_pdiode_k_vddpadside_ge30  { FLATTEN  met3_pdiode_k_vddpadside_ge30 }
   met2_pdiode_k_vddpadside_ge30  { FLATTEN  met2_pdiode_k_vddpadside_ge30 }
   met1_pdiode_k_vddpadside_ge30  { FLATTEN  met1_pdiode_k_vddpadside_ge30 }
#ENDIF
//   met43_pdiode_k_vddpadside_ge30  { FLATTEN  met43_pdiode_k_vddpadside_ge30 }
//   met32_pdiode_k_vddpadside_ge30  { FLATTEN  met32_pdiode_k_vddpadside_ge30 }
//   met21_pdiode_k_vddpadside_ge30  { FLATTEN  met21_pdiode_k_vddpadside_ge30 }
//
// close slots before width check
//
   met1_ndiode_a_gndpadside_h   =  HOLES  met1_ndiode_a_gndpadside INNER < 1000.0  // max slot 300 * 3 U
   met1_ndiode_a_gndpadside_h1  =  INT met1_ndiode_a_gndpadside_h <= 4.0 REGION 
   met1_ndiode_a_gndpadside_c   = met1_ndiode_a_gndpadside OR (met1_ndiode_a_gndpadside_h INTERACT  met1_ndiode_a_gndpadside_h1)
//
   met3_ndiode_a_gndpadside_h   =  HOLES  met3_ndiode_a_gndpadside INNER < 1000.0  // max slot 300 * 3 U
   met3_ndiode_a_gndpadside_h1  =  INT met3_ndiode_a_gndpadside_h <= 4.0 REGION 
   met3_ndiode_a_gndpadside_c   = met3_ndiode_a_gndpadside OR (met3_ndiode_a_gndpadside_h INTERACT  met3_ndiode_a_gndpadside_h1)
//
   met2_ndiode_a_gndpadside_h   =  HOLES  met2_ndiode_a_gndpadside INNER < 1000.0  // max slot 300 * 3 U
   met2_ndiode_a_gndpadside_h1  =  INT met2_ndiode_a_gndpadside_h <= 4.0 REGION 
   met2_ndiode_a_gndpadside_c   = met2_ndiode_a_gndpadside OR (met2_ndiode_a_gndpadside_h INTERACT  met2_ndiode_a_gndpadside_h1)
//
   met4_ndiode_a_gndpadside_h   =  HOLES  met4_ndiode_a_gndpadside INNER < 1000.0  // max slot 300 * 3 U
   met4_ndiode_a_gndpadside_h1  =  INT met4_ndiode_a_gndpadside_h <= 4.0 REGION 
   met4_ndiode_a_gndpadside_c   = met4_ndiode_a_gndpadside OR (met4_ndiode_a_gndpadside_h INTERACT  met4_ndiode_a_gndpadside_h1)
//
// closed slots
//
   met4_ndiode_a_gndpadside_ge30 = WITH WIDTH met4_ndiode_a_gndpadside_c >= 30
   met3_ndiode_a_gndpadside_ge30 = WITH WIDTH met3_ndiode_a_gndpadside_c >= 30
   met2_ndiode_a_gndpadside_ge30 = WITH WIDTH met2_ndiode_a_gndpadside_c >= 30
   met1_ndiode_a_gndpadside_ge30 = WITH WIDTH met1_ndiode_a_gndpadside_c >= 30
//
// overlapping
//
   met43_ndiode_a_gndpadside_ge30 =  met4_ndiode_a_gndpadside_ge30 AND met3_ndiode_a_gndpadside_ge30
   met32_ndiode_a_gndpadside_ge30 =  met3_ndiode_a_gndpadside_ge30 AND met2_ndiode_a_gndpadside_ge30
   met21_ndiode_a_gndpadside_ge30 =  met2_ndiode_a_gndpadside_ge30 AND met1_ndiode_a_gndpadside_ge30
//
#IFDEF GET_MET_DI_PATH
   met4_ndiode_a_gndpadside_ge30  { FLATTEN  met4_ndiode_a_gndpadside_ge30 }
   met3_ndiode_a_gndpadside_ge30  { FLATTEN  met3_ndiode_a_gndpadside_ge30 }
   met2_ndiode_a_gndpadside_ge30  { FLATTEN  met2_ndiode_a_gndpadside_ge30 }
   met1_ndiode_a_gndpadside_ge30  { FLATTEN  met1_ndiode_a_gndpadside_ge30 }
#ENDIF
//   met43_ndiode_a_gndpadside_ge30  { FLATTEN  met43_ndiode_a_gndpadside_ge30 }
//   met32_ndiode_a_gndpadside_ge30  { FLATTEN  met32_ndiode_a_gndpadside_ge30 }
//   met21_ndiode_a_gndpadside_ge30  { FLATTEN  met21_ndiode_a_gndpadside_ge30 }
//
//
// minimum count of vias for one metal change is 30
// add size by 1.5 overunder and check in closed area
//
   DISCONNECT
//
// m1/m2
//
   via_pdiode_k_vddpadsidex = via_pdiode_k_vddpadside AND met1_met2_via_pdiode_k_vddpadside
   CONNECT  met1_met2_via_pdiode_k_vddpadside via_pdiode_k_vddpadsidex
   ESDPATH_IOPAD_VDD_PFORWARD_CPATHVIA_M1_M2 {@ P forward diode connected to IO cell does not have 30 via path to VDD pad
                                                  @  on cathode side
                                                  @  met1/met2 power bus overlap via < 30
        x = NET AREA RATIO met1_met2_via_pdiode_k_vddpadside via_pdiode_k_vddpadsidex < 30  [ COUNT (via_pdiode_k_vddpadsidex) ]
        x AND met21_pdiode_k_vddpadside_ge30
   }
//
   via_pdiode_k_vddpadsideclose = SIZE via_pdiode_k_vddpadsidex BY 1.5 OVERUNDER
   CONNECT  met1_met2_via_pdiode_k_vddpadside  via_pdiode_k_vddpadsideclose
   ESDPATH_IOPAD_VDD_PFORWARD_DPATHVIA_M1_M2 {@ P forward diode connected to IO cell does not have sufficient via density in path to VDD pad
                                              @  met1/met2 power bus overlap via spacing too large 3
        x = NET AREA RATIO met1_met2_via_pdiode_k_vddpadside via_pdiode_k_vddpadsideclose > 1  [ COUNT (via_pdiode_k_vddpadsideclose) ]
        x AND met21_pdiode_k_vddpadside_ge30
   }
//
//----------------------
   via2_pdiode_k_vddpadsidex = via2_pdiode_k_vddpadside AND met2_met3_via2_pdiode_k_vddpadside
   CONNECT  met2_met3_via2_pdiode_k_vddpadside via2_pdiode_k_vddpadsidex
   ESDPATH_IOPAD_VDD_PFORWARD_CPATHVIA2_M2_M3 {@ P forward diode connected to IO cell does not have 30 via2 path to VDD pad
                                                  @  on cathode side
                                                  @  met2/met3 power bus overlap via2 < 30
        x = NET AREA RATIO met2_met3_via2_pdiode_k_vddpadside via2_pdiode_k_vddpadsidex < 30  [ COUNT (via2_pdiode_k_vddpadsidex) ]
        x AND met32_pdiode_k_vddpadside_ge30
   }
   via2_pdiode_k_vddpadsideclose = SIZE via2_pdiode_k_vddpadsidex BY 1.5 OVERUNDER
   CONNECT  met2_met3_via2_pdiode_k_vddpadside via2_pdiode_k_vddpadsideclose
   ESDPATH_IOPAD_VDD_PFORWARD_DPATHVIA2_M2_M3 {@ P forward diode connected to IO cell does not have sufficient via2 density in path to VDD pad
                                               @  met2/met3 power bus overlap via2 spacing too large
        x = NET AREA RATIO met2_met3_via2_pdiode_k_vddpadside via2_pdiode_k_vddpadsideclose > 1  [ COUNT (via2_pdiode_k_vddpadsideclose) ]
        x AND met32_pdiode_k_vddpadside_ge30
   }
//------------------------------
//
   via3_pdiode_k_vddpadsidex = via3_pdiode_k_vddpadside AND met3_met4_via3_pdiode_k_vddpadside
   CONNECT met3_met4_via3_pdiode_k_vddpadside via3_pdiode_k_vddpadsidex
   ESDPATH_IOPAD_VDD_PFORWARD_CPATHVIA3_M3_M4 {@ P forward diode connected to IO cell does not have 30 via3 path to VDD pad
                                                  @  on cathode side
                                                  @  met4/met3 power bus overlap via3 < 30
        x = NET AREA RATIO met3_met4_via3_pdiode_k_vddpadside  via3_pdiode_k_vddpadsidex < 30  [ COUNT ( via3_pdiode_k_vddpadsidex) ]
        x AND met43_pdiode_k_vddpadside_ge30
   }
//
   via3_pdiode_k_vddpadsideclose = SIZE via3_pdiode_k_vddpadsidex BY 1.5 OVERUNDER
   CONNECT met3_met4_via3_pdiode_k_vddpadside via3_pdiode_k_vddpadsideclose
   ESDPATH_IOPAD_VDD_PFORWARD_DPATHVIA3_M3_M4 {@ P forward diode connected to IO cell does not have  sufficient via3 density in path to VDD pad
                                               @  met4/met3 power bus overlap via3 spacing too large
        x = NET AREA RATIO met3_met4_via3_pdiode_k_vddpadside  via3_pdiode_k_vddpadsideclose > 1 [ COUNT ( via3_pdiode_k_vddpadsideclose) ]
        x AND met43_pdiode_k_vddpadside_ge30
   }
//
//----------------------------------
//
// n forward to vss via density checks
//
   via_ndiode_a_gndpadsidex = via_ndiode_a_gndpadside AND met1_met2_via_ndiode_a_gndpadside
   CONNECT  met1_met2_via_ndiode_a_gndpadside via_ndiode_a_gndpadsidex
   ESDPATH_IOPAD_VSS_NFORWARD_CPATHVIA_M1_M2 {@ N forward diode connected to IO cell does not have 30 via path to VDD pad
                                                  @  on cathode side
                                                  @  met1/met2 power bus overlap via < 30
        x = NET AREA RATIO met1_met2_via_ndiode_a_gndpadside via_ndiode_a_gndpadsidex < 30  [ COUNT (via_ndiode_a_gndpadsidex) ]
        x AND met32_ndiode_a_gndpadside_ge30
   }
//
// add density here
//
   via_ndiode_a_gndpadsideclose = SIZE via_ndiode_a_gndpadsidex BY 1.5 OVERUNDER
   CONNECT  met1_met2_via_ndiode_a_gndpadside  via_ndiode_a_gndpadsideclose
   ESDPATH_IOPAD_VSS_NFORWARD_DPATHVIA_M1_M2 {@ N forward diode connected to IO cell does not have sufficient via density in path to VDD pad
                                              @  met1/met2 power bus overlap via spacing too large
        x = NET AREA RATIO met1_met2_via_ndiode_a_gndpadside via_ndiode_a_gndpadsideclose > 1  [ COUNT (via_ndiode_a_gndpadsideclose) ]
        x AND met21_ndiode_a_gndpadside_ge30
   }
//
   via2_ndiode_a_gndpadsidex = via2_ndiode_a_gndpadside AND met2_met3_via2_ndiode_a_gndpadside
   CONNECT  met2_met3_via2_ndiode_a_gndpadside via2_ndiode_a_gndpadsidex
   ESDPATH_IOPAD_VSS_NFORWARD_CPATHVIA2_M2_M3 {@ N forward diode connected to IO cell does not have 30 via2 path to VDD pad
                                                  @  on cathode side
                                                  @  met2/met3 power bus overlap via2 < 30
        x = NET AREA RATIO met2_met3_via2_ndiode_a_gndpadside via2_ndiode_a_gndpadsidex < 30  [ COUNT (via2_ndiode_a_gndpadsidex) ]
        x AND met32_ndiode_a_gndpadside_ge30
   }
//
//
// add density here
   via2_ndiode_a_gndpadsideclose = SIZE via2_ndiode_a_gndpadsidex BY 1.5 OVERUNDER
   CONNECT  met2_met3_via2_ndiode_a_gndpadside via2_ndiode_a_gndpadsideclose
   ESDPATH_IOPAD_VSS_NFORWARD_DPATHVIA2_M2_M3 {@ N forward diode connected to IO cell does not have sufficient via2 density in path to VDD pad
                                               @  met2/met3 power bus overlap via2 spacing too large
        x = NET AREA RATIO met2_met3_via2_ndiode_a_gndpadside via2_ndiode_a_gndpadsideclose > 1  [ COUNT (via2_ndiode_a_gndpadsideclose) ]
        x AND met32_ndiode_a_gndpadside_ge30
   }
//
   via3_ndiode_a_gndpadsidex = via3_ndiode_a_gndpadside AND met3_met4_via3_ndiode_a_gndpadside
   CONNECT met3_met4_via3_ndiode_a_gndpadside via3_ndiode_a_gndpadsidex
   ESDPATH_IOPAD_VSS_NFORWARD_CPATHVIA3_M3_M4 {@ P forward diode connected to IO cell does not have 30 via3 path to VDD pad
                                                  @  on cathode side
                                                  @  met4/met3 power bus overlap via3 < 30
        x = NET AREA RATIO met3_met4_via3_ndiode_a_gndpadside  via3_ndiode_a_gndpadsidex < 30  [ COUNT ( via3_ndiode_a_gndpadsidex) ]
        x AND met43_ndiode_a_gndpadside_ge30
   }
//
// add density here
//
   via3_ndiode_a_gndpadsideclose = SIZE via3_ndiode_a_gndpadsidex BY 1.5 OVERUNDER
   CONNECT met3_met4_via3_ndiode_a_gndpadside via3_ndiode_a_gndpadsideclose
   ESDPATH_IOPAD_VSS_NFORWARD_DPATHVIA3_M3_M4 {@ N forward diode connected to IO cell does not have  sufficient via3 density in path to VDD pad
                                               @  met4/met3 power bus overlap via3 spacing too large
        x = NET AREA RATIO met3_met4_via3_ndiode_a_gndpadside  via3_ndiode_a_gndpadsideclose > 1 [ COUNT ( via3_ndiode_a_gndpadsideclose) ]
        x AND met43_ndiode_a_gndpadside_ge30
   }
//
#ENDIF  // end of via density check

///////////////////////////////////////////////////////////////////////
//
//  check with of met2/met3/met4 bus metal for pathes from GC_NMOS/GC_PMOS
//  to vdd/gnd pad
//
///////////////////////////////////////////////////////////////////////
//
//
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
//              process path gc_pmos to vdd pad  m3
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
//
// Fixed slot width = 3.0 3.0
//
//   WIDTH_M1SLOT_AMW1 { @ AMW1 metal1 Fixed slot width = 3.0
//   WIDTH_M2SLOT_AMW1 { @ AMW1 metal2 Fixed slot width = 3.0
//   WIDTH_M3SLOT_AMW1 { @ AMW1 metal3 Fixed slot width = 3.0
//   WIDTH_M4SLOT_AMW1 { @ AMW1 metal4 Fixed slot width = 3.0
//
   m3_gcps_vdd_m234ovlp = met2_met3_via2_gcpmos_s_vddpadside OR met3_met4_via3_gcpmos_s_vddpadside
   m3_gcps_vdd_x = COPY met3_gcpmos_s_vddpadside
//
// close slots
//
   m3_gcps_vdd_x1_holes = HOLES  m3_gcps_vdd_x INNER < 1000.0  // max slot 300 * 3 U
   m3_gcps_vdd_x1_holes_width = INT  m3_gcps_vdd_x1_holes <= 4.0 REGION
   m3_gcps_vdd_0 = m3_gcps_vdd_x OR  (m3_gcps_vdd_x1_holes INTERACT m3_gcps_vdd_x1_holes_width)
//
   m3_gcps_vdd_1  = ( SIZE m3_gcps_vdd_0 BY -1 ) OR m3_gcps_vdd_m234ovlp
   m3_gcps_vdd_2  = ( SIZE m3_gcps_vdd_1 BY -1 ) OR m3_gcps_vdd_m234ovlp
   m3_gcps_vdd_3  = ( SIZE m3_gcps_vdd_2 BY -1 ) OR m3_gcps_vdd_m234ovlp
   m3_gcps_vdd_4  = ( SIZE m3_gcps_vdd_3 BY -1 ) OR m3_gcps_vdd_m234ovlp
   m3_gcps_vdd_5  = ( SIZE m3_gcps_vdd_4 BY -1 ) OR m3_gcps_vdd_m234ovlp
   m3_gcps_vdd_6  = ( SIZE m3_gcps_vdd_5 BY -1 ) OR m3_gcps_vdd_m234ovlp
   m3_gcps_vdd_7  = ( SIZE m3_gcps_vdd_6 BY -1 ) OR m3_gcps_vdd_m234ovlp
   m3_gcps_vdd_8  = ( SIZE m3_gcps_vdd_7 BY -1 ) OR m3_gcps_vdd_m234ovlp
   m3_gcps_vdd_9  = ( SIZE m3_gcps_vdd_8 BY -1 ) OR m3_gcps_vdd_m234ovlp
   m3_gcps_vdd_10 = ( SIZE m3_gcps_vdd_9 BY -1 ) OR m3_gcps_vdd_m234ovlp
   m3_gcps_vdd_11 = ( SIZE m3_gcps_vdd_10 BY -1 ) OR m3_gcps_vdd_m234ovlp
   m3_gcps_vdd_12 = ( SIZE m3_gcps_vdd_11 BY -1 ) OR m3_gcps_vdd_m234ovlp
   m3_gcps_vdd_13 = ( SIZE m3_gcps_vdd_12 BY -1 ) OR m3_gcps_vdd_m234ovlp
   m3_gcps_vdd_14 = ( SIZE m3_gcps_vdd_13 BY -1 ) OR m3_gcps_vdd_m234ovlp
   m3_gcps_vdd_15 = ( SIZE m3_gcps_vdd_14 BY -0.9 ) OR m3_gcps_vdd_m234ovlp
//
   DISCONNECT
                                                                                                                                             
   CONNECT  met4_gcpmos_s_vddpadside  m3_gcps_vdd_15               BY via3_gcpmos_s_vddpadside
   CONNECT  m3_gcps_vdd_15                met2_gcpmos_s_vddpadside BY via2_gcpmos_s_vddpadside
   CONNECT  met2_gcpmos_s_vddpadside  met1_gcpmos_s_vddpadside BY via_gcpmos_s_vddpadside
   CONNECT  met1_gcpmos_s_vddpadside  gcpmos_s_vddpadside      BY pdiffcon_gcpmos_s_vddpadside
   CONNECT  met2_gcpmos_s_vddpadside  bondpad_vdd
//
// connected ?
//
   m3_gcpmos_s_vddpadside_pathvdd_open = NET AREA RATIO gcpmos_s_vddpadside bondpad_vdd == 0
   m3_gcps_vdd_15_open =  NET AREA RATIO m3_gcps_vdd_15  m3_gcpmos_s_vddpadside_pathvdd_open > 0
// get edge
   m3_gcps_vdd_15_openx = SIZE  m3_gcps_vdd_15_open BY 15 INSIDE OF  met3_gcpmos_s_vddpadside STEP 1
   m3_gcps_vdd_15_openy = EXPAND EDGE (m3_gcps_vdd_15_openx INSIDE EDGE  met3_gcpmos_s_vddpadside) BY 0.5
//
#IFDEF GCBUSWIDTHDEBUG
   m3_gcps_vdd_0 { FLATTEN m3_gcps_vdd_0 }
   m3_gcps_vdd_15 { FLATTEN m3_gcps_vdd_15 }
   m3_gcpmos_s_vddpadside_pathvdd_open { FLATTEN  m3_gcpmos_s_vddpadside_pathvdd_open }
   met3_gcpmos_s_vddpadside_open { FLATTEN  m3_gcps_vdd_15_open  }
   m3_gcps_vdd_15_openy { COPY m3_gcps_vdd_15_openy }
#ENDIF
//
   ESDPATH_IOPAD_VDD_GCPMOS_WIDTHPATHVDD_M3_30 {@  GC_PMOS  connected to IO cell does not have correct path width >= 30 U to VDD pad
                                                 @  met3 power bus smaller than 30 U
       x = NET AREA RATIO gcpmos_s_vddpadside bondpad_vdd == 0
       FLATTEN x
       FLATTEN  m3_gcps_vdd_15_openy
   }
//
//
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
//                process path gc_pmos  to vdd pad  m4
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
//
   m4_gcps_vdd_m34ovlp = COPY met3_met4_via3_gcpmos_s_vddpadside
   m4_gcps_vdd_x = COPY met4_gcpmos_s_vddpadside
//
// close slots
//
   m4_gcps_vdd_x1_holes = HOLES  m4_gcps_vdd_x INNER < 1000.0  // max slot 300 * 3 U
   m4_gcps_vdd_x1_holes_width = INT  m4_gcps_vdd_x1_holes <= 4.0 REGION
   m4_gcps_vdd_0 = m4_gcps_vdd_x OR  (m4_gcps_vdd_x1_holes INTERACT m4_gcps_vdd_x1_holes_width)
//
   m4_gcps_vdd_1  = ( SIZE m4_gcps_vdd_0 BY -1 ) OR m4_gcps_vdd_m34ovlp
   m4_gcps_vdd_2  = ( SIZE m4_gcps_vdd_1 BY -1 ) OR m4_gcps_vdd_m34ovlp
   m4_gcps_vdd_3  = ( SIZE m4_gcps_vdd_2 BY -1 ) OR m4_gcps_vdd_m34ovlp
   m4_gcps_vdd_4  = ( SIZE m4_gcps_vdd_3 BY -1 ) OR m4_gcps_vdd_m34ovlp
   m4_gcps_vdd_5  = ( SIZE m4_gcps_vdd_4 BY -1 ) OR m4_gcps_vdd_m34ovlp
   m4_gcps_vdd_6  = ( SIZE m4_gcps_vdd_5 BY -1 ) OR m4_gcps_vdd_m34ovlp
   m4_gcps_vdd_7  = ( SIZE m4_gcps_vdd_6 BY -1 ) OR m4_gcps_vdd_m34ovlp
   m4_gcps_vdd_8  = ( SIZE m4_gcps_vdd_7 BY -1 ) OR m4_gcps_vdd_m34ovlp
   m4_gcps_vdd_9  = ( SIZE m4_gcps_vdd_8 BY -1 ) OR m4_gcps_vdd_m34ovlp
   m4_gcps_vdd_10 = ( SIZE m4_gcps_vdd_9 BY -1 ) OR m4_gcps_vdd_m34ovlp
   m4_gcps_vdd_11 = ( SIZE m4_gcps_vdd_10 BY -1 ) OR m4_gcps_vdd_m34ovlp
   m4_gcps_vdd_12 = ( SIZE m4_gcps_vdd_11 BY -1 ) OR m4_gcps_vdd_m34ovlp
   m4_gcps_vdd_13 = ( SIZE m4_gcps_vdd_12 BY -1 ) OR m4_gcps_vdd_m34ovlp
   m4_gcps_vdd_14 = ( SIZE m4_gcps_vdd_13 BY -1 ) OR m4_gcps_vdd_m34ovlp
   m4_gcps_vdd_15 = ( SIZE m4_gcps_vdd_14 BY -0.9 ) OR m4_gcps_vdd_m34ovlp
//
   DISCONNECT
   CONNECT  met3_gcpmos_s_vddpadside  m4_gcps_vdd_15           BY via3_gcpmos_s_vddpadside
   CONNECT  met3_gcpmos_s_vddpadside  met2_gcpmos_s_vddpadside BY via2_gcpmos_s_vddpadside
   CONNECT  met2_gcpmos_s_vddpadside  met1_gcpmos_s_vddpadside BY via_gcpmos_s_vddpadside
   CONNECT  met1_gcpmos_s_vddpadside  gcpmos_s_vddpadside      BY pdiffcon_gcpmos_s_vddpadside
   CONNECT  met2_gcpmos_s_vddpadside  bondpad_vdd
//
// connected ?
//
   m4_gcpmos_s_vddpadside_pathvdd_open = NET AREA RATIO gcpmos_s_vddpadside bondpad_vdd == 0
   m4_gcps_vdd_15_open =  NET AREA RATIO m4_gcps_vdd_15  m4_gcpmos_s_vddpadside_pathvdd_open > 0
// get edge
   m4_gcps_vdd_15_openx = SIZE  m4_gcps_vdd_15_open BY 15 INSIDE OF  met4_gcpmos_s_vddpadside STEP 1
   m4_gcps_vdd_15_openy = EXPAND EDGE (m4_gcps_vdd_15_openx INSIDE EDGE  met4_gcpmos_s_vddpadside) BY 0.5
//
#IFDEF GCBUSWIDTHDEBUG
   m4_gcps_vdd_0 { FLATTEN m4_gcps_vdd_0 }
   m4_gcps_vdd_15 { FLATTEN m4_gcps_vdd_15 }
   m4_gcpmos_s_vddpadside_pathvdd_open { FLATTEN  m4_gcpmos_s_vddpadside_pathvdd_open }
   m4_gcps_vdd_15_openy { COPY m4_gcps_vdd_15_openy }
   met4_gcpmos_s_vddpadside_open { FLATTEN  m4_gcps_vdd_15_open  }
#ENDIF
//
   ESDPATH_IOPAD_VDD_GCPMOS_WIDTHPATHVDD_M4_30 {@ GC_PMOS connected to IO cell does not have correct path width >= 30 U to VDD pad
                                                @  met4 power bus smaller than 30 U
       x = NET AREA RATIO gcpmos_s_vddpadside bondpad_vdd == 0
       FLATTEN x
       FLATTEN  m4_gcps_vdd_15_openy
   }
//
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
//                  process path gcpmos to vdd pad  m2
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
//
   m2_gcps_vdd_m123ovlp = met2_met3_via2_gcpmos_s_vddpadside OR met1_met2_via_gcpmos_s_vddpadside
   m2_gcps_vdd_x = COPY met2_gcpmos_s_vddpadside
//
// close slots
//
   m2_gcps_vdd_x1_holes = HOLES  m2_gcps_vdd_x INNER < 1000.0  // max slot 300 * 3 U
   m2_gcps_vdd_x1_holes_width = INT  m2_gcps_vdd_x1_holes <= 4.0 REGION
   m2_gcps_vdd_0 = m2_gcps_vdd_x OR  (m2_gcps_vdd_x1_holes INTERACT m2_gcps_vdd_x1_holes_width)
//
   m2_gcps_vdd_1  = ( SIZE m2_gcps_vdd_0 BY -1 ) OR m2_gcps_vdd_m123ovlp
   m2_gcps_vdd_2  = ( SIZE m2_gcps_vdd_1 BY -1 ) OR m2_gcps_vdd_m123ovlp
   m2_gcps_vdd_3  = ( SIZE m2_gcps_vdd_2 BY -1 ) OR m2_gcps_vdd_m123ovlp
   m2_gcps_vdd_4  = ( SIZE m2_gcps_vdd_3 BY -1 ) OR m2_gcps_vdd_m123ovlp
   m2_gcps_vdd_5  = ( SIZE m2_gcps_vdd_4 BY -1 ) OR m2_gcps_vdd_m123ovlp
   m2_gcps_vdd_6  = ( SIZE m2_gcps_vdd_5 BY -1 ) OR m2_gcps_vdd_m123ovlp
   m2_gcps_vdd_7  = ( SIZE m2_gcps_vdd_6 BY -1 ) OR m2_gcps_vdd_m123ovlp
   m2_gcps_vdd_8  = ( SIZE m2_gcps_vdd_7 BY -1 ) OR m2_gcps_vdd_m123ovlp
   m2_gcps_vdd_9  = ( SIZE m2_gcps_vdd_8 BY -1 ) OR m2_gcps_vdd_m123ovlp
   m2_gcps_vdd_10 = ( SIZE m2_gcps_vdd_9 BY -1 ) OR m2_gcps_vdd_m123ovlp
   m2_gcps_vdd_11 = ( SIZE m2_gcps_vdd_10 BY -1 ) OR m2_gcps_vdd_m123ovlp
   m2_gcps_vdd_12 = ( SIZE m2_gcps_vdd_11 BY -1 ) OR m2_gcps_vdd_m123ovlp
   m2_gcps_vdd_13 = ( SIZE m2_gcps_vdd_12 BY -1 ) OR m2_gcps_vdd_m123ovlp
   m2_gcps_vdd_14 = ( SIZE m2_gcps_vdd_13 BY -1 ) OR m2_gcps_vdd_m123ovlp
   m2_gcps_vdd_15 = ( SIZE m2_gcps_vdd_14 BY -0.9 ) OR m2_gcps_vdd_m123ovlp
//
//
   DISCONNECT
   CONNECT  met4_gcpmos_s_vddpadside  met3_gcpmos_s_vddpadside BY via3_gcpmos_s_vddpadside
   CONNECT  m2_gcps_vdd_15            met3_gcpmos_s_vddpadside BY via2_gcpmos_s_vddpadside
   CONNECT  m2_gcps_vdd_15            met1_gcpmos_s_vddpadside BY via_gcpmos_s_vddpadside
   CONNECT  met1_gcpmos_s_vddpadside  gcpmos_s_vddpadside      BY pdiffcon_gcpmos_s_vddpadside
   CONNECT  m2_gcps_vdd_15            bondpad_vdd
//
// connected ?
//
   m2_gcpmos_s_vddpadside_pathvdd_open = NET AREA RATIO gcpmos_s_vddpadside bondpad_vdd == 0
   m2_gcps_vdd_15_open =  NET AREA RATIO m2_gcps_vdd_15  m2_gcpmos_s_vddpadside_pathvdd_open > 0
// get edge
   m2_gcps_vdd_15_openx = SIZE  m2_gcps_vdd_15_open BY 15 INSIDE OF  met2_gcpmos_s_vddpadside STEP 1
   m2_gcps_vdd_15_openy = EXPAND EDGE (m2_gcps_vdd_15_openx INSIDE EDGE  met2_gcpmos_s_vddpadside) BY 0.5
//
#IFDEF GCBUSWIDTHDEBUG
// original and undersized metal
   m2_gcps_vdd_0 { FLATTEN m2_gcps_vdd_0 }
   m2_gcps_vdd_15 { FLATTEN m2_gcps_vdd_15 }
   m2_gcpmos_s_vddpadside_pathvdd_open { FLATTEN  m2_gcpmos_s_vddpadside_pathvdd_open }
   met2_gcpmos_s_vddpadside_open { FLATTEN  m2_gcps_vdd_15_open  }
   m2_gcps_vdd_15_openy { COPY m2_gcps_vdd_15_openy }
#ENDIF
//
   ESDPATH_IOPAD_VDD_GCPMOS_WIDTHPATHVDD_M2_30 {@ GC_PMOS connected to IO cell does not have path width >= 30 U to VDD pad
                                                @ met2 power bus smaller than 30 U
       x = NET AREA RATIO gcpmos_s_vddpadside bondpad_vdd == 0
       FLATTEN x
       FLATTEN  m2_gcps_vdd_15_openy
   }
//
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
//                process path gc_mos to gnd pad m4
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
//
   m4_gcns_gnd_m34ovlp = COPY met3_met4_via3_gcnmos_s_gndpadside
   m4_gcns_gnd_x = COPY met4_gcnmos_s_gndpadside
//
// close slots
//
   m4_gcns_gnd_x1_holes = HOLES  m4_gcns_gnd_x INNER < 1000.0  // max slot 300 * 3 U
//
   m4_gcns_gnd_x1_holes_width = INT  m4_gcns_gnd_x1_holes <= 4.0 REGION
   m4_gcns_gnd_0 = m4_gcns_gnd_x OR  (m4_gcns_gnd_x1_holes INTERACT m4_gcns_gnd_x1_holes_width)
//
   m4_gcns_gnd_1  = ( SIZE m4_gcns_gnd_0 BY -1 ) OR m4_gcns_gnd_m34ovlp
   m4_gcns_gnd_2  = ( SIZE m4_gcns_gnd_1 BY -1 ) OR m4_gcns_gnd_m34ovlp
   m4_gcns_gnd_3  = ( SIZE m4_gcns_gnd_2 BY -1 ) OR m4_gcns_gnd_m34ovlp
   m4_gcns_gnd_4  = ( SIZE m4_gcns_gnd_3 BY -1 ) OR m4_gcns_gnd_m34ovlp
   m4_gcns_gnd_5  = ( SIZE m4_gcns_gnd_4 BY -1 ) OR m4_gcns_gnd_m34ovlp
   m4_gcns_gnd_6  = ( SIZE m4_gcns_gnd_5 BY -1 ) OR m4_gcns_gnd_m34ovlp
   m4_gcns_gnd_7  = ( SIZE m4_gcns_gnd_6 BY -1 ) OR m4_gcns_gnd_m34ovlp
   m4_gcns_gnd_8  = ( SIZE m4_gcns_gnd_7 BY -1 ) OR m4_gcns_gnd_m34ovlp
   m4_gcns_gnd_9  = ( SIZE m4_gcns_gnd_8 BY -1 ) OR m4_gcns_gnd_m34ovlp
   m4_gcns_gnd_10 = ( SIZE m4_gcns_gnd_9 BY -1 ) OR m4_gcns_gnd_m34ovlp
   m4_gcns_gnd_11 = ( SIZE m4_gcns_gnd_10 BY -1 ) OR m4_gcns_gnd_m34ovlp
   m4_gcns_gnd_12 = ( SIZE m4_gcns_gnd_11 BY -1 ) OR m4_gcns_gnd_m34ovlp
   m4_gcns_gnd_13 = ( SIZE m4_gcns_gnd_12 BY -1 ) OR m4_gcns_gnd_m34ovlp
   m4_gcns_gnd_14 = ( SIZE m4_gcns_gnd_13 BY -1 ) OR m4_gcns_gnd_m34ovlp
   m4_gcns_gnd_15 = ( SIZE m4_gcns_gnd_14 BY -0.9 ) OR m4_gcns_gnd_m34ovlp
//
   DISCONNECT
   CONNECT  met3_gcnmos_s_gndpadside  m4_gcns_gnd_15           BY via3_gcnmos_s_gndpadside
   CONNECT  met3_gcnmos_s_gndpadside  met2_gcnmos_s_gndpadside BY via2_gcnmos_s_gndpadside
   CONNECT  met2_gcnmos_s_gndpadside  met1_gcnmos_s_gndpadside BY via_gcnmos_s_gndpadside
   CONNECT  met1_gcnmos_s_gndpadside  gcnmos_s_gndpadside      BY ndiffcon_gcnmos_s_gndpadside
   CONNECT  met2_gcnmos_s_gndpadside  bondpad_gnd
//
// connected ?
//
   m4_gcnmos_s_gndpadside_pathgnd_open = NET AREA RATIO gcnmos_s_gndpadside bondpad_gnd == 0
   m4_gcns_gnd_15_open =  NET AREA RATIO m4_gcns_gnd_15  m4_gcnmos_s_gndpadside_pathgnd_open > 0
// get edge
   m4_gcns_gnd_15_openx = SIZE  m4_gcns_gnd_15_open BY 15 INSIDE OF  met4_gcnmos_s_gndpadside STEP 1
   m4_gcns_gnd_15_openy = EXPAND EDGE (m4_gcns_gnd_15_openx INSIDE EDGE  met4_gcnmos_s_gndpadside) BY 0.5
//
#IFDEF GCBUSWIDTHDEBUG
   m4_gcns_gnd_0 { FLATTEN m4_gcns_gnd_0 }
   m4_gcns_gnd_15 { FLATTEN m4_gcns_gnd_15 }
   m4_gcnmos_s_gndpadside_pathgnd_open { FLATTEN  m4_gcnmos_s_gndpadside_pathgnd_open }
   m4_gcns_gnd_15_openy { COPY m4_gcns_gnd_15_openy }
   met4_gcnmos_s_gndpadside_open { FLATTEN  m4_gcns_gnd_15_open  }
#ENDIF
//
   ESDPATH_IOPAD_VSS_GCNMOS_WIDTHPATHVSS_M4_30 {@ GC_NMOS connected to IO cell does not have path >=30 to GND pad
                                               @  met4 power bus smaller than 30 U
       x = NET AREA RATIO gcnmos_s_gndpadside bondpad_gnd == 0
       FLATTEN x
       FLATTEN  m4_gcns_gnd_15_openy
   }
//
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
//                process path vss forward to gnd pad m3
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
//
   m3_gcns_gnd_m234ovlp = met2_met3_via2_gcnmos_s_gndpadside OR met3_met4_via3_gcnmos_s_gndpadside
   m3_gcns_gnd_x = COPY met3_gcnmos_s_gndpadside
//
// close slots
//
   m3_gcns_gnd_x1_holes = HOLES  m3_gcns_gnd_x INNER < 1000.0  // max slot 300 * 3 U
   m3_gcns_gnd_x1_holes_width = INT  m3_gcns_gnd_x1_holes <= 4.0 REGION
   m3_gcns_gnd_0 = m3_gcns_gnd_x OR  (m3_gcns_gnd_x1_holes INTERACT m3_gcns_gnd_x1_holes_width)
//
   m3_gcns_gnd_1  = ( SIZE m3_gcns_gnd_0 BY -1 ) OR m3_gcns_gnd_m234ovlp
   m3_gcns_gnd_2  = ( SIZE m3_gcns_gnd_1 BY -1 ) OR m3_gcns_gnd_m234ovlp
   m3_gcns_gnd_3  = ( SIZE m3_gcns_gnd_2 BY -1 ) OR m3_gcns_gnd_m234ovlp
   m3_gcns_gnd_4  = ( SIZE m3_gcns_gnd_3 BY -1 ) OR m3_gcns_gnd_m234ovlp
   m3_gcns_gnd_5  = ( SIZE m3_gcns_gnd_4 BY -1 ) OR m3_gcns_gnd_m234ovlp
   m3_gcns_gnd_6  = ( SIZE m3_gcns_gnd_5 BY -1 ) OR m3_gcns_gnd_m234ovlp
   m3_gcns_gnd_7  = ( SIZE m3_gcns_gnd_6 BY -1 ) OR m3_gcns_gnd_m234ovlp
   m3_gcns_gnd_8  = ( SIZE m3_gcns_gnd_7 BY -1 ) OR m3_gcns_gnd_m234ovlp
   m3_gcns_gnd_9  = ( SIZE m3_gcns_gnd_8 BY -1 ) OR m3_gcns_gnd_m234ovlp
   m3_gcns_gnd_10 = ( SIZE m3_gcns_gnd_9 BY -1 ) OR m3_gcns_gnd_m234ovlp
   m3_gcns_gnd_11 = ( SIZE m3_gcns_gnd_10 BY -1 ) OR m3_gcns_gnd_m234ovlp
   m3_gcns_gnd_12 = ( SIZE m3_gcns_gnd_11 BY -1 ) OR m3_gcns_gnd_m234ovlp
   m3_gcns_gnd_13 = ( SIZE m3_gcns_gnd_12 BY -1 ) OR m3_gcns_gnd_m234ovlp
   m3_gcns_gnd_14 = ( SIZE m3_gcns_gnd_13 BY -1 ) OR m3_gcns_gnd_m234ovlp
   m3_gcns_gnd_15 = ( SIZE m3_gcns_gnd_14 BY -0.9 ) OR m3_gcns_gnd_m234ovlp
//
   DISCONNECT
//
   CONNECT  met4_gcnmos_s_gndpadside  m3_gcns_gnd_15               BY via3_gcnmos_s_gndpadside
   CONNECT  m3_gcns_gnd_15            met2_gcnmos_s_gndpadside     BY via2_gcnmos_s_gndpadside
   CONNECT  met2_gcnmos_s_gndpadside  met1_gcnmos_s_gndpadside     BY via_gcnmos_s_gndpadside
   CONNECT  met1_gcnmos_s_gndpadside  gcnmos_s_gndpadside          BY ndiffcon_gcnmos_s_gndpadside
   CONNECT  met2_gcnmos_s_gndpadside  bondpad_gnd
//
// connected ?
//
   m3_gcnmos_s_gndpadside_pathgnd_open = NET AREA RATIO gcnmos_s_gndpadside bondpad_gnd == 0
   m3_gcns_gnd_15_open =  NET AREA RATIO m3_gcns_gnd_15  m3_gcnmos_s_gndpadside_pathgnd_open > 0
// get edge
   m3_gcns_gnd_15_openx = SIZE  m3_gcns_gnd_15_open BY 15 INSIDE OF  met3_gcnmos_s_gndpadside STEP 1
   m3_gcns_gnd_15_openy = EXPAND EDGE (m3_gcns_gnd_15_openx INSIDE EDGE  met3_gcnmos_s_gndpadside) BY 0.5
//
#IFDEF GCBUSWIDTHDEBUG
   m3_gcns_gnd_0 { FLATTEN m3_gcns_gnd_0 }
   m3_gcns_gnd_15 { FLATTEN m3_gcns_gnd_15 }
   m3_gcnmos_s_gndpadside_pathgnd_open { FLATTEN  m3_gcnmos_s_gndpadside_pathgnd_open }
   met3_gcnmos_s_gndpadside_open { FLATTEN  m3_gcns_gnd_15_open  }
   m3_gcns_gnd_15_openy { COPY m3_gcns_gnd_15_openy }
#ENDIF
//
   ESDPATH_IOPAD_VSS_GCNMOS_WIDTHPATHVSS_M3_30 {@ GC_NMOS connected to IO cell does not have path >=30 U to GND pad
                                               @  met3 power bus smaller than 30 U
       x = NET AREA RATIO gcnmos_s_gndpadside bondpad_gnd == 0
       FLATTEN x
       FLATTEN  m3_gcns_gnd_15_openy
   }
//
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
//                   process path gc_nmos to gnd pad m2
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
//
   m2_gcns_gnd_m123ovlp = met2_met3_via2_gcnmos_s_gndpadside OR met1_met2_via_gcnmos_s_gndpadside
   m2_gcns_gnd_x = COPY met2_gcnmos_s_gndpadside
//
// close slots
//
   m2_gcns_gnd_x1_holes = HOLES  m2_gcns_gnd_x INNER < 1000.0  // max slot 300 * 3 U
   m2_gcns_gnd_x1_holes_width = INT  m2_gcns_gnd_x1_holes <= 4.0 REGION
   m2_gcns_gnd_0 = m2_gcns_gnd_x OR  (m2_gcns_gnd_x1_holes INTERACT m2_gcns_gnd_x1_holes_width)
//
   m2_gcns_gnd_1  = ( SIZE m2_gcns_gnd_0 BY -1 ) OR m2_gcns_gnd_m123ovlp
   m2_gcns_gnd_2  = ( SIZE m2_gcns_gnd_1 BY -1 ) OR m2_gcns_gnd_m123ovlp
   m2_gcns_gnd_3  = ( SIZE m2_gcns_gnd_2 BY -1 ) OR m2_gcns_gnd_m123ovlp
   m2_gcns_gnd_4  = ( SIZE m2_gcns_gnd_3 BY -1 ) OR m2_gcns_gnd_m123ovlp
   m2_gcns_gnd_5  = ( SIZE m2_gcns_gnd_4 BY -1 ) OR m2_gcns_gnd_m123ovlp
   m2_gcns_gnd_6  = ( SIZE m2_gcns_gnd_5 BY -1 ) OR m2_gcns_gnd_m123ovlp
   m2_gcns_gnd_7  = ( SIZE m2_gcns_gnd_6 BY -1 ) OR m2_gcns_gnd_m123ovlp
   m2_gcns_gnd_8  = ( SIZE m2_gcns_gnd_7 BY -1 ) OR m2_gcns_gnd_m123ovlp
   m2_gcns_gnd_9  = ( SIZE m2_gcns_gnd_8 BY -1 ) OR m2_gcns_gnd_m123ovlp
   m2_gcns_gnd_10 = ( SIZE m2_gcns_gnd_9 BY -1 ) OR m2_gcns_gnd_m123ovlp
   m2_gcns_gnd_11 = ( SIZE m2_gcns_gnd_10 BY -1 ) OR m2_gcns_gnd_m123ovlp
   m2_gcns_gnd_12 = ( SIZE m2_gcns_gnd_11 BY -1 ) OR m2_gcns_gnd_m123ovlp
   m2_gcns_gnd_13 = ( SIZE m2_gcns_gnd_12 BY -1 ) OR m2_gcns_gnd_m123ovlp
   m2_gcns_gnd_14 = ( SIZE m2_gcns_gnd_13 BY -1 ) OR m2_gcns_gnd_m123ovlp
   m2_gcns_gnd_15 = ( SIZE m2_gcns_gnd_14 BY -0.9 ) OR m2_gcns_gnd_m123ovlp
//
   DISCONNECT
   CONNECT  met4_gcnmos_s_gndpadside  met3_gcnmos_s_gndpadside BY via3_gcnmos_s_gndpadside
   CONNECT  m2_gcns_gnd_15            met3_gcnmos_s_gndpadside BY via2_gcnmos_s_gndpadside
   CONNECT  m2_gcns_gnd_15            met1_gcnmos_s_gndpadside BY via_gcnmos_s_gndpadside
   CONNECT  met1_gcnmos_s_gndpadside  gcnmos_s_gndpadside      BY ndiffcon_gcnmos_s_gndpadside
   CONNECT  m2_gcns_gnd_15            bondpad_gnd
//
// connected ?
//
   m2_gcnmos_s_gndpadside_pathgnd_open = NET AREA RATIO gcnmos_s_gndpadside bondpad_gnd == 0
   m2_gcns_gnd_15_open =  NET AREA RATIO m2_gcns_gnd_15  m2_gcnmos_s_gndpadside_pathgnd_open > 0
// get edge
   m2_gcns_gnd_15_openx = SIZE  m2_gcns_gnd_15_open BY 15 INSIDE OF  met2_gcnmos_s_gndpadside STEP 1
   m2_gcns_gnd_15_openy = EXPAND EDGE (m2_gcns_gnd_15_openx INSIDE EDGE  met2_gcnmos_s_gndpadside) BY 0.5
//
#IFDEF GCBUSWIDTHDEBUG
// original and undersized metal
   m2_gcns_gnd_0 { FLATTEN m2_gcns_gnd_0 }
   m2_gcns_gnd_15 { FLATTEN m2_gcns_gnd_15 }
   m2_gcnmos_s_gndpadside_pathgnd_open { FLATTEN  m2_gcnmos_s_gndpadside_pathgnd_open }
   met2_gcnmos_s_gndpadside_open { FLATTEN  m2_gcns_gnd_15_open  }
   m2_gcns_gnd_15_openy { COPY m2_gcns_gnd_15_openy }
#ENDIF
//
   ESDPATH_IOPAD_VSS_GCNMOS_WIDTHPATHVSS_M2_30 {@ GC_NMOS connected to IO cell does not have path >=30 U to GND pad
                                                @ met2 power bus smaller than 30 U
       x = NET AREA RATIO gcnmos_s_gndpadside bondpad_gnd == 0
       FLATTEN x
       FLATTEN  m2_gcns_gnd_15_openy
   }
//
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
//
//        check for via count on transition of path gc_nmos/gc_pmos to pad
//
//xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

// close slots before width check
//
   met1_gcpmos_s_vddpadside_h   =  HOLES  met1_gcpmos_s_vddpadside INNER < 1000.0  // max slot 300 * 3 U
   met1_gcpmos_s_vddpadside_h1  =  INT met1_gcpmos_s_vddpadside_h <= 4.0 REGION
   met1_gcpmos_s_vddpadside_c   = met1_gcpmos_s_vddpadside OR (met1_gcpmos_s_vddpadside_h INTERACT  met1_gcpmos_s_vddpadside_h1)
//
   met3_gcpmos_s_vddpadside_h   =  HOLES  met3_gcpmos_s_vddpadside INNER < 1000.0  // max slot 300 * 3 U
   met3_gcpmos_s_vddpadside_h1  =  INT met3_gcpmos_s_vddpadside_h <= 4.0 REGION
   met3_gcpmos_s_vddpadside_c   = met3_gcpmos_s_vddpadside OR (met3_gcpmos_s_vddpadside_h INTERACT  met3_gcpmos_s_vddpadside_h1)
//
   met2_gcpmos_s_vddpadside_h   =  HOLES  met2_gcpmos_s_vddpadside INNER < 1000.0  // max slot 300 * 3 U
   met2_gcpmos_s_vddpadside_h1  =  INT met2_gcpmos_s_vddpadside_h <= 4.0 REGION
   met2_gcpmos_s_vddpadside_c   = met2_gcpmos_s_vddpadside OR (met2_gcpmos_s_vddpadside_h INTERACT  met2_gcpmos_s_vddpadside_h1)
//
   met4_gcpmos_s_vddpadside_h   =  HOLES  met4_gcpmos_s_vddpadside INNER < 1000.0  // max slot 300 * 3 U
   met4_gcpmos_s_vddpadside_h1  =  INT met4_gcpmos_s_vddpadside_h <= 4.0 REGION
   met4_gcpmos_s_vddpadside_c   = met4_gcpmos_s_vddpadside OR (met4_gcpmos_s_vddpadside_h INTERACT  met4_gcpmos_s_vddpadside_h1)
//
// closed slots
//
   met4_gcpmos_s_vddpadside_ge30 = WITH WIDTH met4_gcpmos_s_vddpadside_c >= 30
   met3_gcpmos_s_vddpadside_ge30 = WITH WIDTH met3_gcpmos_s_vddpadside_c >= 30
   met2_gcpmos_s_vddpadside_ge30 = WITH WIDTH met2_gcpmos_s_vddpadside_c >= 30
   met1_gcpmos_s_vddpadside_ge30 = WITH WIDTH met1_gcpmos_s_vddpadside_c >= 30
//
// overlapping
//
   met43_gcpmos_s_vddpadside_ge30 =  met4_gcpmos_s_vddpadside_ge30 AND  met3_gcpmos_s_vddpadside_ge30 
   met32_gcpmos_s_vddpadside_ge30 =  met3_gcpmos_s_vddpadside_ge30 AND  met2_gcpmos_s_vddpadside_ge30 
   met21_gcpmos_s_vddpadside_ge30 =  met2_gcpmos_s_vddpadside_ge30 AND  met1_gcpmos_s_vddpadside_ge30 
//
#IFDEF GET_MET_GC_PATH
   met4_gcpmos_s_vddpadside_ge30  { FLATTEN  met4_gcpmos_s_vddpadside_ge30 }
   met3_gcpmos_s_vddpadside_ge30  { FLATTEN  met3_gcpmos_s_vddpadside_ge30 }
   met2_gcpmos_s_vddpadside_ge30  { FLATTEN  met2_gcpmos_s_vddpadside_ge30 }
   met1_gcpmos_s_vddpadside_ge30  { FLATTEN  met1_gcpmos_s_vddpadside_ge30 }
#ENDIF
//   met43_gcpmos_s_vddpadside_ge30  { FLATTEN  met43_gcpmos_s_vddpadside_ge30 }
//   met32_gcpmos_s_vddpadside_ge30  { FLATTEN  met32_gcpmos_s_vddpadside_ge30 }
//   met21_gcpmos_s_vddpadside_ge30  { FLATTEN  met21_gcpmos_s_vddpadside_ge30 }
//
// close slots before width check
//
   met1_gcnmos_s_gndpadside_h   =  HOLES  met1_gcnmos_s_gndpadside INNER < 1000.0  // max slot 300 * 3 U
   met1_gcnmos_s_gndpadside_h1  =  INT met1_gcnmos_s_gndpadside_h <= 4.0 REGION
   met1_gcnmos_s_gndpadside_c   = met1_gcnmos_s_gndpadside OR (met1_gcnmos_s_gndpadside_h INTERACT  met1_gcnmos_s_gndpadside_h1)
//
   met3_gcnmos_s_gndpadside_h   =  HOLES  met3_gcnmos_s_gndpadside INNER < 1000.0  // max slot 300 * 3 U
   met3_gcnmos_s_gndpadside_h1  =  INT met3_gcnmos_s_gndpadside_h <= 4.0 REGION
   met3_gcnmos_s_gndpadside_c   = met3_gcnmos_s_gndpadside OR (met3_gcnmos_s_gndpadside_h INTERACT  met3_gcnmos_s_gndpadside_h1)
//
   met2_gcnmos_s_gndpadside_h   =  HOLES  met2_gcnmos_s_gndpadside INNER < 1000.0  // max slot 300 * 3 U
   met2_gcnmos_s_gndpadside_h1  =  INT met2_gcnmos_s_gndpadside_h <= 4.0 REGION
   met2_gcnmos_s_gndpadside_c   = met2_gcnmos_s_gndpadside OR (met2_gcnmos_s_gndpadside_h INTERACT  met2_gcnmos_s_gndpadside_h1)
//
   met4_gcnmos_s_gndpadside_h   =  HOLES  met4_gcnmos_s_gndpadside INNER < 1000.0  // max slot 300 * 3 U
   met4_gcnmos_s_gndpadside_h1  =  INT met4_gcnmos_s_gndpadside_h <= 4.0 REGION
   met4_gcnmos_s_gndpadside_c   = met4_gcnmos_s_gndpadside OR (met4_gcnmos_s_gndpadside_h INTERACT  met4_gcnmos_s_gndpadside_h1)
//
// closed slots
//
   met4_gcnmos_s_gndpadside_ge30 = WITH WIDTH met4_gcnmos_s_gndpadside_c >= 30
   met3_gcnmos_s_gndpadside_ge30 = WITH WIDTH met3_gcnmos_s_gndpadside_c >= 30
   met2_gcnmos_s_gndpadside_ge30 = WITH WIDTH met2_gcnmos_s_gndpadside_c >= 30
   met1_gcnmos_s_gndpadside_ge30 = WITH WIDTH met1_gcnmos_s_gndpadside_c >= 30
//
// overlapping
//
   met43_gcnmos_s_gndpadside_ge30 =  met4_gcnmos_s_gndpadside_ge30 AND met3_gcnmos_s_gndpadside_ge30
   met32_gcnmos_s_gndpadside_ge30 =  met3_gcnmos_s_gndpadside_ge30 AND met2_gcnmos_s_gndpadside_ge30
   met21_gcnmos_s_gndpadside_ge30 =  met2_gcnmos_s_gndpadside_ge30 AND met1_gcnmos_s_gndpadside_ge30
//
#IFDEF GET_MET_GC_PATH
   met4_gcnmos_s_gndpadside_ge30  { FLATTEN  met4_gcnmos_s_gndpadside_ge30 }
   met3_gcnmos_s_gndpadside_ge30  { FLATTEN  met3_gcnmos_s_gndpadside_ge30 }
   met2_gcnmos_s_gndpadside_ge30  { FLATTEN  met2_gcnmos_s_gndpadside_ge30 }
   met1_gcnmos_s_gndpadside_ge30  { FLATTEN  met1_gcnmos_s_gndpadside_ge30 }
#ENDIF
//   met43_gcnmos_s_gndpadside_ge30  { FLATTEN  met43_gcnmos_s_gndpadside_ge30 }
//   met32_gcnmos_s_gndpadside_ge30  { FLATTEN  met32_gcnmos_s_gndpadside_ge30 }
//   met21_gcnmos_s_gndpadside_ge30  { FLATTEN  met21_gcnmos_s_gndpadside_ge30 }
//
#DEFINE GCBUS_METAL_VIA_CHECK
#IFDEF GCBUS_METAL_VIA_CHECK
//
// minimum count of vias for one metal change is 30
// add size by 1.5 overunder and check in closed area
//
// check path of gc_pmos to vdd pad
//--------------------------------------
//
   DISCONNECT
//
// create new connect with undersized metal2/3/4
//
   via3_gcpmos_s_vddpadside_15 = via3_gcpmos_s_vddpadside AND ( m3_gcps_vdd_15 AND m4_gcps_vdd_15 )
   via2_gcpmos_s_vddpadside_15 = via2_gcpmos_s_vddpadside AND ( m3_gcps_vdd_15 AND m2_gcps_vdd_15 )
   via_gcpmos_s_vddpadside_15  = via_gcpmos_s_vddpadside AND  ( m2_gcps_vdd_15 AND met1_gcpmos_s_vddpadside)
//
   CONNECT  m3_gcps_vdd_15 m4_gcps_vdd_15 BY via3_gcpmos_s_vddpadside_15
   CONNECT  m3_gcps_vdd_15 m2_gcps_vdd_15 BY via2_gcpmos_s_vddpadside_15
   CONNECT  m2_gcps_vdd_15 met1_gcpmos_s_vddpadside BY via_gcpmos_s_vddpadside_15
   CONNECT  met1_gcpmos_s_vddpadside  gcpmos_s_vddpadside  BY pdiffcon_gcpmos_s_vddpadside
   CONNECT  m2_gcps_vdd_15  bondpad_vdd
//
// m1/m2 ovlp
//----------------------
//----------------------
#DEFINE CHECK_VIA
#IFDEF CHECK_VIA
//
   met1_met2_via_gcpmos_s_vddpadside_x =  m2_gcps_vdd_15 AND met1_gcpmos_s_vddpadside
   via_gcpmos_s_vddpadside_x = via_gcpmos_s_vddpadside_15 AND met1_met2_via_gcpmos_s_vddpadside_x
//
// met1_met2_via_gcpmos_s_vddpadside_x { FLATTEN  met1_met2_via_gcpmos_s_vddpadside_x }
// via_gcpmos_s_vddpadside_x { FLATTEN via_gcpmos_s_vddpadside_x }
// xxxx =  NET AREA RATIO  via_gcpmos_s_vddpadside_x gcpmos_s_vddpadside > 0
// xxxx { FLATTEN xxxx }
// yyyyy { FLATTEN ( m4_gcps_vdd_15 OR ( m3_gcps_vdd_15 OR  m2_gcps_vdd_15)) }
//
   CONNECT  met1_met2_via_gcpmos_s_vddpadside_x via_gcpmos_s_vddpadside_x
   ESDPATH_IOPAD_VDD_GCPMOS_CPATHVIA_M1_M2 {@ GC_PMOS  connected to IO cell does not have 30 via path to VDD pad
                                            @ met1/met2 power bus overlap via < 30
        x = NET AREA RATIO met1_met2_via_gcpmos_s_vddpadside_x via_gcpmos_s_vddpadside_x < 30  [ COUNT (via_gcpmos_s_vddpadside_x) ]
        //x INTERACT met1_gcpmos_s_vddpadside_ge30 
        //x INTERACT met2_gcpmos_s_vddpadside_ge30 
        x INTERACT met21_gcpmos_s_vddpadside_ge30
   }
//
   via_gcpmos_s_vddpadsideclose = SIZE via_gcpmos_s_vddpadside_x BY 1.5 OVERUNDER
   CONNECT  met1_met2_via_gcpmos_s_vddpadside_x  via_gcpmos_s_vddpadsideclose
   ESDPATH_IOPAD_VDD_GCPMOS_DPATHVIA_M1_M2 {@ GC_PMOS  connected to IO cell does not have sufficient via density in path to VDD pad
                                            @ met1/met2 power bus overlap via spacing too large
        x = NET AREA RATIO met1_met2_via_gcpmos_s_vddpadside_x via_gcpmos_s_vddpadsideclose > 1  [ COUNT (via_gcpmos_s_vddpadsideclose) ]
        //x INTERACT met1_gcpmos_s_vddpadside_ge30 
        //x INTERACT met2_gcpmos_s_vddpadside_ge30 
        x INTERACT met21_gcpmos_s_vddpadside_ge30 
   }
#ENDIF
//----------------------
//----------------------
// m2/m3 ovlp
//
   met2_met3_via2_gcpmos_s_vddpadside_x =  m2_gcps_vdd_15 AND m3_gcps_vdd_15
   via2_gcpmos_s_vddpadside_x = via2_gcpmos_s_vddpadside_15 AND met2_met3_via2_gcpmos_s_vddpadside_x
   CONNECT  met2_met3_via2_gcpmos_s_vddpadside_x via2_gcpmos_s_vddpadside_x
   ESDPATH_IOPAD_VDD_GCPMOS_CPATHVIA2_M2_M3 {@ GC_PMOS connected to IO cell does not have 30 via2 path to VDD pad
                                             @ met2/met3 power bus overlap via2 < 30
        x = NET AREA RATIO met2_met3_via2_gcpmos_s_vddpadside_x via2_gcpmos_s_vddpadside_x < 30  [ COUNT (via2_gcpmos_s_vddpadside_x) ]
        //x INTERACT met2_gcpmos_s_vddpadside_ge30 
        //x INTERACT met3_gcpmos_s_vddpadside_ge30 
        x INTERACT met32_gcpmos_s_vddpadside_ge30 
   }
   via2_gcpmos_s_vddpadsideclose = SIZE via2_gcpmos_s_vddpadside_x BY 1.5 OVERUNDER
   CONNECT  met2_met3_via2_gcpmos_s_vddpadside via2_gcpmos_s_vddpadsideclose
   ESDPATH_IOPAD_VDD_GCPMOS_DPATHVIA2_M2_M3 {@ GC_PMOS connected to IO cell does not have sufficient via2 density in path to VDD pad
                                             @ met2/met3 power bus overlap via2 spacing too large
        x = NET AREA RATIO met2_met3_via2_gcpmos_s_vddpadside_x via2_gcpmos_s_vddpadsideclose > 1  [ COUNT (via2_gcpmos_s_vddpadsideclose) ]
        //x INTERACT met2_gcpmos_s_vddpadside_ge30 
        //x INTERACT met3_gcpmos_s_vddpadside_ge30 
        x INTERACT met32_gcpmos_s_vddpadside_ge30 
   }
//------------------------------
//----------------------
// m3/m4 ovlp
//
   met3_met4_via3_gcpmos_s_vddpadside_x =  m4_gcps_vdd_15 AND m3_gcps_vdd_15
   via3_gcpmos_s_vddpadside_x = via3_gcpmos_s_vddpadside_15 AND met3_met4_via3_gcpmos_s_vddpadside_x
   CONNECT  met3_met4_via3_gcpmos_s_vddpadside_x via3_gcpmos_s_vddpadside_x
   ESDPATH_IOPAD_VDD_GCPMOS_CPATHVIA3_M3_M4 {@ GC_PMOS connected to IO cell does not have 30 via3 path to VDD pad
                                               @ met3/met4 power bus overlap via3 < 30
        x = NET AREA RATIO met3_met4_via3_gcpmos_s_vddpadside_x via3_gcpmos_s_vddpadside_x < 30  [ COUNT (via3_gcpmos_s_vddpadside_x) ]
        //x INTERACT met3_gcpmos_s_vddpadside_ge30 
        //x INTERACT met4_gcpmos_s_vddpadside_ge30 
        x INTERACT met43_gcpmos_s_vddpadside_ge30 
   }
   via3_gcpmos_s_vddpadsideclose = SIZE via3_gcpmos_s_vddpadside_x BY 1.5 OVERUNDER
   CONNECT  met3_met4_via3_gcpmos_s_vddpadside via3_gcpmos_s_vddpadsideclose
   ESDPATH_IOPAD_VDD_GCPMOS_DPATHVIA3_M3_M4 {@ GC_PMOS connected to IO cell does not have sufficient via3 density in path to VDD pad
                                               @ met3/met4 power bus overlap via3 spacing too large
        x = NET AREA RATIO met3_met4_via3_gcpmos_s_vddpadside_x via3_gcpmos_s_vddpadsideclose > 1  [ COUNT (via3_gcpmos_s_vddpadsideclose) ]
        //x INTERACT met3_gcpmos_s_vddpadside_ge30 
        //x INTERACT met4_gcpmos_s_vddpadside_ge30 
        x INTERACT met43_gcpmos_s_vddpadside_ge30 
   }
//------------------------------
//
// check path of gc_nmos to gnd pad
//
//--------------------------------------
//
   DISCONNECT
//
// create new connect with undersized metal2/3/4
//
   via3_gcnmos_s_gndpadside_15 = via3_gcnmos_s_gndpadside AND ( m3_gcns_gnd_15 AND m4_gcns_gnd_15 )
   via2_gcnmos_s_gndpadside_15 = via2_gcnmos_s_gndpadside AND ( m3_gcns_gnd_15 AND m2_gcns_gnd_15 )
   via_gcnmos_s_gndpadside_15  = via_gcnmos_s_gndpadside  AND ( m2_gcns_gnd_15 AND met1_gcnmos_s_gndpadside )
//
   CONNECT  m3_gcns_gnd_15 m4_gcns_gnd_15 BY via3_gcnmos_s_gndpadside_15
   CONNECT  m3_gcns_gnd_15 m2_gcns_gnd_15 BY via2_gcnmos_s_gndpadside_15
   CONNECT  m2_gcns_gnd_15 met1_gcnmos_s_gndpadside BY via_gcnmos_s_gndpadside_15
   CONNECT  met1_gcnmos_s_gndpadside  gcnmos_s_gndpadside  BY ndiffcon_gcnmos_s_gndpadside
   CONNECT  m2_gcns_gnd_15  bondpad_gnd
//
// m1/m2 ovlp
//----------------------
//----------------------
#DEFINE CHECK_VIA
#IFDEF CHECK_VIA
//
   met1_met2_via_gcnmos_s_gndpadside_x =  m2_gcns_gnd_15 AND met1_gcnmos_s_gndpadside
   via_gcnmos_s_gndpadside_x = via_gcnmos_s_gndpadside_15 AND met1_met2_via_gcnmos_s_gndpadside_x
//
   CONNECT  met1_met2_via_gcnmos_s_gndpadside_x via_gcnmos_s_gndpadside_x
   ESDPATH_IOPAD_GND_GCNMOS_CPATHVIA_M1_M2 {@ GC_NMOS  connected to IO cell does not have 30 via path to GND pad
                                            @ met1/met2 power bus overlap via < 30
      x = NET AREA RATIO met1_met2_via_gcnmos_s_gndpadside_x via_gcnmos_s_gndpadside_x < 30  [ COUNT (via_gcnmos_s_gndpadside_x) ]
      //x INTERACT met2_gcnmos_s_gndpadside_ge30
      //x INTERACT met1_gcnmos_s_gndpadside_ge30
      x INTERACT met21_gcnmos_s_gndpadside_ge30
   }
//
   via_gcnmos_s_gndpadsideclose = SIZE via_gcnmos_s_gndpadside_x BY 1.5 OVERUNDER
   CONNECT  met1_met2_via_gcnmos_s_gndpadside_x  via_gcnmos_s_gndpadsideclose
   ESDPATH_IOPAD_GND_GCNMOS_DPATHVIA_M1_M2 {@ GC_NMOS  connected to IO cell does not have sufficient via density in path to GND pad
                                            @ met1/met2 power bus overlap via spacing too large
      x = NET AREA RATIO met1_met2_via_gcnmos_s_gndpadside_x via_gcnmos_s_gndpadsideclose > 1  [ COUNT (via_gcnmos_s_gndpadsideclose) ]
      //x INTERACT met2_gcnmos_s_gndpadside_ge30
      //x INTERACT met1_gcnmos_s_gndpadside_ge30
      x INTERACT met21_gcnmos_s_gndpadside_ge30
   }
//
#ENDIF
//
//----------------------
//----------------------
// m2/m3 ovlp
//
   met2_met3_via2_gcnmos_s_gndpadside_x =  m2_gcns_gnd_15 AND m3_gcns_gnd_15
   via2_gcnmos_s_gndpadside_x = via2_gcnmos_s_gndpadside_15 AND met2_met3_via2_gcnmos_s_gndpadside_x
   CONNECT  met2_met3_via2_gcnmos_s_gndpadside_x via2_gcnmos_s_gndpadside_x
   ESDPATH_IOPAD_GND_GCNMOS_CPATHVIA2_M2_M3 {@ GC_NMOS connected to IO cell does not have 30 via2 path to GND pad
                                             @ met2/met3 power bus overlap via2 < 30
      x =  NET AREA RATIO met2_met3_via2_gcnmos_s_gndpadside_x via2_gcnmos_s_gndpadside_x < 30  [ COUNT (via2_gcnmos_s_gndpadside_x) ]
      //x INTERACT met2_gcnmos_s_gndpadside_ge30
      //x INTERACT met3_gcnmos_s_gndpadside_ge30
      x INTERACT met32_gcnmos_s_gndpadside_ge30
   }
   via2_gcnmos_s_gndpadsideclose = SIZE via2_gcnmos_s_gndpadside_x BY 1.5 OVERUNDER
   CONNECT  met2_met3_via2_gcnmos_s_gndpadside via2_gcnmos_s_gndpadsideclose
   ESDPATH_IOPAD_GND_GCNMOS_DPATHVIA2_M2_M3 {@ GC_NMOS connected to IO cell does not have sufficient via2 density in path to GND pad
                                             @ met2/met3 power bus overlap via2 spacing too large
      x = NET AREA RATIO met2_met3_via2_gcnmos_s_gndpadside_x via2_gcnmos_s_gndpadsideclose > 1  [ COUNT (via2_gcnmos_s_gndpadsideclose) ]
      //x INTERACT met2_gcnmos_s_gndpadside_ge30
      //x INTERACT met3_gcnmos_s_gndpadside_ge30
      x INTERACT met32_gcnmos_s_gndpadside_ge30
   }
//------------------------------
//----------------------
// m3/m4 ovlp
//
   met3_met4_via3_gcnmos_s_gndpadside_x =  m4_gcns_gnd_15 AND m3_gcns_gnd_15
   via3_gcnmos_s_gndpadside_x = via3_gcnmos_s_gndpadside_15 AND met3_met4_via3_gcnmos_s_gndpadside_x
   CONNECT  met3_met4_via3_gcnmos_s_gndpadside_x via3_gcnmos_s_gndpadside_x
   ESDPATH_IOPAD_GND_GCNMOS_CPATHVIA3_M3_M4 {@ GC_NMOS connected to IO cell does not have 30 via3 path to GND pad
                                               @ met3/met4 power bus overlap via3 < 30
      x = NET AREA RATIO met3_met4_via3_gcnmos_s_gndpadside_x via3_gcnmos_s_gndpadside_x < 30  [ COUNT (via3_gcnmos_s_gndpadside_x) ]
      //x INTERACT met3_gcnmos_s_gndpadside_ge30
      //x INTERACT met4_gcnmos_s_gndpadside_ge30
      x INTERACT met43_gcnmos_s_gndpadside_ge30
   }
   via3_gcnmos_s_gndpadsideclose = SIZE via3_gcnmos_s_gndpadside_x BY 1.5 OVERUNDER
   CONNECT  met3_met4_via3_gcnmos_s_gndpadside via3_gcnmos_s_gndpadsideclose
   ESDPATH_IOPAD_GND_GCNMOS_DPATHVIA3_M3_M4 {@ GC_NMOS connected to IO cell does not have sufficient via3 density in path to GND pad
                                               @ met3/met4 power bus overlap via3 spacing too large
      x = NET AREA RATIO met3_met4_via3_gcnmos_s_gndpadside_x via3_gcnmos_s_gndpadsideclose > 1  [ COUNT (via3_gcnmos_s_gndpadsideclose) ]
      //x INTERACT met3_gcnmos_s_gndpadside_ge30
      //x INTERACT met4_gcnmos_s_gndpadside_ge30
      x INTERACT met43_gcnmos_s_gndpadside_ge30
   }
//
#ENDIF // via count bus
//
// gggggggggggggggggggggggggggggg
// gggggggggggggggggggggggggggggg
// gggggggggggggggggggggggggggggg
//
#ENDIF
//
///////////////////////////////////////////////////////////////////////
//
//           end of CALIBRE esd check technology file 
//
///////////////////////////////////////////////////////////////////////
