////////////////////////////////////////////////////
// Owner: austriamicrosystems AG                  //
//        Business Unit Silicon Foundry           //
//================================================//
//        HIT-Kit: Digital                        //
////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//
// CALIBRE  DFM R U L E S   F I L E   F O R   P R O C E S S   C 3 5
//
///////////////////////////////////////////////////////////////////////
//
// CMOS C35 DFM rules  Document: ENG-301               Revision: REV 3
//
///////////////////////////////////////////////////////////////////////
//
// ATTENTION : flag for definition of processes
//
// use c35b4 4 metal process
//--------------------------
//
#DEFINE fourmetal
//
// use c35b3 3 metal process
//--------------------------
//
//#UNDEFINE fourmetal
//
//
///////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------
//
// viax, diff conts in connecting area
//
#UNDEFINE CONNECT_COUNT    
//
//-----------------------------------------------------------------------
//
// get duplicated placement of cells
// finds all merged data, also in all levels of hierarchy
//
#UNDEFINE CHECK_MERGE
//-----------------------------------------------------------------------
// filter some checks to reduce ouput
//
#UNDEFINE MORE_DFM_CHECKS
#UNDEFINE DEBUG_DIGITAL 
//-----------------------------------------------------------------------
//
// print areas of layers
//
#UNDEFINE GET_AREAS
//
///////////////////////////////////////////////////////////////////////
//
// do not modify
//
// part of DFM check , always done, do not change
//
#DEFINE CONNECT_STATISTIC
//
// set for c35
//
#DEFINE PROCESS_IS_C35XX
//
#UNDEFINE PROCESS_IS_H35XX
#UNDEFINE PROCESS_IS_S35XX
#UNDEFINE PROCESS_IS_C35B4EE
#UNDEFINE PROCESS_IS_H35EE
//
// standard latchup
//
#IFDEF PROCESS_IS_C35XX
   #DEFINE LATCHUP_CHECK_C35
#ENDIF
//
///////////////////////////////////////////////////////////////////////
//
//            detailed process definition( module check)
//
///////////////////////////////////////////////////////////////////////
//
// this section allows to select a  more detailed processe( with/without
// poly2, hres, midox ..). See DRC document for definitions

// If "process_switch" is not used, all modules are checked, only met3/met4
// is can be selected by "fourmetal" switch
//
// module check flags unsupported layers as DRC errors
// module check disables unsupported devices in LVS
//
//
// select one process
//---------------------
//
//#DEFINE process_C35A3B0 // core
//#DEFINE process_C35B3C0 // core, poly2
//#DEFINE process_C35B3C1 // core, poly2, midox
//#DEFINE process_C35B3C3 // core, poly2, midox, hres
//#DEFINE process_C35B3L3 // core, poly2, midox, hres , lvtdef
//#DEFINE process_C35B4C0 // core, poly2,              met4
//#DEFINE process_C35B4C3 // core, poly2, midox, hres, met4
//#DEFINE process_C35A4L5 // core, midox, lvtdef, cmim, met4
//#DEFINE process_C35B4M6 // core, poly2, hres, cmim, met4
//#DEFINE process_C35B4L7 // core, poly2, midox, hres, lvtdef, cmim, met4
//
// thick top metal only rof value
//#DEFINE process_C35B4M3 // core poly2, thick met4, cmim
//
// dummy square for process DRC output
//
   bound_cent = EXTENTS (EXTENT) CENTERS 1.0
//
// default setting is check for all layers
//-----------------------------------------
//
#DEFINE layer_lvtdef
#DEFINE layer_poly2
#DEFINE layer_midox
#DEFINE layer_hres
#DEFINE layer_metcap
// set flag for default checks
#UNDEFINE process_found_flag
#UNDEFINE fourmetal_thick
//
// set layers for processes
//-------------------------
//
// c35a3b0
//
#IFDEF process_C35A3B0
  #UNDEFINE layer_lvtdef
  #UNDEFINE layer_poly2
  #UNDEFINE layer_midox
  #UNDEFINE layer_hres
  #UNDEFINE layer_metcap
  #UNDEFINE fourmetal
  #DEFINE process_found_flag
  INFO_PROCESS_C35A3B0 { @ INFO : DRC checked with c35a3b0
       FLATTEN bound_cent
  }
#ENDIF
//
// c35b3c0
//
#IFDEF process_C35B3C0
  #UNDEFINE layer_lvtdef
  #DEFINE layer_poly2
  #UNDEFINE layer_midox
  #UNDEFINE layer_hres
  #UNDEFINE layer_metcap
  #UNDEFINE fourmetal
  #DEFINE process_found_flag
  INFO_PROCESS_C35B3C0 { @ INFO : DRC checked with c35b3c0
       FLATTEN bound_cent
  }
#ENDIF
//
// c35b3c1
//
#IFDEF process_C35B3C1
  #UNDEFINE layer_lvtdef
  #DEFINE layer_poly2
  #DEFINE layer_midox
  #UNDEFINE layer_hres
  #UNDEFINE layer_metcap
  #UNDEFINE fourmetal
  #DEFINE process_found_flag
  INFO_PROCESS_C35B3C1 { @ INFO : DRC checked with c35b3c1
       FLATTEN bound_cent
  }
#ENDIF
//
// c35b3c3
//
#IFDEF process_C35B3C3
  #UNDEFINE layer_lvtdef
  #DEFINE layer_poly2
  #DEFINE layer_midox
  #DEFINE layer_hres
  #UNDEFINE layer_metcap
  #UNDEFINE fourmetal
  #DEFINE process_found_flag
  INFO_PROCESS_C35B3C3 { @ INFO : DRC checked with c35b3c3
       FLATTEN bound_cent
  }
#ENDIF
//

//
// c35b3l3
//
#IFDEF process_C35B3L3
  #DEFINE layer_lvtdef
  #DEFINE layer_poly2
  #DEFINE layer_midox
  #DEFINE layer_hres
  #UNDEFINE layer_metcap
  #UNDEFINE fourmetal
  #DEFINE process_found_flag
  INFO_PROCESS_C35B3L3 { @ INFO : DRC checked with c35b3l3
       FLATTEN bound_cent
  }
#ENDIF
//
// c35b4c0
//
#IFDEF process_C35B4C0
  #UNDEFINE layer_lvtdef
  #DEFINE layer_poly2
  #UNDEFINE layer_midox
  #UNDEFINE layer_hres
  #UNDEFINE layer_metcap
  #DEFINE fourmetal
  #DEFINE process_found_flag
  INFO_PROCESS_C35B4C0 { @ INFO : DRC checked with c35b4c0
       FLATTEN bound_cent
  }
#ENDIF
//
// c35b4c3
//
#IFDEF process_C35B4C3
  #UNDEFINE layer_lvtdef
  #DEFINE layer_poly2
  #DEFINE layer_midox
  #DEFINE layer_hres
  #UNDEFINE layer_metcap
  #DEFINE fourmetal
  #DEFINE process_found_flag
  INFO_PROCESS_C35B4C3 { @ INFO : DRC checked with c35b4c3
       FLATTEN bound_cent
  }
#ENDIF
//
// c35a4l5
//
#IFDEF process_C35A4L5
  #DEFINE layer_lvtdef
  #UNDEFINE layer_poly2
  #DEFINE layer_midox
  #UNDEFINE layer_hres
  #DEFINE fourmetal
  #DEFINE layer_metcap
  #DEFINE process_found_flag
  INFO_PROCESS_C35A4L5 { @ INFO : DRC checked with c35a4l5
       FLATTEN bound_cent
  }
#ENDIF
//
// c35b4l7
//
#IFDEF process_C35B4L7
  #DEFINE layer_lvtdef
  #DEFINE layer_poly2
  #DEFINE layer_midox
  #DEFINE layer_hres
  #DEFINE fourmetal
  #DEFINE layer_metcap
  #DEFINE process_found_flag
  INFO_PROCESS_C35B4L7 { @ INFO : DRC checked with c35b4l7
       FLATTEN bound_cent
  }
#ENDIF
//
// c35b4m6
//
#IFDEF process_C35B4M6
  #UNDEFINE layer_lvtdef
  #DEFINE layer_poly2
  #UNDEFINE layer_midox
  #DEFINE layer_hres
  #DEFINE fourmetal
  #DEFINE process_found_flag
  #DEFINE layer_metcap
  INFO_PROCESS_C35B4M6 { @ INFO : DRC checked with c35b4m6
       FLATTEN bound_cent
  }
#ENDIF
//
// c35b4m3
//
// thick metal only ROF value checked
//
#IFDEF process_C35B4M3
  #UNDEFINE layer_lvtdef
  #DEFINE layer_poly2
  #DEFINE layer_midox
  #DEFINE layer_hres
  #DEFINE layer_metcap
  #DEFINE fourmetal
//  // not available yet
  #DEFINE fourmetal_thick
  #DEFINE process_found_flag
  INFO_PROCESS_C35B4M3 { @ INFO : DRC checked with c35b4m3
       FLATTEN bound_cent
  }
#ENDIF
//
//
//
//
// do standard met3/met4 check if not set
//-----------------------------------------
//
#IFNDEF process_found_flag
#IFDEF fourmetal
  INFO_PROCESS_C35B4 { @ INFO : DRC checked with c35b4 ( 4 metal all modules)
       FLATTEN bound_cent
  }
#ELSE
  INFO_PROCESS_C35B3 { @ INFO : DRC checked with c35b3 ( 3 metal all modules)
       FLATTEN bound_cent
  }
#ENDIF
#ENDIF
//
// output of unsupported layer for modules
//-------------------------------------------
//
#IFNDEF layer_hres
  ILL_HRES_UNAVAILABLE_DFM0001 { @ Process Modules : HRES not available
         COPY HRES
  }
#ENDIF
#IFNDEF layer_poly2
  ILL_POLY2_UNAVAILABLE_DFM0001 { @ Process Modules : POLY2 not available
         COPY POLY2
  }
#ENDIF
#IFNDEF layer_midox
  ILL_MIDOX_UNAVAILABLE_DFM0001 { @ Process Modules : MIDOX not available
         COPY MIDOX
  }
#ENDIF
#IFNDEF layer_lvtdef
  ILL_LVTDEF_UNAVAILABLE_DFM0001 { @ Process Modules : LVTDEF not available
         COPY LVTDEF
  }
#ENDIF
#IFNDEF fourmetal
  ILL_MET4_UNAVAILABLE_DFM0001 { @ Process Modules : MET4 not available
         COPY MET4
  }
  ILL_VIA3_UNAVAILABLE_DFM0001 { @ Process Modules : VIA3 not available
         COPY VIA3
  }
#ENDIF
//
#IFNDEF layer_metcap
  ILL_METCAP_UNAVAILABLE_DFM0001 { @ Process Modules : METCAP not available
         COPY METCAP
  }
#ENDIF
//
///////////////////////////////////////////////////////////////////////
//
//   C A L I B R E  R U L E   F I L E  S T A N D A R D   H E A D E R
//
///////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
//               Define options for stand alone environment
//
////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////
//
//               I n p u t   d a t a   d e f i n i t i o n s
//
////////////////////////////////////////////////////////////////////////////////////
//
   LAYOUT PRIMARY "_TOPCELL()"
   LAYOUT PATH  "_GDSFILE()"
   DRC SUMMARY REPORT "_TOPCELL()_dfmcheck0.rpt" REPLACE HIER
   DRC RESULTS DATABASE "_TOPCELL()_dfmcheck0.asc" ASCII
//
//  layout
//--------------
//
   LAYOUT SYSTEM GDSII
   LAYOUT DEPTH ALL // PRIMARY
   LAYOUT ERROR ON INPUT YES  // NO
   DRC MAXIMUM VERTEX 50 
   DRC MAXIMUM RESULTS ALL 
   DRC KEEP EMPTY NO
//
// EXCLUDE CELL name1 name2 name3

///////////////////////////////////////////////////////////////////////
//
//                 end of standard header
//
///////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////
//
// CALIBRE  DFM R U L E S   F I L E   F O R   P R O C E S S   C 3 5
//
///////////////////////////////////////////////////////////////////////
//
// CMOS C35 DFM rules  Document: ENG-301               Revision: REV 3        
//
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//-------------------------------------------------------------------------------
//     rev     date            by                      comment
//-------------------------------------------------------------------------------
//    1.00   14-Jun-2006      aob      basic version for c35b4
//                                     remove polynet ...ok
//                                     merge 2 DFM checks .... ok
//
//                                     problems : dfm0004 trans in peri cells
//            20-Jun-2006     aob
//                 ntrans miss conts ... remove stacked gates with spacing digital cell
//                 missing : gate/via ratio checks ... ok
//                 missing dummy poly2 total ...ok
//                 max distance dummy poly2 ..ok
//                 element checks nmos/pmos ..ok
//
//            26-Jun-06       aob
//                 peri cell nmos/pmos miss conts false errors fixed
//                 remove spirals/ cmim/ hall ... not ok
//                 metcap and spiral..ok
//
//            29-Jun-06       aob
//                 rof values thick metal added
//
//            14-Jul-06       aob
//                 add groups of priority
//                 improve output of more vias 
//                 new draft version of document 11-07-2006
//
//            17-Jul-06  no check under sfcdef
//                       improve L/W of devices
//
//            12-Sep-06  aob  set 0048 to level 2
//                 
//            21-Dec-06  aob  add nldd50 45 degree problem
//            21-Feb-07  aob  improve nldd50 problem
//            23-Mar-07  aob  add level for tapeout checks
//                            add spacing to SFCDEF
//            14-May-07  aob  fix dfm008 rule name
//
//  Rev2/Rev3  4-Jul-08  aob  filter rules showing too much errors 
//                            long_poly_gate : only poly < 0.6, filter gate notch
//                            dummy poly2 : close notches
//                            update layer and device ( OPTO, METRES, nmos30t, nmos30m)
//                            update miss nldd/nldd50/fimp due to nmos30m/t 
//                            more_vias : remove all, show only worst cases 
//                            ntrans/ptrans miss conts .. filter digital cells
//                            reduce miss via error output
//                            more taps only for larger areas
//                            add dummy poly2 res end for rpoly2 conn with met1
//                            add kepout for h35
//                            add techs for s35,h35,h35ee.c35b4ee
//            24-Jul-08 aob  fix poly2 resend
//
///////////////////////////////////////////////////////////////////////
   TITLE "0.35 U CMOS C35/H35/S35/C35B4EE/H35EE  DFM rules Doc ENG 301 REV3 (last modified 24-Jul-08)"
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//
   DRC INCREMENTAL CONNECT YES
//
///////////////////////////////////////////////////////////////////////
//=====================================================================
//                     select checks by groups
//=====================================================================
//
// DRC UNSELECT CHECK INFO
// DRC UNSELECT CHECK DFM_CONTACT
// DRC UNSELECT CHECK DFM_ANALOG_RECOMMENDATIONS
// DRC UNSELECT CHECK DFM_LATCHUP
// DRC UNSELECT CHECK DFM_CHIP 
//
// activate groups which should NOT be checked
//=============================================
//
// DRC UNSELECT CHECK DFM_LEVEL1
// DRC UNSELECT CHECK DFM_LEVEL2 
// DRC UNSELECT CHECK DFM_LEVEL3
// DRC UNSELECT CHECK DFM_TAPEOUT
// DRC UNSELECT CHECK INFO

   GROUP DFM_ANALOG_RECOMMENDATIONS ?_DFMA?
   GROUP DFM_CONTACT ?_DFMC?
   GROUP INFO ?INFO?
   GROUP DFM_LATCHUP ?_DFML?
#IFDEF fourmetal_thick
   // skip ROF. trans density and miss layer and sapcing to SFCDEF/KEEPOUT
   GROUP DFM_CHIP ?_DFM0001 ?0017 ?LOW_TRANS? ?NO_TRANS? ?TPTXXX6
#ELSE
   GROUP DFM_CHIP ?_DFM0001 ?LOW_TRANS? ?NO_TRANS? ?TPTXXX6
#ENDIF
//
//
//------------------------------------------------------------------------------
#IFDEF fourmetal
//
#IFDEF fourmetal_thick
//
// ROF value extra 0017
//
   GROUP DFM_LEVEL1 ?0001 ?0002 ?0003 ?0006 ?0007 ?0009 ?0012 ?0015 ?0017 ?0018 ?0019
                    ?0040? ?0041 ?0044 ?0045 ?0046 ?0047 ?0065 
#ELSE

   GROUP DFM_LEVEL1 ?0001 ?0002 ?0003 ?0006 ?0007 ?0009 ?0012 ?0015 ?0018 ?0019
                    ?0040? ?0041 ?0044 ?0045 ?0046 ?0047 
#ENDIF
//
   GROUP DFM_LEVEL2 ?0005 ?0010 ?0013 ?0016
                    ?0020 ?0021 ?0022 ?0023 ?0024 ?0025 ?0026 ?0027 ?0028 
                    ?0029 ?0030 ?0031 ?0032 ?0033 ?0034 ?0035 ?0036 ?0037 ?0038 ?0039
                    ?0042 ?0043 ?0048
//
   GROUP DFM_LEVEL3 ?0004 ?0008 ?0011 ?0014
//
// nldd50 not activated yet
   //GROUP DFM_LEVEL3 ?0004 ?0008 ?0011 ?0015 ?0065

   GROUP DFM_TAPEOUT ?TPTXXX1 ?TPTXXX2 ?TPTXXX3 ?TPTXXX4 ?TPTXXX5 ?TPTXXX6
//
#ELSE
//------------------------------------------------------------------------------
//
// 3 metal...no 0014/0015/0016
//
//
   GROUP DFM_LEVEL1 ?0001 ?0002 ?0003 ?0006 ?0007 ?0009 ?0012 ?0018 ?0019
                    ?0040? ?0041 ?0044 ?0045 ?0046 ?0047 ?0065 
//
   GROUP DFM_LEVEL2 ?0005 ?0010 ?0013 
                    ?0020 ?0021 ?0022 ?0023 ?0024 ?0025 ?0026 ?0027 ?0028 
                    ?0029 ?0030 ?0031 ?0032 ?0033 ?0034 ?0035 ?0036 ?0037 ?0038 ?0039
                    ?0042 ?0043 ?0048
//
   GROUP DFM_LEVEL3 ?0004 ?0008 ?0011  
   //GROUP DFM_LEVEL3 ?0004 ?0008 ?0011 ?0065 

   GROUP DFM_TAPEOUT ?TPTXXX1 ?TPTXXX2 ?TPTXXX3 ?TPTXXX4 ?TPTXXX5 ?TPTXXX6
//
#ENDIF
//------------------------------------------------------------------------------
// 
// combine level0 and level1
//
//
//=====================================================================
//       check for missing special areas 
//=====================================================================
// not implemented yet
//
// this can be modified by the user
// do not process peri cells
//   do_not_check_1 = EXTENT CELL
//                   "dummy_dummy_BandgapInput"
//                   "dummy_dummy_Amplifier_*"
//                   "dummy_dummy_TestPad_ESD"
//                   "dummy_dummy_APRIOP_2M_HV"
//                   "dummy_dummy_nmosi*"
//
// do not fill spirals, analog structures, near pad, sfc areas, hall rfdef.. if any ...
//
//   padovs = SIZE PAD BY 20.0
//
// replace empty layer if needed
//
//   padovs = AREA (EXTENT) == 0
//
//   nofill_area = SFCDEF OR (padovs OR ( INDDEF OR (NOFILL OR HALLDEF)))
//
//   do_not_check  = nofill_area OR do_not_check_1
//=====================================================================
//       Input layer definition                        
//=====================================================================
//
// basic layer
//
   LAYER TRENCH 3
// NTUB ... ntub mask (nwell)
   LAYER NTUB_alldata 5
// FIMP ... field implant mask
   LAYER FIMP_alldata 8
// DIFF ... field mask (diffusion)
   LAYER DIFF_alldata 10
//
   LAYER MIDOX_alldata 14
//
// POLY1 ... poly1 mask
   LAYER POLY1_alldata 20
// NPLUS ... n+ implant mask
   LAYER NPLUS_alldata 23
// PPLUS ... p+ implant mask
   LAYER PPLUS_alldata 24
// POLY2 ... poly2 mask
   LAYER POLY2_alldata 30
// CONT ... contact mask
   LAYER CONT_alldata 34
// MET1 ... metal1 mask
   LAYER MET1_alldata 35
// VIA ... via mask
   LAYER VIA_alldata 36
// MET2 ... metal2 mask
   LAYER MET2_alldata 37
   LAYER VIA2_alldata 38
   LAYER MET3_alldata 39
// PAD ... pad mask
   LAYER PAD_alldata 40
//
   LAYER VIA3_alldata 41
   LAYER MET4_alldata 42
//
   LAYER HRES_alldata  29
//
   LAYER NLDD_alldata     21
   LAYER NLDD50_alldata   53
//
// bipolar layers
//----------------
//
   LAYER PBUDEF_alldata  2
   LAYER BNTUB_alldata 15
   LAYER BNTUB2_alldata 16
   LAYER BPOLY_alldata 28
   LAYER EMITT_alldata 26
   LAYER COLL_alldata  11  
//
   LAYER METCAP_alldata 55
   LAYER HBT_alldata 25
   LAYER EPOLY_alldata 33
   LAYER NBUR_alldata 1
   LAYER CAPLAY_alldata 27
//
// layer for pldmos
//
   LAYER LPPLUS_alldata 45
//
// hv layers
//----------------
//
   LAYER DNTUB_alldata  4
   LAYER SNTUB_alldata  6
   LAYER DPTUB_alldata  7
   LAYER SPTUB_alldata 57
   LAYER HVDEF_alldata 13
   LAYER HVOX_alldata  56
   LAYER NLD20V_alldata 50
//
// eeprom layer h35ee
//--------------------
//
   LAYER POLY0_alldata    9
   LAYER HALO_alldata    18
   LAYER PLDD_alldata    22
   LAYER EEHVOX_alldata  58
   LAYER EEVTP_alldata   60
//
// eeprom layer c35b4ee
//--------------------
// layer : EEHVOX  ...  EEPROM high voltage gate exide layer
// layer : PFIMP   ...  EEPROM p-tub blocking layer
// layer : EEVTP   ...  NMOSEH vt adjust implant layer
// layer : PLDD    ...  p_LDD implant layer
// layer : POLY0   .... floating gate layer
// layer : ENTUB   .... EEPROM ntub ( NTUB enclosing EEHVOX)
//
//   LAYER POLY0    9
//   LAYER PLDD    22
//   LAYER EEHVOX  58
//   LAYER EEVTP   60
//
   LAYER PFIMP_alldata  12
//
// generated layers
//
   LAYER NFIMP   17
// LAYER HALO    18
   LAYER PTHA    49
// 
// definition layer2
//-------------------
//
   LAYER MAP 62 DATATYPE 2 622
   LAYER SFCDEF 622 
   LAYER MAP 62 DATATYPE 10 6210
   LAYER ZENER_alldata 6210
// diode
   LAYER MAP 62 DATATYPE 11  711
   LAYER DIODE_alldata  711
//
// cell box outline
   LAYER MAP 62 DATATYPE 1  701
   LAYER CELBOX_alldata  701
// GND substrate definition layer
   LAYER MAP 62 DATATYPE 3  703
   LAYER SUBDEF_alldata  703
// diffusion cut
   LAYER MAP 62 DATATYPE 30  730
   LAYER DIFCUT_alldata  730
// poly1 cut
   LAYER MAP 62 DATATYPE 31  731
   LAYER PO1CUT_alldata  731
// poly2 cut
   LAYER MAP 62 DATATYPE 32  732
   LAYER PO2CUT_alldata  732
// ntub resistor definition
   LAYER MAP 62 DATATYPE 12  712
   LAYER TUBDEF_alldata  712
// resistor definition
   LAYER MAP 62 DATATYPE 13  713
   LAYER RESDEF_alldata  713
// resistor terminal
   LAYER MAP 62 DATATYPE 14  714
   LAYER RESTRM_alldata  714
// hall definition layer
   LAYER MAP 62 DATATYPE 24  724
   LAYER HALLDEF_alldata  724
// sandwich cap definition
   LAYER MAP 62 DATATYPE 20  720
   LAYER CAPDEF_alldata  720
//
   LAYER MAP 35 DATATYPE 1 201
   LAYER M1HOLE_alldata 201
//
   LAYER MAP 37 DATATYPE 1 202
   LAYER M2HOLE_alldata 202
//
   LAYER MAP 39 DATATYPE 1 203
   LAYER M3HOLE_alldata 203
//
#IFDEF fourmetal
   LAYER MAP 42 DATATYPE 1 204
   LAYER M4HOLE_alldata 204
#ENDIF
   LAYER MAP 62 DATATYPE 5  705
   LAYER NOFILL_alldata  705
//
// for hv  definition
   LAYER MAP 13 TEXTTYPE 0  725
   LAYER HVDEF_TEXT  725
// for hall definition
   LAYER MAP 62 TEXTTYPE 24  724
   LAYER HALLDEF_TEXT  724
   LAYER MAP 62 TEXTTYPE 13  913
   LAYER RESDEF_TEXT  913
//
   LAYER MAP 62 DATATYPE 22  722
   LAYER INDDEF_alldata  722
//
   LAYER MAP 62 DATATYPE 26  726
   LAYER RFDEF_alldata  726
//
   LAYER MAP 62 DATATYPE 27  727
   LAYER PROBE_alldata  727
//
// photo def layer layer
   LAYER MAP 62 DATATYPE 40  740
   LAYER OPTDEF_alldata  740
//
// definition layer for fimp in nmos30m
   LAYER MAP 62 DATATYPE 29  741
   LAYER FIDEF_alldata  741
//
// met resistor definition
   LAYER MAP 62 DATATYPE 15  715
   LAYER METRES_alldata 715
//
// LVT layers
//-------------
//
   LAYER MAP 62 DATATYPE 28  728
   LAYER LVTDEF_alldata  728
//
// LVTA
   LAYER LVTA_alldata  46
//
// LVPTUB
   LAYER LVPTUB_alldata  47
//
// ipdef
   LAYER MAP 62 DATATYPE 6  706
   LAYER IPDEF   706
// kepout
   LAYER MAP 62 DATATYPE 7  707
   LAYER KEPOUT  707
//
/////////////////////////////////////////////////////////////////////////////////

//
  NTUB = NTUB_alldata NOT SFCDEF
  NTUB_NO_SFCDEF = COPY NTUB
//
  FIMP = FIMP_alldata NOT SFCDEF
  FIMP_NO_SFCDEF = COPY FIMP
//
  DIFF = DIFF_alldata NOT SFCDEF
  DIFF_NO_SFCDEF = COPY DIFF
//
  MIDOX = MIDOX_alldata NOT SFCDEF
  MIDOX_NO_SFCDEF = COPY MIDOX
//
  POLY1 = POLY1_alldata NOT SFCDEF
  POLY1_NO_SFCDEF = COPY POLY1
//
  NPLUS = NPLUS_alldata NOT SFCDEF
  NPLUS_NO_SFCDEF = COPY NPLUS
//
  PPLUS = PPLUS_alldata NOT SFCDEF
  PPLUS_NO_SFCDEF = COPY PPLUS
//
  POLY2 = POLY2_alldata NOT SFCDEF
  POLY2_NO_SFCDEF = COPY POLY2
//
  CONT = CONT_alldata NOT SFCDEF
  CONT_NO_SFCDEF = COPY CONT
//
  MET1 = MET1_alldata NOT SFCDEF
  MET1_NO_SFCDEF = COPY MET1
//
  VIA = VIA_alldata NOT SFCDEF
  VIA_NO_SFCDEF = COPY VIA
//
  MET2 = MET2_alldata NOT SFCDEF
  MET2_NO_SFCDEF = COPY MET2
//
  VIA2 = VIA2_alldata NOT SFCDEF
  VIA2_NO_SFCDEF = COPY VIA2
//
  MET3 = MET3_alldata NOT SFCDEF
  MET3_NO_SFCDEF = COPY MET3
//
  PAD = PAD_alldata NOT SFCDEF
  PAD_NO_SFCDEF = COPY PAD
//
  VIA3 = VIA3_alldata NOT SFCDEF
  VIA3_NO_SFCDEF = COPY VIA3
//
  MET4 = MET4_alldata NOT SFCDEF
  MET4_NO_SFCDEF = COPY MET4
//
  HRES = HRES_alldata NOT SFCDEF
  HRES_NO_SFCDEF = COPY HRES
//
  NLDD = NLDD_alldata NOT SFCDEF
  NLDD_NO_SFCDEF = COPY NLDD
//
  NLDD50 = NLDD50_alldata NOT SFCDEF
  NLDD50_NO_SFCDEF = COPY NLDD50
//
  PBUDEF = PBUDEF_alldata NOT SFCDEF
  PBUDEF_NO_SFCDEF = COPY PBUDEF
//
  BNTUB = BNTUB_alldata NOT SFCDEF
  BNTUB_NO_SFCDEF = COPY BNTUB
//
  BNTUB2 = BNTUB2_alldata NOT SFCDEF
  BNTUB2_NO_SFCDEF = COPY BNTUB2
//
  BPOLY = BPOLY_alldata NOT SFCDEF
  BPOLY_NO_SFCDEF = COPY BPOLY
//
  EMITT = EMITT_alldata NOT SFCDEF
  EMITT_NO_SFCDEF = COPY EMITT
//
  COLL = COLL_alldata NOT SFCDEF
  COLL_NO_SFCDEF = COPY COLL
//
  LPPLUS = LPPLUS_alldata NOT SFCDEF
  LPPLUS_NO_SFCDEF = COPY LPPLUS
//
  DNTUB = DNTUB_alldata NOT SFCDEF
  DNTUB_NO_SFCDEF = COPY DNTUB
//
  SNTUB = SNTUB_alldata NOT SFCDEF
  SNTUB_NO_SFCDEF = COPY SNTUB
//
  DPTUB = DPTUB_alldata NOT SFCDEF
  DPTUB_NO_SFCDEF = COPY DPTUB
//
  SPTUB = SPTUB_alldata NOT SFCDEF
  SPTUB_NO_SFCDEF = COPY SPTUB
//
  HVDEF = HVDEF_alldata NOT SFCDEF
  HVDEF_NO_SFCDEF = COPY HVDEF
//
  HVOX = HVOX_alldata NOT SFCDEF
  HVOX_NO_SFCDEF = COPY HVOX
//
  NLD20V = NLD20V_alldata NOT SFCDEF
  NLD20V_NO_SFCDEF = COPY NLD20V
//
//  SFCDEF = SFCDEF_alldata NOT SFCDEF
//  SFCDEF_NO_SFCDEF = COPY SFCDEF
//
  ZENER = ZENER_alldata NOT SFCDEF
  ZENER_NO_SFCDEF = COPY ZENER
//
  DIODE = DIODE_alldata NOT SFCDEF
  DIODE_NO_SFCDEF = COPY DIODE
//
  CELBOX = CELBOX_alldata NOT SFCDEF
  CELBOX_NO_SFCDEF = COPY CELBOX
//
  SUBDEF = SUBDEF_alldata NOT SFCDEF
  SUBDEF_NO_SFCDEF = COPY SUBDEF
//
  DIFCUT = DIFCUT_alldata NOT SFCDEF
  DIFCUT_NO_SFCDEF = COPY DIFCUT
//
  PO1CUT = PO1CUT_alldata NOT SFCDEF
  PO1CUT_NO_SFCDEF = COPY PO1CUT
//
  PO2CUT = PO2CUT_alldata NOT SFCDEF
  PO2CUT_NO_SFCDEF = COPY PO2CUT
//
  TUBDEF = TUBDEF_alldata NOT SFCDEF
  TUBDEF_NO_SFCDEF = COPY TUBDEF
//
  RESDEF = RESDEF_alldata NOT SFCDEF
  RESDEF_NO_SFCDEF = COPY RESDEF
//
  RESTRM = RESTRM_alldata NOT SFCDEF
  RESTRM_NO_SFCDEF = COPY RESTRM
//
  HALLDEF = HALLDEF_alldata NOT SFCDEF
  HALLDEF_NO_SFCDEF = COPY HALLDEF
//
  INDDEF = INDDEF_alldata NOT SFCDEF
  INDDEF_NO_SFCDEF = COPY INDDEF
//
  NOFILL= NOFILL_alldata NOT SFCDEF
  NOFILL_NO_SFCDEF = COPY NOFILL
//
  RFDEF = RFDEF_alldata NOT SFCDEF
  RFDEF_NO_SFCDEF = COPY RFDEF
//
  CAPDEF = CAPDEF_alldata NOT SFCDEF
  CAPDEF_NO_SFCDEF = COPY CAPDEF
//
  M1HOLE = M1HOLE_alldata NOT SFCDEF
  M1HOLE_NO_SFCDEF = COPY M1HOLE
//
  M2HOLE = M2HOLE_alldata NOT SFCDEF
  M2HOLE_NO_SFCDEF = COPY M2HOLE
//
  M3HOLE = M3HOLE_alldata NOT SFCDEF
  M3HOLE_NO_SFCDEF = COPY M3HOLE
//
#IFDEF fourmetal
  M4HOLE = M4HOLE_alldata NOT SFCDEF
  M4HOLE_NO_SFCDEF = COPY M4HOLE
#ENDIF
//
  LVTDEF = LVTDEF_alldata NOT SFCDEF
  LVTDEF_NO_SFCDEF = COPY  LVTDEF
//
  METCAP = METCAP_alldata NOT SFCDEF
  METCAP_NO_SFCDEF = COPY METCAP
//
  HBT =  HBT_alldata NOT SFCDEF
  HBT_NO_SFCDEF = COPY HBT
//
  EPOLY_NO_SFCDEF = EPOLY_alldata NOT SFCDEF
  EPOLY = COPY EPOLY_NO_SFCDEF
//
  NBUR = NBUR_alldata NOT SFCDEF 
  NBUR_NO_SFCDEF = COPY NBUR
//
  CAPLAY = CAPLAY_alldata NOT SFCDEF
  CAPLAY_NO_SFCDEF = COPY CAPLAY
//
  POLY0  = POLY0_alldata NOT SFCDEF
  POLY0_NO_SFCDEF  = COPY POLY0
//
  HALO   = HALO_alldata NOT SFCDEF
  HALO_NO_SFCDEF   = COPY HALO
//
  PLDD   = PLDD_alldata NOT SFCDEF
  PLDD_NO_SFCDEF   = COPY PLDD
//
  EEHVOX = EEHVOX_alldata NOT SFCDEF
  EEHVOX_NO_SFCDEF  = COPY EEHVOX
//
  EEVTP = EEVTP_alldata NOT SFCDEF
  EEVTP_NO_SFCDEF  = COPY EEVTP
//
  PFIMP = PFIMP_alldata NOT SFCDEF
  PFIMP_NO_SFCDEF  = COPY PFIMP
//-----------------------------------------------
//-----------------------------------------------
//
  OPTDEF = OPTDEF_alldata NOT SFCDEF
//
  FIDEF  = FIDEF_alldata NOT SFCDEF
//
  METRES = METRES_alldata NOT SFCDEF
//
//=====================================================================
//                             Options                                       
//=====================================================================

   PRECISION 1000
   RESOLUTION 50

   UNIT RESISTANCE ohm
   UNIT CAPACITANCE ff

   DRC TOLERANCE FACTOR 0.005
//
//#DEFINE DEVSWITCH
#UNDEFINE DEVSWITCH

#IFDEF fourmetal
   LAYOUT TOP LAYER MET4_alldata VIA3_alldata MET3_alldata VIA2_alldata MET2_alldata VIA_alldata MET1_alldata
#ELSE
   LAYOUT TOP LAYER MET3_alldata VIA2_alldata MET2_alldata VIA_alldata MET1_alldata
#ENDIF
//
//=====================================================================
//       check for missing data on input layer DFM0001 
//=====================================================================
//
// all data in sfcdef already removed
//
   empty_layer = AREA (EXTENT) == 0
//
   NTUB_extent = EXTENT NTUB_no_sfcdef
   DIFF_extent = EXTENT DIFF_no_sfcdef
   MIDOX_extent = EXTENT MIDOX_no_sfcdef
   POLY1_extent = EXTENT POLY1_no_sfcdef
   NPLUS_extent = EXTENT NPLUS_no_sfcdef
   PPLUS_extent = EXTENT PPLUS_no_sfcdef
   HRES_extent = EXTENT HRES_no_sfcdef
   POLY2_extent = EXTENT POLY2_no_sfcdef
   CONT_extent = EXTENT CONT_no_sfcdef
   MET1_extent = EXTENT MET1_no_sfcdef
   VIA_extent = EXTENT VIA_no_sfcdef
   MET2_extent = EXTENT MET2_no_sfcdef
   VIA2_extent = EXTENT VIA2_no_sfcdef
   MET3_extent = EXTENT MET3_no_sfcdef
   PAD_extent = EXTENT PAD_no_sfcdef
#IFDEF fourmetal
   VIA3_extent = EXTENT VIA3_no_sfcdef
   MET4_extent = EXTENT MET4_no_sfcdef
#ELSE
   VIA3_extent = COPY empty_layer     
   MET4_extent = COPY empty_layer     
#ENDIF
   FIMP_extent = EXTENT FIMP_no_sfcdef
   NLDD_extent = EXTENT NLDD_no_sfcdef
   NLDD50_extent = EXTENT NLDD50_no_sfcdef
//
   LVTDEF_extent = EXTENT LVTDEf_no_sfcdef
   METCAP_extent = EXTENT METCAP_no_sfcdef
//
// hv layers
//
   DNTUB_extent = EXTENT DNTUB_no_sfcdef
   SNTUB_extent = EXTENT SNTUB_no_sfcdef
   DPTUB_extent = EXTENT DPTUB_no_sfcdef
   SPTUB_extent = EXTENT SPTUB_no_sfcdef
   HVOX_extent  = EXTENT HVOX_no_sfcdef
   NLD20V_extent = EXTENT NLD20V_no_sfcdef
//
// bipolar layers
//
   PBUDEF_extent = EXTENT PBUDEF_no_sfcdef
   BNTUB_extent = EXTENT BNTUB_no_sfcdef
   BNTUB2_extent = EXTENT BNTUB2_no_sfcdef
   BPOLY_extent = EXTENT BPOLY_no_sfcdef
   EMITT_extent = EXTENT EMITT_no_sfcdef
   COLL_extent = EXTENT COLL_no_sfcdef
   LPPLUS_extent = EXTENT LPPLUS_no_sfcdef
//
   HBT_extent = EXTENT HBT_no_sfcdef
   EPOLY_extent = EXTENT EPOLY_no_sfcdef
   NBUR_extent = EXTENT NBUR_no_sfcdef
//
// eeprom layer
//
   POLY0_extent = EXTENT POLY0_no_sfcdef
   HALO_extent = EXTENT HALO_no_sfcdef
   PLDD_extent = EXTENT PLDD_no_sfcdef
   EEHVOX_extent = EXTENT EEHVOX_no_sfcdef
   EEVTP_extent = EXTENT EEVTP_no_sfcdef
//
   design_extent_h35ee = 
   POLY0_extent OR                        
   (HALO_extent OR                       
   (PLDD_extent OR                       
   (EEHVOX_extent OR                       
   EEVTP_extent )))
//
   design_extent_s35 = 
   PBUDEF_extent OR
   (BNTUB_extent OR                         
   (BNTUB2_extent OR                         
   (BPOLY_extent OR                         
   (EMITT_extent OR                         
   (COLL_extent OR                         
   (HBT_extent OR                         
   (EPOLY_extent OR                         
   NBUR_extent )))))))                      
//
   design_extent_h35 = 
   DNTUB_extent OR                       
   (SNTUB_extent OR                       
   (DPTUB_extent OR                       
   (SPTUB_extent OR                       
   (HVOX_extent  OR                       
   NLD20V_extent ))))                
//
   design_extent =
   NTUB_extent OR
   (DIFF_extent OR
   (MIDOX_extent OR
   (POLY1_extent OR
   (NPLUS_extent OR
   (PPLUS_extent OR
   (HRES_extent OR
   (POLY2_extent OR
   (CONT_extent OR
   (MET1_extent OR
   (VIA_extent OR
   (MET2_extent OR
   (VIA2_extent OR
   (MET3_extent OR
   (PAD_extent OR
   (VIA3_extent OR
   (MET4_extent OR
   (FIMP_extent OR
   (NLDD_extent OR
   (LVTDEF_extent OR              
   (METCAP_extent OR              
   NLDD50_extent  ))))))))))))))))))))
//
//------------------------------------------------------------------------------------------
//
   design_extent_out_sfcdef = (EXTENT design_extent) NOT SFCDEF
   design_extent_out_sfcdef_h35 = (EXTENT (design_extent OR design_extent_h35)) NOT SFCDEF
   design_extent_out_sfcdef_s35 = (EXTENT (design_extent OR design_extent_s35)) NOT SFCDEF
   design_extent_out_sfcdef_h35ee = (EXTENT (design_extent OR (design_extent_h35ee OR design_extent_h35))) NOT SFCDEF
//
//------------------------------------------------------------------------------------------
//  check for missing c35 layer
//------------------------------------------------------------------------------------------
//
   MISS_NTUB_DFM0001 {@ DFM0001 : missing NTUB , design must contain all process layers
            FLATTEN( design_extent_out_sfcdef NOT ENCLOSE NTUB_NO_SFCDEF)  
   }
   MISS_DIFF_DFM0001 {@ DFM0001 : missing DIFF , design must contain all process layers
            FLATTEN( design_extent_out_sfcdef NOT ENCLOSE DIFF_NO_SFCDEF) 
   }
#IFDEF layer_midox
   MISS_MIDOX_DFM0001 {@ DFM0001 : missing MIDOX , design must contain all process layers
            FLATTEN( design_extent_out_sfcdef NOT ENCLOSE  MIDOX_NO_SFCDEF) 
   }
#ENDIF
   MISS_POLY1_DFM0001 {@ DFM0001 : missing POLY1 , design must contain all process layers
            FLATTEN( design_extent_out_sfcdef NOT ENCLOSE  POLY1_NO_SFCDEF) 
   }
   MISS_NPLUS_DFM0001 {@ DFM0001 : missing NPLUS , design must contain all process layers
            FLATTEN( design_extent_out_sfcdef NOT ENCLOSE  NPLUS_NO_SFCDEF) 
   }
   MISS_PPLUS_DFM0001 {@ DFM0001 : missing PPLUS , design must contain all process layers
            FLATTEN( design_extent_out_sfcdef NOT ENCLOSE  PPLUS_NO_SFCDEF) 
   }
#IFDEF layer_hres
   MISS_HRES_DFM0001 {@ DFM0001 : missing HRES , design must contain all process layers
            FLATTEN( design_extent_out_sfcdef NOT ENCLOSE  HRES_NO_SFCDEF) 
   }
#ENDIF

#IFDEF layer_poly2
   MISS_POLY2_DFM0001 {@ DFM0001 : missing POLY2 , design must contain all process layers
            FLATTEN( design_extent_out_sfcdef NOT ENCLOSE  POLY2_NO_SFCDEF )
   }
#ENDIF

#IFDEF layer_lvtdef
   MISS_LVTDEF_DFM0001 {@ DFM0001 : missing LVTDEF , design must contain all process layers
            FLATTEN( design_extent_out_sfcdef NOT ENCLOSE  LVTDEF_NO_SFCDEF)
   }
#ENDIF

#IFDEF layer_metcap
   MISS_METCAP_DFM0001 {@ DFM0001 : missing METCAP , design must contain all process layers
            FLATTEN( design_extent_out_sfcdef NOT ENCLOSE  METCAP_NO_SFCDEF)
   }
#ENDIF

   MISS_CONT_DFM0001 {@ DFM0001 : missing CONT , design must contain all process layers
            FLATTEN( design_extent_out_sfcdef NOT ENCLOSE  CONT_NO_SFCDEF) 
   }
   MISS_MET1_DFM0001 {@ DFM0001 : missing MET1 , design must contain all process layers
            FLATTEN( design_extent_out_sfcdef NOT ENCLOSE  MET1_NO_SFCDEF)  
   }
   MISS_VIA_DFM0001 {@ DFM0001 : missing VIA , design must contain all process layers
            FLATTEN( design_extent_out_sfcdef NOT ENCLOSE  VIA_NO_SFCDEF ) 
   }
   MISS_MET2_DFM0001 {@ DFM0001 : missing MET2 , design must contain all process layers
            FLATTEN( design_extent_out_sfcdef NOT ENCLOSE  MET2_NO_SFCDEF)  
   }
   MISS_VIA2_DFM0001 {@ DFM0001 : missing VIA2 , design must contain all process layers
            FLATTEN( design_extent_out_sfcdef NOT ENCLOSE  VIA2_NO_SFCDEF)  
   }
   MISS_MET3_DFM0001 {@ DFM0001 : missing MET3 , design must contain all process layers
            FLATTEN( design_extent_out_sfcdef NOT ENCLOSE  MET3_NO_SFCDEF)  
   }
   MISS_PAD_DFM0001 {@ DFM0001 : missing PAD , design must contain all process layers
            FLATTEN( design_extent_out_sfcdef NOT ENCLOSE  PAD_NO_SFCDEF ) 
   }
#IFDEF fourmetal
   MISS_VIA3_DFM0001 {@ DFM0001 : missing VIA3 , design must contain all process layers
            FLATTEN( design_extent_out_sfcdef NOT ENCLOSE  VIA3_NO_SFCDEF)  
   }
   MISS_MET4_DFM0001 {@ DFM0001 : missing MET4 , design must contain all process layers
            FLATTEN( design_extent_out_sfcdef NOT ENCLOSE  MET4_NO_SFCDEF)  
   }
#ENDIF
//
//------------------------------------------------------------------------------------------
//  check for missing c35B4ee layer
//------------------------------------------------------------------------------------------
//
// must be drawn on layout
//
#IFDEF PROCESS_IS_C35B4EE
//
   MISS_EEHVOX_DFM0001 {@ DFM0001 : missing EEHVOX, design must contain all process layers
            FLATTEN( design_extent_out_sfcdef_h35 NOT ENCLOSE  EEHVOX_NO_SFCDEF) 
   }
//
   MISS_PFIMP_DFM0001 {@ DFM0001 : missing PFIMP, design must contain all process layers
            FLATTEN( design_extent_out_sfcdef_h35 NOT ENCLOSE  PFIMP_NO_SFCDEF) 
   }
//
   MISS_EEVTP_DFM0001 {@ DFM0001 : missing EEVTP, design must contain all process layers
            FLATTEN( design_extent_out_sfcdef_h35 NOT ENCLOSE  EEVTP_NO_SFCDEF) 
   }
//
   MISS_PLDD_DFM0001 {@ DFM0001 : missing PLDD, design must contain all process layers
            FLATTEN( design_extent_out_sfcdef_h35 NOT ENCLOSE  PLDD_NO_SFCDEF) 
   }
//
   MISS_POLY0_DFM0001 {@ DFM0001 : missing POLY0, design must contain all process layers
            FLATTEN( design_extent_out_sfcdef_h35 NOT ENCLOSE  POLY0_NO_SFCDEF) 
   }
//
// HALO is generated
//
#ENDIF
//
//-------------------------------------------------------------------------------------------
// check for h35
//-------------------------------------------------------------------------------------------
//
#IFDEF PROCESS_IS_H35XX
//
   MISS_HVOX_DFM0001 {@ DFM0001 : missing HVOX, design must contain all process layers
            FLATTEN( design_extent_out_sfcdef_h35 NOT ENCLOSE  HVOX_NO_SFCDEF) 
   }
//
   MISS_DNTUB_DFM0001 {@ DFM0001 : missing DNTUB, design must contain all process layers
            FLATTEN( design_extent_out_sfcdef_h35 NOT ENCLOSE  DNTUB_NO_SFCDEF) 
   }
//
   MISS_SNTUB_DFM0001 {@ DFM0001 : missing SNTUB, design must contain all process layers
            FLATTEN( design_extent_out_sfcdef_h35 NOT ENCLOSE  SNTUB_NO_SFCDEF) 
   }
//
   MISS_DPTUB_DFM0001 {@ DFM0001 : missing DPTUB, design must contain all process layers
            FLATTEN( design_extent_out_sfcdef_h35 NOT ENCLOSE  DPTUB_NO_SFCDEF) 
   }
//
   MISS_SPTUB_DFM0001 {@ DFM0001 : missing SPTUB, design must contain all process layers
            FLATTEN( design_extent_out_sfcdef_h35 NOT ENCLOSE  SPTUB_NO_SFCDEF) 
   }
//
   MISS_NLD20V_DFM0001 {@ DFM0001 : missing NLD20V, design must contain all process layers
            FLATTEN( design_extent_out_sfcdef_h35 NOT ENCLOSE  NLD20V_NO_SFCDEF) 
   }
#ENDIF
//
//-------------------------------------------------------------------------------------------
// check for s35
//-------------------------------------------------------------------------------------------
//
#IFDEF PROCESS_IS_S35XX
   MISS_BNTUB_DFM0001 {@ DFM0001 : missing BNTUB, design must contain all process layers
            FLATTEN( design_extent_out_sfcdef_s35 NOT ENCLOSE  BNTUB_NO_SFCDEF) 
   }
   MISS_BNTUB2_DFM0001 {@ DFM0001 : missing BNTUB2, design must contain all process layers
            FLATTEN( design_extent_out_sfcdef_s35 NOT ENCLOSE  BNTUB2_NO_SFCDEF) 
   }
   MISS_BPOLY_DFM0001 {@ DFM0001 : missing BPOLY, design must contain all process layers
            FLATTEN( design_extent_out_sfcdef_s35 NOT ENCLOSE  BPOLY_NO_SFCDEF) 
   }
   MISS_EMITT_DFM0001 {@ DFM0001 : missing EMITT, design must contain all process layers
            FLATTEN( design_extent_out_sfcdef_s35 NOT ENCLOSE  EMITT_NO_SFCDEF) 
   }
   MISS_COLL_DFM0001 {@ DFM0001 : missing COLL, design must contain all process layers
            FLATTEN( design_extent_out_sfcdef_s35 NOT ENCLOSE  COLL_NO_SFCDEF) 
   }
   MISS_EPOLY_DFM0001 {@ DFM0001 : missing EPOLY, design must contain all process layers
            FLATTEN( design_extent_out_sfcdef_s35 NOT ENCLOSE  EPOLY_NO_SFCDEF) 
   }
//
#IFDEF layer_lpplus
   MISS_LPPLUS_DFM0001 {@ DFM0001 : missing LPPLUS, design must contain all process layers
            FLATTEN( design_extent_out_sfcdef_s35 NOT ENCLOSE  LPPLUS_NO_SFCDEF) 
   }
#ENDIF
//
#ENDIF
//
///////////////////////////////////////////////////////////////////////
//
//                   generated layer for c35 
//
///////////////////////////////////////////////////////////////////////
//
#IFDEF PROCESS_IS_C35XX
//
// no data on generated layers
//
   MISS_FIMP_DFM0001 {@ DFM0001 : missing FIMP , design must contain all process layers
            FLATTEN( design_extent_out_sfcdef NOT ENCLOSE  FIMP_NO_SFCDEF)  
   }
   MISS_NLDD_DFM0001 {@ DFM0001 : missing NLDD , design must contain all process layers
            FLATTEN( design_extent_out_sfcdef NOT ENCLOSE  NLDD_NO_SFCDEF)  
   }
   MISS_NLDD50_DFM0001 {@ DFM0001 : missing NLDD50 , design must contain all process layers
            FLATTEN( design_extent_out_sfcdef NOT ENCLOSE  NLDD50_NO_SFCDEF)  
   }
//
//----------------------------------------------------------------------
//
// nmos30m :
// fimp:
//--------
// add fidef to fimp
// FIMP width 1.7/spacing 1.0       (NTUB NOT (SFC OR HVDEF)) OR FIDEF
//
// nldd:
//------
// add nplus from nmos30t/m
// NLDD width 0.6/spacing 0.6       ((NPLUS NOT MIDOX) NOT (SFC OR HVDEF)) OR (NPLUS INSIDE nmos30m_hvdef_ok)
//
// nldd50:
//--------
// NLDD50 width 0.6/ spacing 0.6    (NPLUS AND MIDOX) NOT (SFC OR HVDEF)
//
//----------------------------------------------------------------------
//
// fimp layer
//
// generate in nmos30m/nmos30t
    MISSING_BAD_FIMP_DFM0001 { @ DFM0001 Design must contain all process layer
                               @ Generated Layers: FIMP is not a copy of NTUB NOT (SFCDEF OR HVDEF)
       generated_fimp_out_nmos30m  = NTUB NOT (SFCDEF OR HVDEF)
       generated_fimp_in_nmos30m  = COPY FIDEF
       generated_fimp = generated_fimp_out_nmos30m OR generated_fimp_in_nmos30m
       generated_fimp XOR FIMP_NO_SFCDEF
    }
//
// nldd
//
// generate in nmos30m/t with valid text in HVDEF
// use any HVDEF
   nmos30m_hvdef_ok = COPY HVDEF
   MISSING_BAD_NLDD_DFM0001 { @ DFM0001 Design must contain all process layer
                              @ Generated Layers: NLDD is not : (NPLUS NOT (SFCDEF OR HVDEF)) NOT MIDOX
       generated_nldd_out_nmos30m = (NPLUS NOT (SFCDEF OR HVDEF)) NOT MIDOX
       generated_nldd_in_nmos30m =   NPLUS INSIDE nmos30m_hvdef_ok
       generated_nldd = generated_nldd_out_nmos30m OR generated_nldd_in_nmos30m
       generated_nldd XOR NLDD_NO_SFCDEF
   }
//
// nldd50
//
// do NOT generate inside nmos30m/nmos30t
   MISSING_BAD_NLDD50_DFM0001 { @ DFM0001 Design must contain all process layer
                                @ Generated Layers: NLDD50 is not : (NPLUS NOT (SFCDEF OR HVDEF)) AND MIDOX
       generated_nldd50_out_nmos30m = (NPLUS NOT (SFCDEF OR HVDEF)) AND MIDOX
       generated_nldd50_out_nmos30m XOR NLDD50_NO_SFCDEF
   }
//
#ENDIF
///////////////////////////////////////////////////////////////////////
//
//                   generated layer for s35 
//
///////////////////////////////////////////////////////////////////////
//
#IFDEF PROCESS_IS_S35XX
//
// no data on generated layers
//
   MISS_FIMP_DFM0001 {@ DFM0001 : missing FIMP , design must contain all process layers
            FLATTEN( design_extent_out_sfcdef_s35 NOT ENCLOSE  FIMP_NO_SFCDEF)  
   }
   MISS_NLDD_DFM0001 {@ DFM0001 : missing NLDD , design must contain all process layers
            FLATTEN( design_extent_out_sfcdef_s35 NOT ENCLOSE  NLDD_NO_SFCDEF)  
   }
//
#IFNDEF process_C35B4M3
   MISS_HBT_DFM0001 {@ DFM0001 : missing HBT, design must contain all process layers
            FLATTEN( design_extent_out_sfcdef_s35 NOT ENCLOSE  HBT_NO_SFCDEF) 
   }
   MISS_NBUR_DFM0001 {@ DFM0001 : missing NBUR, design must contain all process layers
            FLATTEN( design_extent_out_sfcdef_s35 NOT ENCLOSE  NBUR_NO_SFCDEF) 
   }
//
// nbur
//
// 21-Jan-2005 diable nbur,hbt for c35b4m3
   MISSING_BAD_NBUR_DFM0001 { @ Generated layers: missing NBUR layer
                              @ Generated Layers: NBUR is not a copy of BNTUB SIZE BY -2.0        
     // x1 = (BNTUB NOT PBUDEF) SIZE BY -2.0
     x1 = BNTUB SIZE BY -2.0
     x1 XOR NBUR
   }
//
// bipolar hbt open mask 
//
   MISSING_BAD_HBT_DFM0001 { @ Generated layers: missing HBT layer
                             @ Generated Layers: HBT is not a copy of  ( DIFF AND BPOLY )        
       HBT XOR ( DIFF AND BPOLY )
   }
#ENDIF
//
// fimp layer
//
    MISSING_BAD_FIMP_DFM0001 { @ Generated layers: missing FIMP layer
                               @ Generated Layers: FIMP is not a copy of (NTUB OR BNTUB) NOT SFCDEF 
       ((NTUB OR BNTUB) NOT SFCDEF) XOR FIMP
    }
//
// nldd
//
   MISSING_BAD_NLDD_DFM0001 { @ Generated layers: missing NLDD layer
                              @ Generated Layers: NLDD is not a copy of  (NPLUS NOT MIDOX )    
       NLDD XOR (NPLUS NOT MIDOX )
   }
//
// nldd50
//
#IFDEF layer_midox
   MISS_NLDD50_DFM0001 {@ DFM0001 : missing NLDD50 , design must contain all process layers
            FLATTEN( design_extent_out_sfcdef_s35 NOT ENCLOSE  NLDD50_NO_SFCDEF)  
   }
//
   MISSING_BAD_NLDD50_DFM0001 { @ Generated layers: missing NLDD50 layer
                               @ Generated Layers: NLDD50 is not a copy of  (NPLUS AND MIDOX )    
       NLDD50 XOR (NPLUS AND MIDOX )
   }
#ENDIF

#ENDIF
//
///////////////////////////////////////////////////////////////////////
//   
//         end of layer definition and layer checks
//
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//
//                 KEPOUT and IPDEF checks
//
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//
// CALIBRE  DFM R U L E S   F I L E   F O R   P R O C E S S   C 3 5
//
///////////////////////////////////////////////////////////////////////
//
// CMOS C35 DFM rules  Document: ENG-301                Revision: REV 3        
//
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//-------------------------------------------------------------------------------
//     rev     date            by                      comment
//-------------------------------------------------------------------------------
//    1.00   4-Jul-2006      aob      basic version for x35xx
//                                    check all layers over KEPOUT
//                                    check all layer spacing to KEPOUT/SFCDEF
//
//                                    some switches for process modules 
//                                    almost all layers are checked
//-------------------------------------------------------------------------------
//
// no SFCDEF on device ??? Is this ok
//
   MISS_SFCDEF_TPTXXX6 { @ INFO : No SFCDEF data found on design, is this ok, does chip does not have REVBLK ???
        FLATTEN( (EXTENT) NOT INTERACT SFCDEF)
   }
//
   kepout_or_sfcdef = KEPOUT OR SFCDEF
//   
//   NTUB 5
//   
// NTUB overlapping KEPOUT is not allowed
   ILL_NTUB_OVER_KEPOUT_NWR001_TPTXXX6 { @ KEPOUT definition : (NTUB AND KEPOUT) is not allowed 
          NTUB_alldata AND KEPOUT
   }
// Minimum NTUB spacing to KEPOUT or SFCDEF = 3
   SPAC_NTUB_SFCDEF_S1KOXX_TPTXXX6 { @ KEPOUT definition : Minimum spacing NTUB to (KEPOUT or SFCDEF) = 3
        EXT  NTUB_alldata kepout_or_sfcdef < 3 ABUT == 0 REGION
   }
//   
//   DIFF 10
//   
// DIFF overlapping KEPOUT is not allowed
   ILL_DIFF_OVER_KEPOUT_AAR001_TPTXXX6 { @ KEPOUT definition : (DIFF AND KEPOUT) is not allowed 
          DIFF_alldata AND KEPOUT
   }
// Minimum DIFF spacing to KEPOUT or SFCDEF = 0.6
   SPAC_DIFF_SFCDEF_S1AAKO_TPTXXX6 { @ KEPOUT definition : Minimum spacing DIFF to (KEPOUT or SFCDEF) = 0.6
        EXT  DIFF_alldata kepout_or_sfcdef < 0.6 ABUT == 0 REGION
   }
//   
//   MIDOX 14
//   
// MIDOX overlapping KEPOUT is not allowed
   ILL_MIDOX_OVER_KEPOUT_XMR002_TPTXXX6 { @ KEPOUT definition : (MIDOX AND KEPOUT) is not allowed 
          MIDOX_alldata AND KEPOUT
   }
// Minimum MIDOX spacing to KEPOUT or SFCDEF = 0.6
   SPAC_MIDOX_SFCDEF_S1KOXM_TPTXXX6 { @ KEPOUT definition : Minimum spacing MIDOX to (KEPOUT or SFCDEF) = 0.6
        EXT  MIDOX_alldata kepout_or_sfcdef < 0.6 ABUT == 0 REGION
   }
//   
//   POLY1 20
//   
// POLY1 overlapping KEPOUT is not allowed
   ILL_POLY1_OVER_KEPOUT_P1R002_TPTXXX6 { @ KEPOUT definition : (POLY1 AND KEPOUT) is not allowed 
          POLY1_alldata AND KEPOUT
   }
// Minimum POLY1 spacing to KEPOUT or SFCDEF = 0.45
   SPAC_POLY1_SFCDEF_S1KOXX_TPTXXX6 { @ KEPOUT definition : Minimum spacing POLY1 to (KEPOUT or SFCDEF) = S1KOP1
        EXT  POLY1_alldata kepout_or_sfcdef < 0.45 ABUT == 0 REGION
   }
//   
//   NPLUS 23
//   
// NPLUS overlapping KEPOUT is not allowed
   ILL_NPLUS_OVER_KEPOUT_NSR001_TPTXXX6 { @ KEPOUT definition : (NPLUS AND KEPOUT) is not allowed 
          NPLUS_alldata AND KEPOUT
   }
// Minimum NPLUS spacing to KEPOUT or SFCDEF = 0.6
   SPAC_NPLUS_SFCDEF_S1KOXX_TPTXXX6 { @ KEPOUT definition : Minimum spacing NPLUS to (KEPOUT or SFCDEF) = S1KONS
        EXT  NPLUS_alldata kepout_or_sfcdef < 0.6 ABUT == 0 REGION
   }
//   
//   PPLUS 24
//   
// PPLUS overlapping KEPOUT is not allowed
   ILL_PPLUS_OVER_KEPOUT_PSR001_TPTXXX6 { @ KEPOUT definition : (PPLUS AND KEPOUT) is not allowed 
          PPLUS_alldata AND KEPOUT
   }
// Minimum PPLUS spacing to KEPOUT or SFCDEF = 0.6
   SPAC_PPLUS_SFCDEF_S1KOXX_TPTXXX6 { @ KEPOUT definition : Minimum spacing PPLUS to (KEPOUT or SFCDEF) = 0.6
        EXT  PPLUS_alldata kepout_or_sfcdef < 0.6 ABUT == 0 REGION
   }
//   
//   HRES 29
//   
// HRES overlapping KEPOUT is not allowed
   ILL_HRES_OVER_KEPOUT_HRR004_TPTXXX6 { @ KEPOUT definition : (HRES AND KEPOUT) is not allowed 
          HRES_alldata AND KEPOUT
   }
// Minimum HRES spacing to KEPOUT or SFCDEF = 0.6
   SPAC_HRES_SFCDEF_S1KOXX_TPTXXX6 { @ KEPOUT definition : Minimum spacing HRES to (KEPOUT or SFCDEF) = 0.6
        EXT  HRES_alldata kepout_or_sfcdef < 0.6 ABUT == 0 REGION
   }
//   
//   POLY2 30
//   
// POLY2 overlapping KEPOUT is not allowed
   ILL_POLY2_OVER_KEPOUT_P2R002_TPTXXX6 { @ KEPOUT definition : (POLY2 AND KEPOUT) is not allowed 
          POLY2_alldata AND KEPOUT
   }
// Minimum POLY2 spacing to KEPOUT or SFCDEF = 0.6
   SPAC_POLY2_SFCDEF_S1KOP2_TPTXXX6 { @ KEPOUT definition : Minimum spacing POLY2 to (KEPOUT or SFCDEF) = 0.6
        EXT  POLY2_alldata kepout_or_sfcdef < 0.6 ABUT == 0 REGION
   }
//   
//   CONT 34
//   
// CONT overlapping KEPOUT is not allowed
   ILL_CONT_OVER_KEPOUT_COR002_TPTXXX6 { @ KEPOUT definition : (CONT AND KEPOUT) is not allowed 
          CONT_alldata AND KEPOUT
   }
// Minimum CONT spacing to KEPOUT or SFCDEF = 0.4
   SPAC_CONT_SFCDEF_S1COKO_TPTXXX6 { @ KEPOUT definition : Minimum spacing CONT to (KEPOUT or SFCDEF) = 0.4
        EXT  CONT_alldata kepout_or_sfcdef < 0.4 ABUT == 0 REGION
   }
//   
//   MET1 35
//   
// MET1 overlapping KEPOUT is not allowed
   ILL_MET1_OVER_KEPOUT_M1R002_TPTXXX6 { @ KEPOUT definition : (MET1 AND KEPOUT) is not allowed 
          MET1_alldata AND KEPOUT
   }
// Minimum MET1 spacing to KEPOUT or SFCDEF = 0.45
   SPAC_MET1_SFCDEF_S1KOM1_TPTXXX6 { @ KEPOUT definition : Minimum spacing MET1 to (KEPOUT or SFCDEF) = 0.45
        EXT  MET1_alldata kepout_or_sfcdef < 0.45 ABUT == 0 REGION
   }
//   
//   VIA 36
//   
// VIA1 overlapping KEPOUT is not allowed
   ILL_VIA_OVER_KEPOUT_V1R002_TPTXXX6 { @ KEPOUT definition : (VIA AND KEPOUT) is not allowed 
          VIA_alldata AND KEPOUT
   }
// Minimum VIA1 spacing to KEPOUT or SFCDEF = 0.45
   SPAC_VIA_SFCDEF_S1KOV1_TPTXXX6 { @ KEPOUT definition : Minimum spacing VIA to (KEPOUT or SFCDEF) = S1KOV1
        EXT  VIA_alldata kepout_or_sfcdef < 0.45 ABUT == 0 REGION
   }
//   
//   MET2 37
//   
// MET2 overlapping KEPOUT is not allowed
   ILL_MET2_OVER_KEPOUT_M2R002_TPTXXX6 { @ KEPOUT definition : (MET2 AND KEPOUT) is not allowed 
          MET2_alldata AND KEPOUT
   }
// Minimum MET2 spacing to KEPOUT or SFCDEF = 0.6 
// use 0.5
   SPAC_MET2_SFCDEF_S1KOXX_TPTXXX6 { @ KEPOUT definition : Minimum spacing MET2 to (KEPOUT or SFCDEF) = 0.5
        EXT  MET2_alldata kepout_or_sfcdef < 0.5 ABUT == 0 REGION
   }
//   
//   VIA2 38
//   
// VIA2 overlapping KEPOUT is not allowed
   ILL_VIA2_OVER_KEPOUT_V2R002_TPTXXX6 { @ KEPOUT definition : (VIA2 AND KEPOUT) is not allowed 
          VIA2_alldata AND KEPOUT
   }
// Minimum VIA2 spacing to KEPOUT or SFCDEF = 0.45
   SPAC_VIA2_SFCDEF_S1KOV2_TPTXXX6 { @ KEPOUT definition : Minimum spacing VIA2 to (KEPOUT or SFCDEF) = 0.45
        EXT  VIA2_alldata kepout_or_sfcdef < 0.45 ABUT == 0 REGION
   }
//   
//   MET3 39
//   
// MET3 overlapping KEPOUT is not allowed
   ILL_MET3_OVER_KEPOUT_M3R002_TPTXXX6 { @ KEPOUT definition : (MET3 AND KEPOUT) is not allowed 
          MET3_alldata AND KEPOUT
   }
// Minimum MET3 spacing to KEPOUT or SFCDEF = 0.6
   SPAC_MET3_SFCDEF_S1KOM3_TPTXXX6 { @ KEPOUT definition : Minimum spacing MET3 to (KEPOUT or SFCDEF) = 0.6
        EXT  MET3_alldata kepout_or_sfcdef < 0.6 ABUT == 0 REGION
   }
//   
//   PAD 40
//   
// PAD overlapping KEPOUT is not allowed
   ILL_PAD_OVER_KEPOUT_PAR002_TPTXXX6 { @ KEPOUT definition : (PAD AND KEPOUT) is not allowed 
          PAD_alldata AND KEPOUT
   }
// Minimum PAD spacing to KEPOUT or SFCDEF = 9
   SPAC_PAD_SFCDEF_S1KOPA_TPTXXX6 { @ KEPOUT definition : Minimum spacing PAD to (KEPOUT or SFCDEF) = 9
        EXT  PAD_alldata kepout_or_sfcdef < 9 ABUT == 0 REGION
   }
//   
//   VIA3 41
//   
// VIA3 overlapping KEPOUT is not allowed
   ILL_VIA3_OVER_KEPOUT_V3R002_TPTXXX6 { @ KEPOUT definition : (VIA3 AND KEPOUT) is not allowed 
          VIA3_alldata AND KEPOUT
   }
// Minimum VIA3 spacing to KEPOUT or SFCDEF = 0.45
   SPAC_VIA3_SFCDEF_S1KOV3_TPTXXX6 { @ KEPOUT definition : Minimum spacing VIA3 to (KEPOUT or SFCDEF) = 0.45
        EXT  VIA3_alldata kepout_or_sfcdef < 0.45 ABUT == 0 REGION
   }
//   
//   MET4 42
//   
// MET4 overlapping KEPOUT is not allowed
   ILL_MET4_OVER_KEPOUT_M4R002_TPTXXX6 { @ KEPOUT definition : (MET4 AND KEPOUT) is not allowed 
          MET4_alldata AND KEPOUT
   }
// Minimum MET4 spacing to KEPOUT or SFCDEF = 0.6
   SPAC_MET4_SFCDEF_S1KOM4_TPTXXX6 { @ KEPOUT definition : Minimum spacing MET4 to (KEPOUT or SFCDEF) = 0.6
        EXT  MET4_alldata kepout_or_sfcdef < 0.6 ABUT == 0 REGION
   }
//
//   METCAP 
//   
// METCAP overlapping KEPOUT is not allowed
//   ILL_METCAP_OVER_KEPOUT_MCR002 { @ KEPOUT definition : (METCAP AND KEPOUT) is not allowed 
//          METCAP AND KEPOUT
//   }
// Minimum METCAP spacing to KEPOUT or SFCDEF = 0.8
//   SPAC_METCAP_KEPOUT_S1MCKO { @ KEPOUT definition : Minimum spacing METCAP to (KEPOUT or SFCDEF) = 0.8
//        EXT METCAP kepout_or_sfcdef < 0.8 ABUT == 0 REGION
//   }
//
//----------------------------------------------------------------------------
//                                  h35
//----------------------------------------------------------------------------
#IFDEF PROCESS_IS_H35XX
//
//   DNTUB 4
//
// DNTUB overlapping KEPOUT is not allowed
   ILL_DNTUB_OVER_KEPOUT_DNR006_TPTXXX6 { @ KEPOUT definition : (DNTUB AND KEPOUT) is not allowed
          DNTUB AND KEPOUT
   }
// Minimum DNTUB spacing to KEPOUT or SFCDEF = 4.5
   SPAC_DNTUB_KEPOUT_S1DNKO_TPTXXX6 { @ KEPOUT definition : Minimum spacing DNTUB to (KEPOUT or SFCDEF) = 4.5
        EXT  DNTUB kepout_or_sfcdef < 4.5 ABUT == 0 REGION
   }
//
//   SNTUB 6
//
// SNTUB overlapping KEPOUT is not allowed
   ILL_SNTUB_OVER_KEPOUT_SNR006_TPTXXX6 { @ KEPOUT definition : (SNTUB AND KEPOUT) is not allowed
          SNTUB AND KEPOUT
   }
// Minimum SNTUB spacing to KEPOUT or SFCDEF = 4
   SPAC_SNTUB_KEPOUT_S1KOSN_TPTXXX6 { @ KEPOUT definition : Minimum spacing SNTUB to (KEPOUT or SFCDEF) = 4
        EXT  SNTUB kepout_or_sfcdef < 4 ABUT == 0 REGION
   }
//
//   DPTUB 7
//
// DPTUB overlapping KEPOUT is not allowed
   ILL_DPTUB_OVER_KEPOUT_DPR003_TPTXXX6 { @ KEPOUT definition : (DPTUB AND KEPOUT) is not allowed
          DPTUB AND KEPOUT
   }
// Minimum DPTUB spacing to KEPOUT or SFCDEF = 1.7
   SPAC_DPTUB_KEPOUT_S1DPKO_TPTXXX6 { @ KEPOUT definition : Minimum spacing DPTUB to (KEPOUT or SFCDEF) = 1.7
        EXT  DPTUB kepout_or_sfcdef < 1.7 ABUT == 0 REGION
   }
//
//   SPTUB 57
//
// SPTUB overlapping KEPOUT is not allowed
   ILL_SPTUB_OVER_KEPOUT_SPR003_TPTXXX6 { @ KEPOUT definition : (SPTUB AND KEPOUT) is not allowed
          SPTUB AND KEPOUT
   }
// Minimum SPTUB spacing to KEPOUT or SFCDEF = 1.7
   SPAC_SPTUB_KEPOUT_S1KOSP_TPTXXX6 { @ KEPOUT definition : Minimum spacing SPTUB to (KEPOUT or SFCDEF) = S1KOSP
        EXT  SPTUB kepout_or_sfcdef < 1.7 ABUT == 0 REGION
   }
//   HVOX 56
//
// HVOX overlapping KEPOUT is not allowed
   ILL_HVOX_OVER_KEPOUT_HXR002_TPTXXX6 { @ KEPOUT definition : (HVOX AND KEPOUT) is not allowed
          HVOX AND KEPOUT
   }
// Minimum HVOX spacing to KEPOUT or SFCDEF = 0.6
   SPAC_HVOX_KEPOUT_S1HXKO_TPTXXX6 { @ KEPOUT definition : Minimum spacing HVOX to (KEPOUT or SFCDEF) = 0.6
        EXT  HVOX kepout_or_sfcdef < 0.6 ABUT == 0 REGION
   }
//
#ENDIF
//----------------------------------------------------------------------------
//                                  s35
//----------------------------------------------------------------------------
//
#IFDEF PROCESS_IS_S35XX
//
// preliminary added
//
// BNTUB
   ILL_BNTUB_OVER_KEPOUT_TPTXXX6 { @ KEPOUT definition : (BNTUB AND KEPOUT) is not allowed
          BNTUB AND KEPOUT
   }
   SPAC_BNTUB_KEPOUT_TPTXXX6 { @ KEPOUT definition : Minimum spacing BNTUB to (KEPOUT or SFCDEF) = 4.0
        EXT BNTUB kepout_or_sfcdef < 4.0 ABUT == 0 REGION
   }
//
   ILL_BNTUB2_OVER_KEPOUT_TPTXXX6 { @ KEPOUT definition : (BNTUB2 AND KEPOUT) is not allowed
          BNTUB2 AND KEPOUT
   }
   SPAC_BNTUB2_KEPOUT_TPTXXX6 { @ KEPOUT definition : Minimum spacing BNTUB2 to (KEPOUT or SFCDEF) = 0.1
        EXT BNTUB2 kepout_or_sfcdef < 0.1 ABUT == 0 REGION
   }
//
// COLL
   ILL_COLL_OVER_KEPOUT_TPTXXX6 { @ KEPOUT definition : (COLL AND KEPOUT) is not allowed
          COLL AND KEPOUT
   }
   SPAC_COLL_KEPOUT_TPTXXX6 { @ KEPOUT definition : Minimum spacing COLL to (KEPOUT or SFCDEF) = 0.6
        EXT COLL kepout_or_sfcdef < 0.6 ABUT == 0 REGION
   }
//
// BPOLY
   ILL_BPOLY_OVER_KEPOUT_TPTXXX6 { @ KEPOUT definition : (BPOLY AND KEPOUT) is not allowed
          BPOLY AND KEPOUT
   }
   SPAC_BPOLY_KEPOUT_TPTXXX6 { @ KEPOUT definition : Minimum spacing BPOLY to (KEPOUT or SFCDEF) = 0.5
        EXT BPOLY kepout_or_sfcdef < 0.5 ABUT == 0 REGION
   }
// EMITT
   ILL_EMITT_OVER_KEPOUT_TPTXXX6 { @ KEPOUT definition : (EMITT AND KEPOUT) is not allowed
          EMITT AND KEPOUT
   }
   SPAC_EMITT_KEPOUT_TPTXXX6 { @ KEPOUT definition : Minimum spacing EMITT to (KEPOUT or SFCDEF) = 1.2
        EXT EMITT kepout_or_sfcdef < 1.2 ABUT == 0 REGION
   }
//
// EPOLY
   ILL_EPOLY_OVER_KEPOUT_TPTXXX6 { @ KEPOUT definition : (EPOLY AND KEPOUT) is not allowed
          EPOLY AND KEPOUT
   }
   SPAC_EPOLY_KEPOUT_TPTXXX6 { @ KEPOUT definition : Minimum spacing EPOLY to (KEPOUT or SFCDEF) = 0.5
        EXT EPOLY kepout_or_sfcdef < 0.5 ABUT == 0 REGION
   }
//
#ENDIF
//----------------------------------------------------------------------------
//                                 c35b4ee
//----------------------------------------------------------------------------
//
#IFDEF PROCESS_IS_C35B4EE
// POLY0
   ILL_POLY0_OVER_KEPOUT_TPTXXX6 { @ KEPOUT definition : (POLY0 AND KEPOUT) is not allowed
          POLY0 AND KEPOUT
   }
   SPAC_POLY0_KEPOUT_TPTXXX6 { @ KEPOUT definition : Minimum spacing POLY0 to (KEPOUT or SFCDEF) = 0.45
        EXT POLY0 kepout_or_sfcdef < 0.45 ABUT == 0 REGION
   }
// PLDD
   ILL_PLDD_OVER_KEPOUT_TPTXXX6 { @ KEPOUT definition : (PLDD AND KEPOUT) is not allowed
          PLDD AND KEPOUT
   }
   SPAC_PLDD_KEPOUT_TPTXXX6 { @ KEPOUT definition : Minimum spacing PLDD to (KEPOUT or SFCDEF) = 0.6
        EXT PLDD kepout_or_sfcdef < 0.6  ABUT == 0 REGION
   }
// EEHVOX
   ILL_EEHVOX_OVER_KEPOUT_TPTXXX6 { @ KEPOUT definition : (EEHVOX AND KEPOUT) is not allowed
          EEHVOX AND KEPOUT
   }
   SPAC_EEHVOX_KEPOUT_TPTXXX6 { @ KEPOUT definition : Minimum spacing EEHVOX to (KEPOUT or SFCDEF) = 0.6
        EXT EEHVOX kepout_or_sfcdef < 0.6  ABUT == 0 REGION
   }
// EEVTP 
   ILL_EEVTP_OVER_KEPOUT_TPTXXX6 { @ KEPOUT definition : (EEVTP  AND KEPOUT) is not allowed
          EEVTP  AND KEPOUT
   }
   SPAC_EEVTP_KEPOUT_TPTXXX6 { @ KEPOUT definition : Minimum spacing EEVTP  to (KEPOUT or SFCDEF) = 0.6
        EXT EEVTP  kepout_or_sfcdef < 0.6  ABUT == 0 REGION
   }
// PFIMP 
   ILL_PFIMP_OVER_KEPOUT_TPTXXX6 { @ KEPOUT definition : (PFIMP  AND KEPOUT) is not allowed
          PFIMP  AND KEPOUT
   }
   SPAC_PFIMP_KEPOUT_TPTXXX6 { @ KEPOUT definition : Minimum spacing PFIMP  to (KEPOUT or SFCDEF) = 0.6
        EXT PFIMP  kepout_or_sfcdef < 0.6  ABUT == 0 REGION
   }
//
#ENDIF
//----------------------------------------------------------------------------
//                                 h35ee  
//----------------------------------------------------------------------------
#IFDEF PROCESS_IS_H35EE  
// HALO is drawn
//
// POLY0
   ILL_POLY0_OVER_KEPOUT_TPTXXX6 { @ KEPOUT definition : (POLY0 AND KEPOUT) is not allowed
          POLY0 AND KEPOUT
   }
   SPAC_POLY0_KEPOUT_TPTXXX6 { @ KEPOUT definition : Minimum spacing POLY0 to (KEPOUT or SFCDEF) = 0.45
        EXT POLY0 kepout_or_sfcdef < 0.45 ABUT == 0 REGION
   }
// PLDD
   ILL_PLDD_OVER_KEPOUT_TPTXXX6 { @ KEPOUT definition : (PLDD0 AND KEPOUT) is not allowed
          PLDD AND KEPOUT
   }
   SPAC_PLDD_KEPOUT_TPTXXX6 { @ KEPOUT definition : Minimum spacing PLDD to (KEPOUT or SFCDEF) = 0.6
        EXT PLDD kepout_or_sfcdef < 0.6  ABUT == 0 REGION
   }
// EEHVOX
   ILL_EEHVOX_OVER_KEPOUT_TPTXXX6 { @ KEPOUT definition : (EEHVOX AND KEPOUT) is not allowed
          EEHVOX AND KEPOUT
   }
   SPAC_EEHVOX_KEPOUT_TPTXXX6 { @ KEPOUT definition : Minimum spacing EEHVOX to (KEPOUT or SFCDEF) = 0.6
        EXT EEHVOX kepout_or_sfcdef < 0.6  ABUT == 0 REGION
   }
// EEVTP 
   ILL_EEVTP_OVER_KEPOUT_TPTXXX6 { @ KEPOUT definition : (EEVTP  AND KEPOUT) is not allowed
          EEVTP AND KEPOUT
   }
   SPAC_EEVTP_KEPOUT_TPTXXX6 { @ KEPOUT definition : Minimum spacing EEVTP  to (KEPOUT or SFCDEF) = 0.6
        EXT EEVTP kepout_or_sfcdef < 0.6  ABUT == 0 REGION
   }
// HALO  
   ILL_HALO_OVER_KEPOUT_TPTXXX6 { @ KEPOUT definition : (HALO AND KEPOUT) is not allowed
          HALO AND KEPOUT
   }
   SPAC_HALO_KEPOUT_TPTXXX6 { @ KEPOUT definition : Minimum spacing HALO to (KEPOUT or SFCDEF) = 0.6
        EXT HALO kepout_or_sfcdef < 0.6  ABUT == 0 REGION
   }
//
#ENDIF
//   
///////////////////////////////////////////////////////////////////////
//   
//                 end of KEPOUT and IPDEF checks
//
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//
//                       DFM part1 checks 
//
///////////////////////////////////////////////////////////////////////
//
// CMOS C35 DFM rules  Document: ENG-301                Revision: REV 3
//
///////////////////////////////////////////////////////////////////////
//=====================================================================
//   Version          Date           by       Description
//---------------------------------------------------------------------
//    2.0          30-Jun-2008     aob    general update
//                 24-Jul-2008     aob    fix rpoly2 resend
//---------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////
//=====================================================================
// TPTXXX1 : check for reduced cells
//=====================================================================
//
// tapout check
//
   ERROR_REDUCED_CELL_TPTXXX1 {@ TPTXXX1 Error : Reduced cell found, data incomplete
               EXPAND TEXT "LAYOUT:REDUCED" RESDEF_TEXT BY 2
   }
//
   ERROR_IP_BLOCK_INCOMPLETE_TPTXXX2 {@ TPTXXX2 Error : KEPOUT Layer on data , IP Block not inserted
               COPY KEPOUT                                   
   }
//
//=====================================================================
// TPTXXX3 : check for layer ZENER inside correct zap block version
//=====================================================================
//
// number of bits 10, 32, 16...
// ZAP32_LSH_V31  ... lsh = level shift
// ZAP16_LSH_V31
//
// 27.9.04  check for V33
//  7.4.05  check for V35
//
  ILL_OLD_ZAPBLOCK_TPTXXX3 { @ TPTXXX3 : Warning : zener layer not inside correct zap block version
     NOT INSIDE CELL ZENER_alldata  "ZAP*_LSH_V35*"
  }
//
// 27.1.05
// next 2 checks info only
//  ZENER_DIODE_DEFINITION { @ Information : there is a zener diode on data, please check if valid
//     COPY ZENER
//  }
//
//  ZAP_BLOCK_ZAPXX_LSH_V35 { @ Information : there is a ZAP Block named ZAPxx_LSH_V35xx on data
//     EXTENT CELL "ZAP*_LSH_V35*"
//  }
//
//=====================================================================
// DFM0006/ DFM0007 check for G01P1/G01P2
//=====================================================================
//
// cannot use density check, because density uses bounding box of polygons
//
   poly1_n_poly2    = POLY1 NOT POLY2
   poly1con         = CONT AND poly1_n_poly2
   con_n_p1         = CONT NOT poly1con
   poly2con         = CONT AND POLY2
//
// Maximum ratio of POLY1 area to connected CONT area = 18000
      poly1_polygon = POLY1 enclose poly1con
      poly1_polygon_net = COPY poly1_polygon
      CONNECT poly1_polygon_net 
   RATIO_CONT_POLY1_DFMC0006 { @ DFM0006 Maximum ratio of POLY1 area to connected CONT area = 18000
      poly1_poly1con = poly1con INSIDE poly1_polygon
      //poly1_polygon_net = POLYNET poly1_polygon
      poly1_poly1con_net = STAMP poly1_poly1con BY poly1_polygon_net
      NET AREA RATIO poly1_polygon_net poly1_poly1con_net > 18000
      xx = NET AREA RATIO poly1_polygon_net poly1_poly1con_net > 18000 ACCUMULATE
      NET AREA RATIO PRINT xx 'ratio_poly1_cont.txt'
   }
//
// Maximum ratio of POLY2 area to connected CONT area = 22000
      poly2_polygon = POLY2 enclose poly2con
      poly2_polygon_net = COPY poly2_polygon 
      CONNECT poly2_polygon_net
   RATIO_CONT_POLY2_DFMC0007 { @ DFM0007 Maximum ratio of POLY2 area to connected CONT area = 22000
      poly2_poly2con = poly2con INSIDE poly2_polygon
      //poly2_polygon_net = POLYNET poly2_polygon
      poly2_poly2con_net = STAMP poly2_poly2con BY poly2_polygon_net
      NET AREA RATIO poly2_polygon_net poly2_poly2con_net > 22000
      xx = NET AREA RATIO poly2_polygon_net poly2_poly2con_net > 22000 ACCUMULATE
      NET AREA RATIO PRINT xx 'ratio_poly2_cont.txt'
   }
//
//=====================================================================
// DFM0040/DFM0044 check for missing dummy poly2 at the end of narrow poly2
//=====================================================================
//
// check for min poly2 width and spacings
//
// na
//
//   WIDTHMIN_POLY2_PO2W2_DFMA {@ INFO: Minimum POLY2 width = 0.65 0.65
//        INT POLY2 <= 0.65 ABUT>0<90 SINGULAR REGION
//   }
//   SPACMIN_POLY2_NOTCH_PO2S2_DFMA {@ INFO : Minimum POLY2 spacing = 0.5 0.5
//        EXT POLY2 <= 0.50 NOTCH ABUT>0<90 REGION
//   }
// check for resistor with notches
//   SPACMIN_POLY2_PO2S2_DFMA { @ INFO : Minimum POLY2 spacing notch = 0.5 0.5
//        EXT POLY2 <= 0.50 SPACE ABUT>0<90 SINGULAR REGION
//   }
//----------------------------------------------------------------------------------------------------
//                     check res end for snake like narrow poly2 res
//                                  without dummy poly2
//----------------------------------------------------------------------------------------------------
//
// check for res without dummy poly 
// (do not use resdef and poly2cut)
//
// search U notch, notch length > 10 
// search poly2 near U res
// 
// notch up to 1 U and length > 10
//
   poly2_notch = EXT POLY2 <= 1.0 NOTCH ABUT>0<90 SINGULAR REGION
   //poly2_notch { FLATTEN poly2_notch }
   poly2_notch_1 = INT poly2_notch < 1.0 PARA OPPOSITE REGION
   poly2_notch_long_edge = poly2_notch_1 LENGTH > 10
   poly2_notch_with_long_edge = poly2_notch_1 WITH EDGE poly2_notch_long_edge
   //poly2_notch_with_long_edge { FLATTEN poly2_notch_with_long_edge }
//
// get res body with U shape
//
   poly2_u_res_body_1 = POLY2 TOUCH poly2_notch_with_long_edge 
//
// find any dummy poly2 near up to 8 U
//
   poly2_dummy_1 = SIZE poly2_u_res_body_1 BY 8.0 
   poly2_dummy = (POLY2 AND poly2_dummy_1) NOT poly2_u_res_body_1 
   //poly2_dummy { COPY poly2_dummy }
//
// find pieces of U
// 
   poly2_u_res_body_2 = INT poly2_u_res_body_1 < 1.0 PARA OPPOSITE REGION 
   poly2_u_res_body_3 = poly2_u_res_body_2 TOUCH poly2_notch_with_long_edge
   //poly2_u_res_body_3 { COPY  poly2_u_res_body_3 }
//
// find end of U snake like shapes
//
   poly2_u_res_body_out = poly2_u_res_body_3 TOUCH poly2_notch_with_long_edge == 1
   //poly2_u_res_body_out { COPY  poly2_u_res_body_out }
//
// if more U snake shapes in series , remove it     
//
   poly2_u_res_inner_end = EXT (COIN EDGE poly2_u_res_body_out POLY2) < 3.0 PARA OPPOSITE REGION
//
// spacing check to internal poly to 3 U
//
   poly2_u_res_out_end = EXT poly2_dummy (COIN EDGE poly2_u_res_body_out POLY2) < 3.0 PARA OPPOSITE REGION
   //poly2_u_res_out_end { COPY poly2_u_res_out_end }
//
// no dummy poly2 near the end
//
   poly2_u_bad_end = ( poly2_u_res_body_out NOT INTERACT poly2_u_res_out_end) NOT INTERACT poly2_u_res_inner_end
// poly2_u_bad_end { COPY poly2_u_bad_end }
//
//----------------------------------------------------------------------------------------------------
//             check res end for snake like narrow poly2 res connected with met1
//                                  without dummy poly2
//  this is identical to poly2 notch , but with met1 connectivity
//----------------------------------------------------------------------------------------------------
//
   adfm_poly1_poly2      = POLY1 AND POLY2
//
// poly2 resistor
// no notch <=1
//
   adfm_pres_1          = ((POLY2 NOT INTERACT poly2_notch) AND RESDEF) NOT HRES
   adfm_pres_2          = adfm_pres_1 NOT adfm_poly1_poly2
   adfm_pres            = adfm_pres_2 NOT RESTRM
   adfm_pres_le1        = INT adfm_pres < 1.0 PARALLEL OPPOSITE REGION 
//
   adfm_poly2con        = (CONT AND POLY2) NOT POLY1
//
   adfm_pres_long_edge  = adfm_pres_le1 LENGTH > 10
//
// body of poly2 res with width < 1 and length > 10
//
   adfm_pres_gt10       = adfm_pres_le1 WITH EDGE  adfm_pres_long_edge
// 
// notch up to 1 U and length > 10
//
   adfm_pres_poly2 = POLY2 INTERACT adfm_pres_gt10
//
// connect all poly2 with met1
//
   CONNECT adfm_pres_poly2 MET1 BY adfm_poly2con 
   CONNECT adfm_pres_gt10 adfm_pres_poly2 
//
// do spacing between res body <=1 U connected width < 1 outside to avoid error over restrm
//
   adfm_poly2_spac = EXT ( NOT COIN EDGE adfm_pres_gt10 RESTRM) <= 1.0 CONNECTED REGION
   //adfm_poly2_spac { COPY adfm_poly2_spac }

   adfm_pres_gt10_conn = adfm_pres_gt10 INTERACT adfm_poly2_spac
//
// find any dummy poly2 near up to 8 U
//
   adfm_poly2_dummy_1 = SIZE adfm_pres_gt10_conn BY 8.0 
   adfm_poly2_dummy   = (POLY2 AND adfm_poly2_dummy_1) NOT adfm_pres_gt10_conn 
//
   //adfm_poly2_dummy { COPY adfm_poly2_dummy }
//
// last resistor outside of array
//
   adfm_poly2_res_end_out = adfm_pres_gt10_conn TOUCH adfm_poly2_spac == 1
   //adfm_poly2_res_end_out { FLATTEN adfm_poly2_res_end_out }
//
// do spacing to dummy poly 
//
   adfm_poly2_res_end_spac = EXT adfm_poly2_dummy (COIN EDGE adfm_poly2_res_end_out POLY2) < 3.0 PARA OPPOSITE REGION
   //adfm_poly2_res_end_spac { COPY adfm_poly2_res_end_spac }
//
// if more U snake shapes in series , remove it     
//
   adfm_poly2_res_inner_end = EXT (COIN EDGE adfm_poly2_res_end_out POLY2) < 3.0 PARA OPPOSITE REGION
//
// no dummy poly2 near the end
//
   adfm_poly2_res_end_bad = (adfm_poly2_res_end_out NOT INTERACT adfm_poly2_res_end_spac) NOT INTERACT adfm_poly2_res_inner_end
   //adfm_poly2_res_end_bad { FLATTEN adfm_poly2_res_end_bad }
//
// very critcal error
//
   MISS_DUMMY_POLY2_RESEND_DFMA0040_DFMA0044 { @ DFM0040/DFM0044 Missing dummy poly2 near end of last resistor of
                                               @ resistor array or long single res  with width poly2 < 1 U and spacing poly2 <= 1 U 
                                               @ can encrease total resistor value due to underetching
                                               @ rpoly2 without dummy poly2 is not allowed
                                               @ rpolyh without dummy poly2 is not allowed
       // poly2 snake
       FLATTEN poly2_u_bad_end 
       // poly2 connected metal1
       FLATTEN adfm_poly2_res_end_bad 
   }
//
//=====================================================================
// TPTXXX4 : check for any missing IPs with cell box layer only, but no data
//=====================================================================
//
  dens0  = DENSITY MET1  == 0  WINDOW 150.0  STEP 10.0
  dens1  = DENSITY MET2  == 0  WINDOW 150.0  STEP 10.0
  dens2  = DENSITY POLY1 == 0  WINDOW 150.0  STEP 10.0
  dens3  = DENSITY POLY2 == 0  WINDOW 150.0  STEP 10.0
  dens4  = DENSITY DIFF  == 0  WINDOW 150.0  STEP 10.0
  dens5  = DENSITY NPLUS == 0  WINDOW 150.0  STEP 10.0
  dens6  = DENSITY PPLUS == 0  WINDOW 150.0  STEP 10.0
  dens7  = DENSITY VIA   == 0  WINDOW 150.0  STEP 10.0
  dens8  = DENSITY NTUB  == 0  WINDOW 150.0  STEP 10.0
  dens9  = DENSITY MET3  == 0  WINDOW 150.0  STEP 10.0
  densA  = DENSITY VIA2  == 0  WINDOW 150.0  STEP 10.0
  densB  = DENSITY CONT  == 0  WINDOW 150.0  STEP 10.0
//
//
  data_density_all_1 = dens0 AND (dens1 AND (dens2 AND (dens3 AND
             (dens4 AND (dens5 AND (dens6 AND (dens7 AND (dens8 AND (dens9 AND (densA AND densB))))))))))
//
#IFDEF fourmetal
  densC  = DENSITY VIA3  == 0  WINDOW 150.0  STEP 10.0
  densD  = DENSITY MET4  == 0  WINDOW 150.0  STEP 10.0
  data_density_all = data_density_all_1 AND (densD AND densC)
#ELSE
  data_density_all = COPY data_density_all_1 
#ENDIF
//
// only > 100 x 100 U
//
  poss_empty_cell = AREA( data_density_all AND CELBOX) > 10000.0 
//
  POSSIBLE_EMPTY_IPCELL_TPTXXX4 { @ TPTXXX4 : Possible empty IP cell with reduced data
                                  @ area within cell box > 100 x 100 is empty ?
      FLATTEN poss_empty_cell 
  }
//
//=====================================================================
// TPTXXX5 : check for revblock missing sfcdef ( using pad mask designator)
//=====================================================================

//
// get scribe pad
// no hole because of scribe cut
//-------------------------------
//
   pad_long_edge = PAD LENGTH > 200
   pad_with_long_edge = PAD WITH EDGE pad_long_edge
// pad_with_long_edge { COPY pad_with_long_edge }
//
   pad_no_scribe = PAD NOT pad_with_long_edge
//
//  REMOVE ALL PADS < 5x5 U !!!!!!!!
//------------------------------------
//
   pad_large = SIZE pad_no_scribe BY 2.5 UNDEROVER
//
// add SFCDEF in REV block
//--------------------------
// pad layer number 40 and mask rev is in SFCDEF
// description : 3 shapes : 40 and square, A,B,C
// min pad width 0.9, heigth if 40 is 4.3, spacing between 4 and 0
// is 0.7, distance 40 to mask design = 10.3
//
// get mask designator and layer nummer on pad
// avoid any checks for vertices , may be scaled down
// in cadence by magnify
//
// small area ?
   pad_sfc_1     = pad_no_scribe AREA < 100
// small width ?
   pad_sfc_2     = INT pad_sfc_1 < 4 REGION PARALLEL OPPOSITE
   pad_sfc_small = pad_sfc_1 INTERACT pad_sfc_2
//
// hole ?
//  hole in 40 ( in 0 )
   pad_sfc_zero  = DONUT pad_sfc_small
   pad_sfc_nozero = pad_sfc_small NOT pad_sfc_zero
//
// any shape near by ?
//
   pad_sfc_dist  = EXT pad_sfc_zero pad_sfc_nozero < 3 REGION
//
   pad_sfc_ok1 = pad_sfc_zero INTERACT pad_sfc_dist
   pad_sfc_ok2 = pad_sfc_nozero INTERACT pad_sfc_dist
//
// this should be 40

// polygon ? do vertex
//
   pad_sfc_fourty = VERTEX ( pad_sfc_ok1 OR pad_sfc_ok2) > 5
   //pad_sfc_fourty { COPY pad_sfc_fourty }
//
// missing SFCDEF on rvblk
//--------------------------
//
// polyimide layer covers revblock if not corrected
//
   MISS_SFCDEF_ON_REVBLK_TPTXXX5 { @ TPTXXX5 : Probably missing SFCDEF on RVBLK
                                   @ revblock will be covered by POLYIMIDE if automatically generated
      pad_sfc_fourty NOT INSIDE SFCDEF
   }
//
//=====================================================================
// DFM0016/DFM0013/DFM0010 check for via stacks with min unused metal ovlp 
//=====================================================================
//
// check for 4 3 and 2 metal
// check for min overlap too complicated, use 1*1U
//
   met2_less_1 = MET2 AREA < 1.0
   met3_less_1 = MET3 AREA < 1.0
//
// dfm0010, dfm0013, dfm0016
//
//#IFDEF fourmetal
//
   met4_less_1 = MET4 AREA < 1.0
// top met4
   TOPMINMET4_ON_VIA3_DFMC0016 {@ DFM0016: Min Top MET4 on VIA3 stack is used
      met4_less_1 ENCLOSE VIA3
   }
//
// stack ends with met2
//   INFO_TOPMINMET2_ON_VIA_DFMC {@ INFO:     Min Top MET2 on VIA stack is used
//      ((met2_less_1 ENCLOSE VIA) NOT ENCLOSE VIA2) NOT ENCLOSE VIA3
//   }
//
// stack ends with met3
   TOPMINMET3_ON_VIA2_DFMC0013 {@ DFM0013: Min Top MET3 on VIA2 stack is used
      (met3_less_1 ENCLOSE VIA2) NOT ENCLOSE VIA3
   }
// stack ends with small met4 AND small met3
//   INFO_TOPMINMET34_ON_VIA23_DFMC {@ INFO:     Min Top MET4 and min MET3 on VIA3/VIA2 stack is used
//      ((met3_less_1 AND met4_less_1) ENCLOSE VIA2) ENCLOSE VIA3
//   }
// stack ends with small met3 AND small met2
//   INFO_TOPMINMET32_ON_VIA_VIA2_DFMC {@  INFO:     Min Top MET3 and min MET2 on VIA/VIA2 stack is used
//      (((met3_less_1 AND met2_less_1) ENCLOSE VIA) ENCLOSE VIA2) NOT ENCLOSE VIA3
//   }
//#ELSE
// stack ends with met3
//   INFO_TOPMINMET3_ON_VIA2_DFMC {@  INFO:     Min Top MET3 on VIA2 stack is used
//      met3_less_1 ENCLOSE VIA2
//   }
// stack ends with met2
   TOPMINMET2_ON_VIA_DFMC0010 {@  DFM0010:   Min Top MET2 on VIA stack is used
      (met2_less_1 ENCLOSE VIA) NOT ENCLOSE VIA2
   }
// stack ends with small met3 AND small met2
//   INFO_TOPMINMET32_ON_VIA_VIA2_DFMC {@  INFO:     Min Top MET3 and min MET2 on VIA/VIA2 stack is used
//      ((met3_less_1 AND met2_less_1) ENCLOSE VIA) ENCLOSE VIA2
//  }
//#ENDIF
//
//################################################################################
//################################################################################
//
//=====================================================================
// check for  quality of connections and connect statistic
//=====================================================================
//
// problems : peri cell input trans has miss diffcons
//            peri cells met3/met4 large areas not conn
//            do underover of errors to avoid too narrow areas flagging
//
//   cannot use density because if rectangular scanning box (inside of layer uses bounding box)
//
// check for quality of connections 
//
// attention : insufficient .. checks only, if diff or met ovlp has not
// sufficient conts/vias, which can be placed there, but does not check
// if ovlp should be larger 
//
// only for special applications
//
#IFDEF CONNECT_STATISTIC
//
// find areas connected with 1 via, 2 via 
// found on MENTOR FAQ
// How do you select any intersection of m1 and m2 of the same net that contain less than 2 vias
// flags overlapping connected areas with via inside
// select edges of overlapping polygons and get overlapping area
// can also be totally enclosed
//
//=======================================================================
//
// all via1/2/3
   VARIABLE via_dens 1.2
// met conts
   VARIABLE cont_dens 1.1
// substrate const
   VARIABLE subtap_dens 1.2
   VARIABLE welltap_dens 1.2
//
   pad_ovs = SIZE PAD BY 5.2
// set higher to get rid of errorrs in digital cells
//
   VARIABLE sd_dens 2.0

   DISCONNECT

//M1 and M2, same net, common area
//
// this find ovlp on same net without any via in it
//

   //CONNECT MET2 MET1 BY VIA
   //common_edge1 = EXTERNAL MET2 [MET1] < 0.002 INSIDE ALSO CONNECTED
   //common_edge2 = EXTERNAL MET1 [MET2] < 0.002 INSIDE ALSO CONNECTED
   //common_m1 = (MET1 and MET2) WITH EDGE common_edge1
   //common_m2 = (MET1 and MET2) WITH EDGE common_edge2
   //x = common_m1 or common_m2

   m1m2_commonx = (MET1 AND MET2) NOT OUTSIDE VIA
   CONNECT MET1 m1m2_commonx

#IFDEF CONNECT_COUNT    
   INFO_M1M2_VIA1_1_CONNECTION {
               m1m2_commonx ENCLOSE VIA == 1
   }
   INFO_M1M2_VIA1_2_CONNECTION {
               m1m2_commonx ENCLOSE VIA == 2
   }
   INFO_M1M2_VIA1_3_CONNECTION {
               m1m2_commonx ENCLOSE VIA == 3
   }
   INFO_M1M2_VIA1_4_CONNECTION {
               m1m2_commonx ENCLOSE VIA == 4
   }
   INFO_M1M2_VIA1_5_CONNECTION {
               m1m2_commonx ENCLOSE VIA == 5
   }
   INFO_M1M2_VIA1_6_CONNECTION {
               m1m2_commonx ENCLOSE VIA == 6
   }
   INFO_M1M2_VIA1_7_CONNECTION {
               m1m2_commonx ENCLOSE VIA == 7
   }
   INFO_M1M2_VIA1_8_CONNECTION {
               m1m2_commonx ENCLOSE VIA == 8
   }
   INFO_M1M2_VIA1_9_CONNECTION {
               m1m2_commonx ENCLOSE VIA == 9
   }
   INFO_M1M2_VIA1_GE10_CONNECTION {
               m1m2_commonx ENCLOSE VIA >= 10
   }
#ENDIF
//
// check for miss vias
// remove false errors metcap ( higher spacing )
// and spiral
//
     met1_met2_ovlp_conn = COPY m1m2_commonx
     via_closed_conn = met1_met2_ovlp_conn AND (SIZE VIA BY 0.5) 
    
     //via_closed_conn = STAMP via_closed BY met1_met2_ovlp_conn
//
//
#IFDEF MORE_DFM_CHECKS
// check all
// too much output
   MORE_VIA_M1M2_ALL_DFMC0008 { @ DFM0008 : more vias can be placed here on m1/m2 connection
     xx = NET AREA RATIO met1_met2_ovlp_conn via_closed_conn > via_dens
     yy = (SIZE (xx NOT via_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT INDDEF
   }
#ENDIF
//
// check width
//
   MORE_VIA_M1M2_GT10LE15_DFMC0008 { @ DFM0008 : more vias can be placed here on m1/m2 connection
                                 @           for big metal1/2 junction width > 10 <=15 U
     met1_met2_ovlp_connx  = STAMP (met1_met2_ovlp_conn WITH WIDTH > 10 <=15) BY met1_met2_ovlp_conn
     xx = NET AREA RATIO met1_met2_ovlp_connx via_closed_conn > via_dens
     yy = (SIZE (xx NOT via_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT INDDEF
   }
   MORE_VIA_M1M2_GT15LE20_DFMC0008 { @ DFM0008 : more vias can be placed here on m1/m2 connection
                                 @           for big metal1/2 junction width > 10 <=20 U
     met1_met2_ovlp_connx  = STAMP (met1_met2_ovlp_conn WITH WIDTH > 15 <= 20) BY met1_met2_ovlp_conn
     xx = NET AREA RATIO met1_met2_ovlp_connx via_closed_conn > via_dens
     yy = (SIZE (xx NOT via_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT INDDEF
   }
   MORE_VIA_M1M2_GT20LE30_DFMC0008 { @ DFM0008 : more vias can be placed here on m1/m2 connection
                                 @           for big metal1/2 junction width > 10 <=30 U
     met1_met2_ovlp_connx  = STAMP (met1_met2_ovlp_conn WITH WIDTH > 20 <=30) BY met1_met2_ovlp_conn
     xx = NET AREA RATIO met1_met2_ovlp_connx via_closed_conn > via_dens
     yy = (SIZE (xx NOT via_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT INDDEF
   }
   MORE_VIA_M1M2_GT30LE50_DFMC0008 { @ DFM0008 : more vias can be placed here on m1/m2 connection
                                 @           for big metal1/2 junction  width> 10 <=50 U
     met1_met2_ovlp_connx  = STAMP (met1_met2_ovlp_conn WITH WIDTH > 30 <=50 ) BY met1_met2_ovlp_conn
     xx = NET AREA RATIO met1_met2_ovlp_connx via_closed_conn > via_dens
     yy = (SIZE (xx NOT via_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT INDDEF
   }
   MORE_VIA_M1M2_GT50_DFMC0008 { @ DFM0008 : more vias can be placed here on m1/m2 connection
                                 @           for big metal1/2 junction width > 50 U
     met1_met2_ovlp_connx  = STAMP (met1_met2_ovlp_conn WITH WIDTH > 50) BY met1_met2_ovlp_conn
     xx = NET AREA RATIO met1_met2_ovlp_connx via_closed_conn > via_dens
     yy = (SIZE (xx NOT via_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT INDDEF
   }
// 
// check density
//
#IFDEF MORE_DFM_CHECKS
// check all
// too much output
   MORE_VIA_M1M2_R5_DFMC0008 { @ DFM0008 : more vias can be placed here on m1/m2 connection
     xx = NET AREA RATIO met1_met2_ovlp_conn via_closed_conn > 5
     yy = (SIZE (xx NOT via_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT INDDEF
   }
#ENDIF
   MORE_VIA_M1M2_R10_DFMC0008 { @ DFM0008 : more vias can be placed here on m1/m2 connection
                                 @           only less than 1/10  of possible connctions are done
                                 @           for any size of metal1/metal2 junction
     xx = NET AREA RATIO met1_met2_ovlp_conn via_closed_conn > 10 <= 15
     yy = (SIZE (xx NOT via_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT INDDEF
   }
   MORE_VIA_M1M2_R15_DFMC0008 { @ DFM0008 : more vias can be placed here on m1/m2 connection
                                 @           only less than 1/15  of possible connctions are done
                                 @           for any size of metal1/metal2 junction
     xx = NET AREA RATIO met1_met2_ovlp_conn via_closed_conn > 15 <= 20
     yy = (SIZE (xx NOT via_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT INDDEF
   }
   MORE_VIA_M1M2_R20_DFMC0008 { @ DFM0008 : more vias can be placed here on m1/m2 connection
                                 @           only less than 1/20  of possible connctions are done
                                 @           for any size of metal1/metal2 junction
     xx = NET AREA RATIO met1_met2_ovlp_conn via_closed_conn > 20 <= 50
     yy = (SIZE (xx NOT via_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT INDDEF
   }
   MORE_VIA_M1M2_R50_DFMC0008 { @ DFM0008 : more vias can be placed here on m1/m2 connection
                                 @           only less than 1/50  of possible connctions are done
                                 @           for any size of metal1/metal2 junction
     xx = NET AREA RATIO met1_met2_ovlp_conn via_closed_conn > 50
     yy = (SIZE (xx NOT via_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT INDDEF
   }
//
// combi
//
// width > 10, density 0.1
//
   MORE_VIA_M1M2_GT10LE20_R10_DFMC0008 { @ DFM0008 : more vias can be placed here on m1/m2 connection
                                 @           only 1/10 of possible connctions are done
                                 @           for big metal1/2 junction width > 10 <=20  U
     met1_met2_ovlp_connx  = STAMP( met1_met2_ovlp_conn WITH WIDTH > 10 <=20 ) BY  met1_met2_ovlp_conn
     xx = NET AREA RATIO met1_met2_ovlp_connx via_closed_conn > 10
     yy = (SIZE (xx NOT via_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT INDDEF
   }
//
// width > 20, density 0.1
//
   MORE_VIA_M1M2_GT20LE30_R10_DFMC0008 { @ DFM0008 : more vias can be placed here on m1/m2 connection
                                 @           only 1/10 of possible connctions are done
                                 @           for big metal1/2 junction width  > 20 <= 30  U
     met1_met2_ovlp_connx  = STAMP( met1_met2_ovlp_conn WITH WIDTH > 20 <=30 ) BY  met1_met2_ovlp_conn
     xx = NET AREA RATIO met1_met2_ovlp_connx via_closed_conn > 10
     yy = (SIZE (xx NOT via_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT INDDEF
   }
//
// width > 30, density 0.1
//
   MORE_VIA_M1M2_GT30_R10_DFMC0008 { @ DFM0008 : more vias can be placed here on m1/m2 connection
                                 @           only 1/10 of possible connctions are done
                                 @           for big metal1/2 junction width > 30 
     met1_met2_ovlp_connx  = STAMP( met1_met2_ovlp_conn WITH WIDTH > 30) BY  met1_met2_ovlp_conn
     xx = NET AREA RATIO met1_met2_ovlp_connx via_closed_conn > 10
     yy = (SIZE (xx NOT via_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT INDDEF
   }
//
// check worst case
//
// good : do not select parts of all angle areas with with width constraint
   m1m2_commonx_good = m1m2_commonx ENCLOSE VIA >= 10 
//
   MORE_VIA_M1M2_GT5LE10_EQ1V_DFMC0008 { @ DFM0008 : only one via on large connection
                                 @           for big metal metal1/2 junction width > 5  <=10  U
               ((m1m2_commonx NOT INTERACT m1m2_commonx_good)  WITH WIDTH > 5 <=10) ENCLOSE VIA == 1
   }
//
   MORE_VIA_M1M2_GT10LE20_LT3V_DFMC0008 { @ DFM0008 : insufficient via count < 3 on large connection
                                 @           for big metal metal1/2 junction width > 10 <=20  U
               ((m1m2_commonx NOT INTERACT m1m2_commonx_good)  WITH WIDTH > 10 <=20 ) ENCLOSE VIA < 3
   }
//
   MORE_VIA_M1M2_GT20LT20_LT5V_DFMC0008 { @ DFM0008 : insufficient via count < 5 on large connection
                                 @           for big metal metal1/2 junction width > 20 <=30  U
               ((m1m2_commonx NOT INTERACT m1m2_commonx_good)  WITH WIDTH > 20 <=30 ) ENCLOSE VIA < 5
   }
//
   MORE_VIA_M1M2_GT30_LT10V_DFMC0008 { @ DFM0008 : insufficient via count < 10 on large connection
                                 @           for big metal metal1/2 junction width > 30  U
               ((m1m2_commonx NOT INTERACT m1m2_commonx_good) WITH WIDTH > 30) ENCLOSE VIA < 10
   }
//
//
//=======================================================================
//
   DISCONNECT

//M1 and M2, same net, common area

   //CONNECT MET3 MET2 BY VIA2
   //common_edge1_a = EXTERNAL MET3 [MET2] < 0.002 INSIDE ALSO CONNECTED
   //common_edge2_a = EXTERNAL MET2 [MET3] < 0.002 INSIDE ALSO CONNECTED
   //common_m1_a = (MET3 and MET2) WITH EDGE common_edge1_a
   //common_m2_a = (MET3 and MET2) WITH EDGE common_edge2_a
   //x_a = common_m1_a OR common_m2_a

   m2m3_commonx_a = (MET2 AND MET3) NOT OUTSIDE VIA2
   CONNECT MET2 m2m3_commonx_a
//
#IFDEF CONNECT_COUNT    
   INFO_M2M3_VIA2_1_CONNECTION {
               m2m3_commonx_a ENCLOSE VIA2 == 1
   }
   INFO_M2M3_VIA2_2_CONNECTION {
               m2m3_commonx_a ENCLOSE VIA2 == 2
   }
   INFO_M2M3_VIA2_3_CONNECTION {
               m2m3_commonx_a ENCLOSE VIA2 == 3
   }
   INFO_M2M3_VIA2_4_CONNECTION {
               m2m3_commonx_a ENCLOSE VIA2 == 4
   }
   INFO_M2M3_VIA2_5_CONNECTION {
               m2m3_commonx_a ENCLOSE VIA2 == 5
   }
   INFO_M2M3_VIA2_6_CONNECTION {
               m2m3_commonx_a ENCLOSE VIA2 == 6
   }
   INFO_M2M3_VIA2_7_CONNECTION {
               m2m3_commonx_a ENCLOSE VIA2 == 7
   }
   INFO_M2M3_VIA2_8_CONNECTION {
               m2m3_commonx_a ENCLOSE VIA2 == 8
   }
   INFO_M2M3_VIA2_9_CONNECTION {
               m2m3_commonx_a ENCLOSE VIA2 == 9
   }
   INFO_M2M3_VIA2_GE10_CONNECTION {
               m2m3_commonx_a ENCLOSE VIA2 >= 10
   }
#ENDIF
//
// check for miss vias
//
// not in spiral or metcap
//
   met2_met3_ovlp_conn = COPY  m2m3_commonx_a         
   via2_closed_conn = met2_met3_ovlp_conn AND (SIZE VIA2 BY 0.5) 
//
// check all
//
//   MORE_VIA2_M2M3_ALL_DFMC0011 { @ DFM0011 : more via2 can be placed here on m2/m3 connection
//     xx = NET AREA RATIO met2_met3_ovlp_conn via2_closed_conn > via_dens
//     yy = (SIZE (xx NOT via2_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
//     yy NOT (METCAP OR INDDEF)
//     //yy = NET AREA RATIO met2_met3_ovlp_conn via2_closed_conn > via_dens ACCUMULATE
//     //NET AREA RATIO PRINT yy 'm2m3ovlp_via2_density.txt'
//   }
//
// check width
//
   MORE_VIA2_M2M3_GT10LE15_DFMC0011 { @ DFM0011 : more via2 can be placed here on m2/m3 connection
                                  @           for big metal2/3 junction width > 10 <=15 U
     met2_met3_ovlp_conn0 = STAMP (met2_met3_ovlp_conn WITH WIDTH > 10 <=15 )  BY met2_met3_ovlp_conn
     xx = NET AREA RATIO met2_met3_ovlp_conn0 via2_closed_conn > via_dens
     yy = (SIZE (xx NOT via2_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT (METCAP OR INDDEF)
   }
   MORE_VIA2_M2M3_GT15LE20_DFMC0011 { @ DFM0011 : more via2 can be placed here on m2/m3 connection
                                  @           for big metal2/3 junction  width> 15 <=20 U
     met2_met3_ovlp_conn0 = STAMP (met2_met3_ovlp_conn WITH WIDTH > 15 <= 20)  BY met2_met3_ovlp_conn
     xx = NET AREA RATIO met2_met3_ovlp_conn0 via2_closed_conn > via_dens
     yy = (SIZE (xx NOT via2_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT (METCAP OR INDDEF)
   }
   MORE_VIA2_M2M3_GT20LE30_DFMC0011 { @ DFM0011 : more via2 can be placed here on m2/m3 connection
                                  @           for big metal2/3 junction width > 20 <=30 U
     met2_met3_ovlp_conn0 = STAMP (met2_met3_ovlp_conn WITH WIDTH > 20 <=30 )  BY met2_met3_ovlp_conn
     xx = NET AREA RATIO met2_met3_ovlp_conn0 via2_closed_conn > via_dens
     yy = (SIZE (xx NOT via2_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT (METCAP OR INDDEF)
   }
   MORE_VIA2_M2M3_GT30LE50_DFMC0011 { @ DFM0011 : more via2 can be placed here on m2/m3 connection
                                  @           for big metal2/3 junction width > 30 <=50 U
     met2_met3_ovlp_conn0 = STAMP (met2_met3_ovlp_conn WITH WIDTH > 30 <=50 )  BY met2_met3_ovlp_conn
     xx = NET AREA RATIO met2_met3_ovlp_conn0 via2_closed_conn > via_dens
     yy = (SIZE (xx NOT via2_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT (METCAP OR INDDEF)
   }
   MORE_VIA2_M2M3_GT50_DFMC0011 { @ DFM0011 : more via2 can be placed here on m2/m3 connection
                                  @           for big metal2/3 junction width > 50 U
     met2_met3_ovlp_conn0 = STAMP (met2_met3_ovlp_conn WITH WIDTH > 50 )  BY met2_met3_ovlp_conn
     xx = NET AREA RATIO met2_met3_ovlp_conn0 via2_closed_conn > via_dens
     yy = (SIZE (xx NOT via2_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT (METCAP OR INDDEF)
   }
//
// check bad ratio
//
#IFDEF MORE_DFM_CHECKS
// check all
// too much output
   MORE_VIA2_M2M3_R5_DFMC0011 { @ DFM0011 : more via2 can be placed here on m2/m3 connection
                                 @           only 1/10  of possible connctions are done
                                 @           for any size of metal2/metal3 junction
     xx = NET AREA RATIO met2_met3_ovlp_conn via2_closed_conn > 5
     yy = (SIZE (xx NOT via2_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT (METCAP OR INDDEF)
   }
#ENDIF
   MORE_VIA2_M2M3_R10_DFMC0011 { @ DFM0011 : more via2 can be placed here on m2/m3 connection
                                 @           only 1/10  of possible connctions are done
                                 @           for any size of metal2/metal3 junction
     xx = NET AREA RATIO met2_met3_ovlp_conn via2_closed_conn > 10 <= 15
     yy = (SIZE (xx NOT via2_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT (METCAP OR INDDEF)
   }
   MORE_VIA2_M2M3_R15_DFMC0011 { @ DFM0011 : more via2 can be placed here on m2/m3 connection
                                 @           only 1/15  of possible connctions are done
                                 @           for any size of metal2/metal3 junction
     xx = NET AREA RATIO met2_met3_ovlp_conn via2_closed_conn > 15 <= 20
     yy = (SIZE (xx NOT via2_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT (METCAP OR INDDEF)
   }
   MORE_VIA2_M2M3_R20_DFMC0011 { @ DFM0011 : more via2 can be placed here on m2/m3 connection
                                 @           only 1/20  of possible connctions are done
                                 @           for any size of metal2/metal3 junction
     xx = NET AREA RATIO met2_met3_ovlp_conn via2_closed_conn > 20 <=50
     yy = (SIZE (xx NOT via2_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT (METCAP OR INDDEF)
   }
   MORE_VIA2_M2M3_R50_DFMC0011 { @ DFM0011 : more via2 can be placed here on m2/m3 connection
                                 @           only 1/50  of possible connctions are done
                                 @           for any size of metal2/metal3 junction
     xx = NET AREA RATIO met2_met3_ovlp_conn via2_closed_conn > 50
     yy = (SIZE (xx NOT via2_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT (METCAP OR INDDEF)
   }
//
// combi
//
   MORE_VIA2_M2M3_GT10LE20_R10_DFMC0011 { @ DFM0011 : more via2 can be placed here on m2/m3 connection
                                 @           only 1/10 of possible connctions are done
                                 @           for big metal2/metal3 junction width > 10 <=20  U
     met2_met3_ovlp_conn0 = STAMP (met2_met3_ovlp_conn WITH WIDTH > 10 <=20 )  BY met2_met3_ovlp_conn
     xx = NET AREA RATIO met2_met3_ovlp_conn0 via2_closed_conn > 10
     yy = (SIZE (xx NOT via2_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT (METCAP OR INDDEF)
   }
   MORE_VIA2_M2M3_GT20LE30_R10_DFMC0011 { @ DFM0011 : more via2 can be placed here on m2/m3 connection
                                 @           only 1/10 of possible connctions are done
                                 @           for big metal2/metal3 junction width > 20 <=30  U
     met2_met3_ovlp_conn0 = STAMP (met2_met3_ovlp_conn WITH WIDTH > 20 <=30 )  BY met2_met3_ovlp_conn
     xx = NET AREA RATIO met2_met3_ovlp_conn0 via2_closed_conn > 10
     yy = (SIZE (xx NOT via2_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT (METCAP OR INDDEF)
   }
   MORE_VIA2_M2M3_GT30LE50_R10_DFMC0011 { @ DFM0011 : more via2 can be placed here on m2/m3 connection
                                 @           only 1/10 of possible connctions are done
                                 @           for big metal2/metal3 junction width > 30 U
     met2_met3_ovlp_conn0 = STAMP (met2_met3_ovlp_conn WITH WIDTH > 30 )  BY met2_met3_ovlp_conn
     xx = NET AREA RATIO met2_met3_ovlp_conn0 via2_closed_conn > 10
     yy = (SIZE (xx NOT via2_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT (METCAP OR INDDEF)
   }
//
// check worst case
//
// good : do not select parts of all angle areas with with width constraint
   m2m3_commonx_a_good = m2m3_commonx_a ENCLOSE VIA2 >= 10 
//
   MORE_VIA2_M2M3_GT5LE10_EQ1V_DFMC0011 { @ DFM0011 : only one via on large connection
                                 @           for big metal metal2/3 junction width > 5  <=10  U
               ((m2m3_commonx_a NOT INTERACT m2m3_commonx_a_good) WITH WIDTH > 5 <=10) ENCLOSE VIA2 == 1
   }
//
   MORE_VIA2_M2M3_GT10LE20_LTV3_DFMC0011 { @ DFM0011 : insufficient via count < 3 on large connection
                                 @           for big metal metal2/3 junction width > 10  <=20  U
               ((m2m3_commonx_a NOT INTERACT m2m3_commonx_a_good) WITH WIDTH > 10 <=20) ENCLOSE VIA2 < 3
   }
//
   MORE_VIA2_M2M3_GT20LE30_LTV5_DFMC0011 { @ DFM0011 : insufficient via count < 5  on large connection
                                 @           for big metal metal2/3 junction width > 20  <=30  U
               ((m2m3_commonx_a NOT INTERACT m2m3_commonx_a_good) WITH WIDTH > 20 <=30 ) ENCLOSE VIA2 < 5
   }
//
   MORE_VIA2_M2M3_GT30_LTV10_DFMC0011 { @ DFM0011 : insufficient via count < 10 on large connection
                                 @           for big metal metal2/3 junction  width> 30  U
               ((m2m3_commonx_a NOT INTERACT m2m3_commonx_a_good) WITH WIDTH > 30) ENCLOSE VIA2 < 10
   }
//
//=======================================================================
//
#IFDEF fourmetal

   DISCONNECT

//M1 and M2, same net, common area

   //CONNECT MET4 MET3 BY VIA3
   //common_edge1_b = EXTERNAL MET4 [MET3] < 0.002 INSIDE ALSO CONNECTED
   //common_edge2_b = EXTERNAL MET3 [MET4] < 0.002 INSIDE ALSO CONNECTED
   //common_m1_b = (MET4 and MET3) WITH EDGE common_edge1_b
   //common_m2_b = (MET4 and MET3) WITH EDGE common_edge2_b
   //x_b = common_m1_b OR common_m2_b
//
   m3m4_commonx_b = (MET3 AND MET4) NOT OUTSIDE VIA3
   CONNECT MET3 m3m4_commonx_b
//
//
// not in spiral
//
     met3_met4_ovlp_conn  = COPY m3m4_commonx_b
     via3_closed_conn = m3m4_commonx_b AND (SIZE VIA3 BY 0.5)
     //via3_closed_conn = STAMP via3_closed BY  m3m4_commonx_b
//
// check all
//
#IFDEF MORE_DFM_CHECKS
// check all
// too much output
   MORE_VIA3_M3M4_ALL_DFMC0014 { @ DFM0014 : more via3 can be placed here on m4/m3 connection
     xx = NET AREA RATIO met3_met4_ovlp_conn via3_closed_conn > via_dens
     yy = (SIZE (xx NOT via3_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT INDDEF
   }
#ENDIF
//
// check width
//
   MORE_VIA3_M3M4_GT10LE15_DFMC0014 { @ DFM0014 : more via3 can be placed here on m4/m3 connection
                                 @           for big metal3/4 junction width > 10 <=15 U
     met3_met4_ovlp_connx  = STAMP (met3_met4_ovlp_conn WITH WIDTH > 10 <=15 ) BY  met3_met4_ovlp_conn
     xx = NET AREA RATIO met3_met4_ovlp_connx via3_closed_conn > via_dens
     yy = (SIZE (xx NOT via3_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT INDDEF
   }
   MORE_VIA3_M3M4_GT15LE20_DFMC0014 { @ DFM0014 : more via3 can be placed here on m4/m3 connection
                                 @           for big metal3/4 junction width > 15 <= 20  U
     met3_met4_ovlp_connx  = STAMP (met3_met4_ovlp_conn WITH WIDTH > 15 <= 20) BY  met3_met4_ovlp_conn
     xx = NET AREA RATIO met3_met4_ovlp_connx via3_closed_conn > via_dens
     yy = (SIZE (xx NOT via3_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT INDDEF
   }
   MORE_VIA3_M3M4_GT20LE30_DFMC0014 { @ DFM0014 : more via3 can be placed here on m4/m3 connection
                                 @           for big metal3/4 junction width > 20 <=30 U
     met3_met4_ovlp_connx  = STAMP (met3_met4_ovlp_conn WITH WIDTH > 20 <=30) BY  met3_met4_ovlp_conn
     xx = NET AREA RATIO met3_met4_ovlp_connx via3_closed_conn > via_dens
     yy = (SIZE (xx NOT via3_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT INDDEF
   }
   MORE_VIA3_M3M4_GT30LE50_DFMC0014 { @ DFM0014 : more via3 can be placed here on m4/m3 connection
                                 @           for big metal3/4 junction width > 30 <=50 U
     met3_met4_ovlp_connx  = STAMP (met3_met4_ovlp_conn WITH WIDTH > 30 <=50) BY  met3_met4_ovlp_conn
     xx = NET AREA RATIO met3_met4_ovlp_connx via3_closed_conn > via_dens
     yy = (SIZE (xx NOT via3_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT INDDEF
   }
   MORE_VIA3_M3M4_GT50_DFMC0014 { @ DFM0014 : more via3 can be placed here on m4/m3 connection
                                 @           for big metal3/4 junction width > 50 U
     met3_met4_ovlp_connx  = STAMP (met3_met4_ovlp_conn WITH WIDTH > 50) BY  met3_met4_ovlp_conn
     xx = NET AREA RATIO met3_met4_ovlp_connx via3_closed_conn > via_dens
     yy = (SIZE (xx NOT via3_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT INDDEF
   }
//
// check ratio
//
#IFDEF MORE_DFM_CHECKS
// check all
// too much output
   MORE_VIA3_M3M4_R5_DFMC0014 { @ DFM0014 : more via3 can be placed here on m4/m3 connection
     xx = NET AREA RATIO met3_met4_ovlp_conn via3_closed_conn > 5
     yy = (SIZE (xx NOT via3_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT INDDEF
   }
#ENDIF
//
   MORE_VIA3_M3M4_R10_DFMC0014 { @ DFM0014 : more via3 can be placed here on m4/m3 connection
                                 @           only 1/10  of possible connctions are done
                                 @           for any size of metal2/metal4 junction
     xx = NET AREA RATIO met3_met4_ovlp_conn via3_closed_conn > 10 <=15
     yy = (SIZE (xx NOT via3_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT INDDEF
   }
   MORE_VIA3_M3M4_R15_DFMC0014 { @ DFM0014 : more via3 can be placed here on m4/m3 connection
                                 @           only 1/15 of possible connctions are done
                                 @           for any size of metal3/metal4 junction
     xx = NET AREA RATIO met3_met4_ovlp_conn via3_closed_conn > 15 <=20
     yy = (SIZE (xx NOT via3_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT INDDEF
   }
   MORE_VIA3_M3M4_R20_DFMC0014 { @ DFM0014 : more via3 can be placed here on m4/m3 connection
                                 @           only 1/20 of possible connctions are done
                                 @           for any size of metal3/metal4 junction
     xx = NET AREA RATIO met3_met4_ovlp_conn via3_closed_conn > 20 <=50
     yy = (SIZE (xx NOT via3_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT INDDEF
   }
   MORE_VIA3_M3M4_R50_DFMC0008 { @ DFM0008 : more via3 can be placed here on m3/m4 connection
                                 @           only 1/50  of possible connctions are done
                                 @           for any size of metal4/metal3 junction
     xx = NET AREA RATIO met3_met4_ovlp_conn via3_closed_conn > 50 
     yy = (SIZE (xx NOT via3_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT INDDEF
   }
//
   MORE_VIA3_M3M4_GT10LE20_R10_DFMC0014 { @ DFM0014 : more via3 can be placed here on m4/m3 connection
                                 @           only 1/10 of possible connctions are done
                                 @           for big metal3/4 junction width > 10 <=20  U
     met3_met4_ovlp_connx  = STAMP (met3_met4_ovlp_conn WITH WIDTH > 10 <=20 ) BY  met3_met4_ovlp_conn
     xx = NET AREA RATIO met3_met4_ovlp_connx via3_closed_conn > 10      
     yy = (SIZE (xx NOT via3_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT INDDEF
   }
   MORE_VIA3_M3M4_GT20LE30_R10_DFMC0014 { @ DFM0014 : more via3 can be placed here on m4/m3 connection
                                 @           only 1/10 of possible connctions are done
                                 @           for big metal metal3/4 junction width > 20 <=30  U
     met3_met4_ovlp_connx  = STAMP (met3_met4_ovlp_conn WITH WIDTH > 20 <=30 ) BY  met3_met4_ovlp_conn
     xx = NET AREA RATIO met3_met4_ovlp_connx via3_closed_conn > 10      
     yy = (SIZE (xx NOT via3_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT INDDEF
   }
   MORE_VIA3_M3M4_GT30_R10_DFMC0014 { @ DFM0014 : more via3 can be placed here on m4/m3 connection
                                 @           only 1/10 of possible connctions are done
                                 @           for big metal metal3/4 junction width > 30 U
     met3_met4_ovlp_connx  = STAMP (met3_met4_ovlp_conn WITH WIDTH > 30) BY  met3_met4_ovlp_conn
     xx = NET AREA RATIO met3_met4_ovlp_connx via3_closed_conn > 10      
     yy = (SIZE (xx NOT via3_closed_conn) BY 0.5 UNDEROVER) NOT pad_ovs
     yy NOT INDDEF
   }

//
// check worst case
//
// good : do not select parts of all angle areas with with width constraint
   m3m4_commonx_b_good = m3m4_commonx_b ENCLOSE VIA3 >= 10 
//
   MORE_VIA3_M3M4_GT5LE10_EQ1V_DFMC0014 { @ DFM0014 : only one via3 on large connection
                                 @           for big metal metal3/4 junction width > 5  <=10  U
               ((m3m4_commonx_b NOT INTERACT m3m4_commonx_b_good) WITH WIDTH > 5 <=10 ) ENCLOSE VIA3 == 1
   }
//
   MORE_VIA3_M3M4_GT10LE20_LT3V_DFMC0014 { @ DFM0014 : insufficient via3 count < 3 on large connection
                                 @           for big metal metal3/4 junction width > 10 <= 20  U
               ((m3m4_commonx_b NOT INTERACT m3m4_commonx_b_good) WITH WIDTH > 10 <=20) ENCLOSE VIA3 < 3
   }
//
   MORE_VIA3_M3M4_GT20LE30_LT5V_DFMC0014 { @ DFM0014 : insufficient via3 count < 5  on large connection
                                 @           for big metal metal3/4 junction width > 20 <=30  U
               ((m3m4_commonx_b NOT INTERACT m3m4_commonx_b_good) WITH WIDTH > 20 <=30) ENCLOSE VIA3 < 5
   }
//
   MORE_VIA3_M3M4_GT30_LT10V_DFMC0014 { @ DFM0014 : insufficient via3 count < 10 on large connection
                                 @           for big metal metal3/4 junction width > 30  U
               ((m3m4_commonx_b NOT INTERACT m3m4_commonx_b_good) WITH WIDTH > 30) ENCLOSE VIA3 < 10
   }
//
#ENDIF
//
// get ndiff sd conts
//--------------------------
//
//=====================================================================
// create layers to find ndiff and pdiff structures

   ndiff_1          = DIFF  AND NPLUS
   pdiff_1          = DIFF  AND PPLUS

// create layers to find ndiff and pdiff structures not belonging
// to a resistor or any gate structure

   ndiff          = ndiff_1 NOT POLY1
//
   pdiff          = pdiff_1 NOT POLY1

//=====================================================================
// create layers to find gate structures of n- and p- low voltage
// devices and nmosh (NTUB version)

#IFDEF PROCESS_IS_C35XX
   trans            = DIFF AND POLY1
   ngate            = trans NOT NTUB
   pgate            = trans AND NTUB
#ENDIF
//
#IFDEF PROCESS_IS_C35B4EE
   trans            = DIFF AND POLY1
   ngate            = trans NOT NTUB
   pgate            = trans AND NTUB
#ENDIF
//
#IFDEF PROCESS_IS_S35XX
   trans            = DIFF AND POLY1
   ngate            = trans NOT NTUB
   pgate            = trans AND NTUB
#ENDIF
//
#IFDEF PROCESS_IS_H35XX
   trans            = (DIFF AND POLY1) NOT HVDEF
   rptub            = DPTUB AND SPTUB
   ptub_for_trans   = (NTUB OR (DNTUB OR SNTUB)) NOT rptub
   ngate            = trans NOT ptub_for_trans                        
   pgate            = trans AND ptub_for_trans                        
#ENDIF
   //gate           = ngate OR pgate
   ndev             = ngate AND NPLUS
   pdev             = pgate AND PPLUS
//
   routp_n_trans    = POLY1 NOT trans
//
// pmos transistors

   pmos_1           = COPY pdev
   pmos_2           = pmos_1 TOUCH routp_n_trans
   pmos             = pmos_2 TOUCH pdiff == 2
//
   nmos_1           = COPY ndev
   nmos_2           = COPY nmos_1
   nmos_3           = nmos_2 TOUCH routp_n_trans
   nmos             = nmos_3 TOUCH ndiff == 2
//
   ndiff_sd   = ndiff INTERACT nmos
   pdiff_sd   = pdiff INTERACT pmos
//
   ndiff_sd_cont = CONT AND ndiff_sd
   pdiff_sd_cont = CONT AND pdiff_sd
//
   DISCONNECT
   CONNECT MET1 ndiff_sd  BY  ndiff_sd_cont
   CONNECT MET1 pdiff_sd  BY  pdiff_sd_cont
//
// substrate taps
//--------------------------------------------------------------------
#IFDEF PROCESS_IS_C35XX
   welltap          = ndiff AND NTUB        
   subtap           = pdiff NOT NTUB        
#ENDIF
//--------------------------------------------------------------------
#IFDEF PROCESS_IS_C35B4EE
   welltap          = ndiff AND NTUB        
   subtap           = pdiff NOT NTUB        
#ENDIF
//--------------------------------------------------------------------
#IFDEF PROCESS_IS_S35XX
   welltap          = ndiff AND NTUB        
   subtap           = pdiff NOT NTUB        
#ENDIF
//--------------------------------------------------------------------
#IFDEF PROCESS_IS_H35XX
   routingpwell = ( DPTUB OR SPTUB) NOT TUBDEF
   ntub_all     = ( NTUB OR DNTUB) OR SNTUB
   routingnwell = ntub_all NOT ( TUBDEF OR HALLDEF )
//
   pdiff_c_ptub = pdiff AND routingpwell
   ndiff_c_ntub = (ndiff AND routingnwell) NOT routingpwell
   pdiff_c_sub  = (pdiff NOT routingnwell) NOT routingpwell
//
// nwells
   welltap          = COPY ndiff_c_ntub     
// pwell
   subtap           = pdiff_c_sub OR pdiff_c_ptub
//
   //welltap_ntub { FLATTEN (welltap AND NTUB) }
   //welltap_dntub { FLATTEN (welltap AND (DNTUB OR SNTUB)) }
   //subtap_sub   { FLATTEN (subtap NOT rptub) }
   //subtap_rptub { FLATTEN (subtap AND rptub) }
   //ndev_rptub { FLATTEN (nmos AND rptub) }
   //ndev_sub { FLATTEN (nmos NOT rptub) }
   //pdev_ntub { FLATTEN (pmos AND NTUB) }
   //pdev_dntub { FLATTEN (pmos AND DNTUB) }
#ENDIF
//--------------------------------------------------------------------
//
   ndiff_welltap_cont = CONT AND welltap 
   pdiff_subtap_cont  = CONT AND subtap
//
   routingnwell_snap = NTUB INSIDE DIFF
// nmos pad is s/d diff with enclosed nwell
   ndiff_nmos_pad   = ndiff INTERACT routingnwell_snap
//
   CONNECT MET1 welltap  BY  ndiff_welltap_cont
   CONNECT MET1 subtap   BY  pdiff_subtap_cont
//
   common_edge1_n = EXTERNAL MET1 [ndiff_sd] < 0.002 INSIDE ALSO CONNECTED
   common_edge2_n = EXTERNAL ndiff_sd [MET1] < 0.002 INSIDE ALSO CONNECTED
//
   //comm1 { COPY common_edge1_n }
   //comm2 { COPY common_edge2_n }
   common_m1_n = (MET1 and ndiff_sd) WITH EDGE common_edge1_n
   common_m2_n = (MET1 and ndiff_sd) WITH EDGE common_edge2_n
   x_n = common_m1_n OR common_m2_n
//
#IFDEF CONNECT_COUNT    
   INFO_M1_NDIFF_CONT_1_CONNECTION {
          x_n ENCLOSE ndiff_sd_cont == 1
   }
   INFO_M1_NDIFF_CONT_2_CONNECTION {
          x_n ENCLOSE ndiff_sd_cont == 2
   }
   INFO_M1_NDIFF_CONT_3_CONNECTION {
          x_n ENCLOSE ndiff_sd_cont == 3
   }
   INFO_M1_NDIFF_CONT_4_CONNECTION {
          x_n ENCLOSE ndiff_sd_cont == 4
   }
   INFO_M1_NDIFF_CONT_5_CONNECTION {
          x_n ENCLOSE ndiff_sd_cont == 5
   }
   INFO_M1_NDIFF_CONT_6_CONNECTION {
          x_n ENCLOSE ndiff_sd_cont == 6
   }
   INFO_M1_NDIFF_CONT_7_CONNECTION {
          x_n ENCLOSE ndiff_sd_cont == 7
   }
   INFO_M1_NDIFF_CONT_8_CONNECTION {
          x_n ENCLOSE ndiff_sd_cont == 8
   }
   INFO_M1_NDIFF_CONT_9_CONNECTION {
          x_n ENCLOSE ndiff_sd_cont == 9
   }
   INFO_M1_NDIFF_CONT_GE10_CONNECTION {
          x_n ENCLOSE ndiff_sd_cont >= 10
   }
#ENDIF
//
// filter digital cells
//
//--------------------------------------------------------------------------------------------------
// get all parts of digital cells with L=0.35 for all ntrans/ptrans
// get s/d diff and tap diff
//--------------------------------------------------------------------------------------------------
//
   xdfm_nmos =  nmos NOT MIDOX
   xdfm_pmos =  pmos NOT MIDOX
//
   xdfm_nmos_l = xdfm_nmos COINCIDENT INSIDE EDGE DIFF
   xdfm_pmos_l = xdfm_pmos COINCIDENT INSIDE EDGE DIFF
//
   xdfm_nmos_eq035x = ( PATH LENGTH xdfm_nmos_l == 0.35 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL
   xdfm_nmos_eq035 = xdfm_nmos INTERACT xdfm_nmos_eq035x
   xdfm_nmos_gt035x = ( PATH LENGTH xdfm_nmos_l > 0.35 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL
   xdfm_nmos_gt035 = xdfm_nmos INTERACT xdfm_nmos_gt035x
//
   xdfm_pmos_eq035x = ( PATH LENGTH xdfm_pmos_l == 0.35 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL
   xdfm_pmos_eq035 = xdfm_pmos INTERACT xdfm_pmos_eq035x
   xdfm_pmos_gt035x = ( PATH LENGTH xdfm_pmos_l > 0.35 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL
   xdfm_pmos_gt035 = xdfm_pmos INTERACT xdfm_pmos_gt035x
//
   xdfm_pdiff_digi_eq035 = pdiff_1 INTERACT xdfm_pmos_eq035
   // xdfm_pdiff_digi_eq035 { COPY xdfm_pdiff_digi_eq035 }
   xdfm_pdiff_nodigi_gt035 = pdiff_1 INTERACT xdfm_pmos_gt035
   // xdfm_pdiff_nodigi_gt035 { COPY xdfm_pdiff_nodigi_gt035 }
   xdfm_pdiff_eq035_digi_only = xdfm_pdiff_digi_eq035 NOT xdfm_pdiff_nodigi_gt035
   // xdfm_pdiff_eq035_digi_only { COPY xdfm_pdiff_eq035_digi_only }
//
   xdfm_ndiff_digi_eq035 = ndiff_1 INTERACT xdfm_nmos_eq035
   // xdfm_ndiff_digi_eq035 { COPY xdfm_ndiff_digi_eq035 }
   xdfm_ndiff_nodigi_gt035 = ndiff_1 INTERACT xdfm_nmos_gt035
   // xdfm_ndiff_nodigi_gt035 { COPY xdfm_ndiff_nodigi_gt035 }
   xdfm_ndiff_eq035_digi_only = xdfm_ndiff_digi_eq035 NOT xdfm_ndiff_nodigi_gt035
   // xdfm_ndiff_eq035_digi_only { COPY xdfm_ndiff_eq035_digi_only }
//
// 0.35 U digital cells
//
   xdfm_routingpoly_all = COPY POLY1
   xdfm_routp_eq035_digi_1 = xdfm_routingpoly_all INTERACT ( xdfm_pmos_eq035 INTERACT xdfm_pdiff_eq035_digi_only)
   xdfm_routp_eq035_digit = xdfm_routp_eq035_digi_1 INTERACT ( xdfm_nmos_eq035 INTERACT xdfm_ndiff_eq035_digi_only)
//
// final ndiff/pdiff with 0.35 U gates
   xdfm_ndiff_eq035_digit = xdfm_ndiff_eq035_digi_only INTERACT xdfm_routp_eq035_digit
   xdfm_pdiff_eq035_digit = xdfm_pdiff_eq035_digi_only INTERACT xdfm_routp_eq035_digit
//
// get poly touching nmos and pmos
   xdfm_ntub_eq035_digit = NTUB ENCLOSE xdfm_pdiff_eq035_digit
   xdfm_nplus_eq035_digit = NPLUS ENCLOSE xdfm_ndiff_eq035_digit
   //subtap is near nmos
   xdfm_subtap_eq035_digit = subtap INTERACT (SIZE xdfm_nplus_eq035_digit BY 1.0)
//
#IFDEF DEBUG_DIGITAL
   xdfm_routp_eq035_digit { COPY xdfm_routp_eq035_digit }
   xdfm_ndiff_eq035_digit { COPY xdfm_ndiff_eq035_digit }
   xdfm_pdiff_eq035_digit { COPY xdfm_pdiff_eq035_digit }
   xdfm_subtap_eq035_digit { COPY xdfm_subtap_eq035_digit }
#ENDIF
//
//--------------------------------------------------------------------------------------------------
// get all parts of digital cells with L=0.5 for all ntransm/ptransm
// get s/d diff and tap diff
//--------------------------------------------------------------------------------------------------
//
   xdfm_nmosm = nmos AND MIDOX
   xdfm_pmosm = pmos AND MIDOX
//
   xdfm_nmosm_l = xdfm_nmosm COINCIDENT INSIDE EDGE DIFF
   xdfm_pmosm_l = xdfm_pmosm COINCIDENT INSIDE EDGE DIFF
//
   xdfm_nmos_meq05x = ( PATH LENGTH xdfm_nmosm_l == 0.5 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL
   xdfm_nmos_meq05 = xdfm_nmos INTERACT xdfm_nmos_meq05x
   xdfm_nmos_mgt05x = ( PATH LENGTH xdfm_nmosm_l > 0.5 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL
   xdfm_nmos_mgt05 = xdfm_nmos INTERACT xdfm_nmos_mgt05x
//
   xdfm_pmos_meq05x = ( PATH LENGTH xdfm_pmosm_l == 0.5 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL
   xdfm_pmos_meq05 = xdfm_pmosm INTERACT xdfm_pmos_meq05x
   xdfm_pmos_mgt05x = ( PATH LENGTH xdfm_pmosm_l > 0.5 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL
   xdfm_pmos_mgt05 = xdfm_pmosm INTERACT xdfm_pmos_mgt05x
//
   xdfm_pdiff_digi_meq05 = pdiff_1 INTERACT xdfm_pmos_meq05
   // xdfm_pdiff_digi_meq05 { COPY xdfm_pdiff_digi_meq05 }
   xdfm_pdiff_nodigi_mgt05 = pdiff_1 INTERACT xdfm_pmos_mgt05
   // xdfm_pdiff_nodigi_mgt05 { COPY xdfm_pdiff_nodigi_mgt05 }
   xdfm_pdiff_meq05_digi_only = xdfm_pdiff_digi_meq05 NOT xdfm_pdiff_nodigi_mgt05
   // xdfm_pdiff_meq05_digi_only { COPY xdfm_pdiff_meq05_digi_only }
//
   xdfm_ndiff_digi_meq05 = ndiff_1 INTERACT xdfm_nmos_meq05
   // xdfm_ndiff_digi_meq05 { COPY xdfm_ndiff_digi_meq05 }
   xdfm_ndiff_nodigi_mgt05 = ndiff_1 INTERACT xdfm_nmos_mgt05
   // xdfm_ndiff_nodigi_mgt05 { COPY xdfm_ndiff_nodigi_mgt05 }
   xdfm_ndiff_meq05_digi_only = xdfm_ndiff_digi_meq05 NOT xdfm_ndiff_nodigi_mgt05
   // xdfm_ndiff_meq05_digi_only { COPY xdfm_ndiff_meq05_digi_only }
//
// 0.5 U digital cells
//
   //xdfm_routingpoly_all = COPY POLY1
   xdfm_routp_meq05_digi_1 = xdfm_routingpoly_all INTERACT ( xdfm_pmos_meq05 INTERACT xdfm_pdiff_meq05_digi_only)
   xdfm_routp_meq05_digit = xdfm_routp_meq05_digi_1 INTERACT ( xdfm_nmos_meq05 INTERACT xdfm_ndiff_meq05_digi_only)
//
// final ndiff/pdiff with 0.5 U gates
   xdfm_ndiff_meq05_digit = xdfm_ndiff_meq05_digi_only INTERACT xdfm_routp_meq05_digit
   xdfm_pdiff_meq05_digit = xdfm_pdiff_meq05_digi_only INTERACT xdfm_routp_meq05_digit
//
// get poly touching nmos and pmos
   xdfm_ntub_meq05_digit = NTUB ENCLOSE xdfm_pdiff_meq05_digit
   xdfm_nplus_meq05_digit = NPLUS ENCLOSE xdfm_ndiff_meq05_digit
   //  subtap is near nmos
   xdfm_subtap_meq05_digit = subtap INTERACT (SIZE xdfm_nplus_meq05_digit BY 1.0)
//
#IFDEF DEBUG_DIGITAL
   xdfm_routp_meq05_digit { COPY xdfm_routp_meq05_digit }
   xdfm_ndiff_meq05_digit { COPY xdfm_ndiff_meq05_digit }
   xdfm_pdiff_meq05_digit { COPY xdfm_pdiff_meq05_digit }
   xdfm_subtap_meq05_digit { COPY xdfm_subtap_meq05_digit }
   xdfm_ntub_meq05_digit { COPY xdfm_ntub_meq05_digit }
#ENDIF
//
//--------------------------------------------------------------------------------------------------
// get all parts of digital cells with L > 0.35 and L < 0.7 for all ntrans/ptrans
// get s/d diff and tap diff
//--------------------------------------------------------------------------------------------------
//
   xdfm_nmos_gt035lt07x = ( PATH LENGTH xdfm_nmos_l > 0.35 < 0.7 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL
   xdfm_nmos_gt035lt07 = xdfm_nmos INTERACT xdfm_nmos_gt035lt07x
   xdfm_nmos_gt07x = ( PATH LENGTH xdfm_nmos_l > 0.7 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL
//
   xdfm_pmos_gt035lt07x = ( PATH LENGTH xdfm_pmos_l > 0.35 < 0.7 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL
   xdfm_pmos_gt035lt07 = xdfm_pmos INTERACT xdfm_pmos_gt035lt07x
   xdfm_pmos_gt07x = ( PATH LENGTH xdfm_pmos_l >= 0.7 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL
//
   xdfm_pdiff_digi_gt035lt07 = pdiff_1 INTERACT xdfm_pmos_gt035lt07
   xdfm_pdiff_nodigi_gt07 = pdiff_1 INTERACT xdfm_pmos_gt07x
   xdfm_pdiff_gt035lt07_digi_only = xdfm_pdiff_digi_gt035lt07 NOT (xdfm_pdiff_nodigi_gt07 NOT xdfm_pdiff_eq035_digi_only)
   //xdfm_pdiff_gt035lt07_digi_only { COPY xdfm_pdiff_gt035lt07_digi_only }
//
   xdfm_ndiff_digi_gt035lt07 = ndiff_1 INTERACT xdfm_nmos_gt035lt07
   xdfm_ndiff_nodigi_gt07 = ndiff_1 INTERACT xdfm_nmos_gt07x
   xdfm_ndiff_gt035lt07_digi_only = xdfm_ndiff_digi_gt035lt07 NOT (xdfm_ndiff_nodigi_gt07 NOT xdfm_ndiff_eq035_digi_only)
   //xdfm_ndiff_gt035lt07_digi_only { COPY xdfm_ndiff_gt035lt07_digi_only }
//
// 0.35 U digital cells with L > 0.35 and L < 0.7
// remove any combinations with 0.35
//
   xdfm_routp_gt035lt07_digi_1 = xdfm_routingpoly_all INTERACT
                ( xdfm_pmos_gt035lt07 INTERACT xdfm_pdiff_gt035lt07_digi_only )
   xdfm_routp_gt035lt07_digit = xdfm_routp_gt035lt07_digi_1 INTERACT
                ( xdfm_nmos_gt035lt07 INTERACT xdfm_ndiff_gt035lt07_digi_only )
//
// final ndiff/pdiff with 0.35 U gates
   xdfm_ndiff_gt035lt07_digit = xdfm_ndiff_gt035lt07_digi_only INTERACT xdfm_routp_gt035lt07_digit
   xdfm_pdiff_gt035lt07_digit = xdfm_pdiff_gt035lt07_digi_only INTERACT xdfm_routp_gt035lt07_digit
//
// get poly touching nmos and pmos
   xdfm_ntub_gt035lt07_digit = NTUB ENCLOSE xdfm_pdiff_gt035lt07_digit
   xdfm_nplus_gt035lt07_digit = NPLUS ENCLOSE xdfm_ndiff_gt035lt07_digit
   //  subtap is near nmos
   xdfm_subtap_gt035lt07_digit = subtap INTERACT (SIZE xdfm_nplus_gt035lt07_digit BY 1.0)
//
#IFDEF DEBUG_DIGITAL
   //xdfm_test { xdfm_ntub_gt035lt07_digit AND xdfm_ntub_eq035_digit }
   xdfm_routp_gt035lt07_digit { COPY xdfm_routp_gt035lt07_digit }
   xdfm_ndiff_gt035lt07_digit { COPY xdfm_ndiff_gt035lt07_digit }
   xdfm_pdiff_gt035lt07_digit { COPY xdfm_pdiff_gt035lt07_digit }
   xdfm_subtap_gt035lt07_digit { COPY xdfm_subtap_gt035lt07_digit }
   xdfm_ntub_gt035lt07_digit { COPY xdfm_ntub_gt035lt07_digit }
#ENDIF
//
//--------------------------------------------------------------------------------------------------
// get all parts of digital cells with L > 0.5 and L < 1.0/0.75 for all ntransm/ptransm
// get s/d diff and tap diff
//--------------------------------------------------------------------------------------------------
//
   xdfm_nmosm_gt050lt07x = ( PATH LENGTH xdfm_nmosm_l > 0.5 < 1.0 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL
   xdfm_nmosm_gt050lt07 = xdfm_nmosm INTERACT xdfm_nmosm_gt050lt07x
   xdfm_nmosm_gt07x = ( PATH LENGTH xdfm_nmosm_l > 1.0 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL
//
   xdfm_pmosm_gt050lt07x = ( PATH LENGTH xdfm_pmosm_l > 0.5 < 0.75 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL
   xdfm_pmosm_gt050lt07 = xdfm_pmosm INTERACT xdfm_pmosm_gt050lt07x
   xdfm_pmosm_gt07x = ( PATH LENGTH xdfm_pmosm_l >= 0.75) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL
//
   xdfm_pdiff_digi_mgt050lt07 = pdiff_1 INTERACT xdfm_pmosm_gt050lt07
   xdfm_pdiff_nodigi_mgt07 = pdiff_1 INTERACT xdfm_pmosm_gt07x
   xdfm_pdiff_mgt050lt07_digi_only = xdfm_pdiff_digi_mgt050lt07 NOT (xdfm_pdiff_nodigi_mgt07 NOT xdfm_pdiff_meq05_digi_only)
   //xdfm_pdiff_mgt050lt07_digi_only { COPY xdfm_pdiff_mgt050lt07_digi_only }
//
   xdfm_ndiff_digi_mgt050lt07 = ndiff_1 INTERACT xdfm_nmosm_gt050lt07
   xdfm_ndiff_nodigi_mgt07 = ndiff_1 INTERACT xdfm_nmosm_gt07x
   xdfm_ndiff_mgt050lt07_digi_only = xdfm_ndiff_digi_mgt050lt07 NOT (xdfm_ndiff_nodigi_mgt07 NOT xdfm_ndiff_meq05_digi_only)
   //xdfm_ndiff_mgt050lt07_digi_only { COPY xdfm_ndiff_mgt050lt07_digi_only }
//
// 0.35 U digital cells with L > 0.5 and L < 0.75/1.0
// remove any combinations with 0.5
//
   xdfm_routp_mgt050lt07_digi_1 = xdfm_routingpoly_all INTERACT
                ( xdfm_pmosm_gt050lt07 INTERACT xdfm_pdiff_mgt050lt07_digi_only )
   xdfm_routp_mgt050lt07_digit = xdfm_routp_mgt050lt07_digi_1 INTERACT
                ( xdfm_nmosm_gt050lt07 INTERACT xdfm_ndiff_mgt050lt07_digi_only )
//
// final ndiff/pdiff with 0.5 U gates
   xdfm_ndiff_mgt050lt07_digit = xdfm_ndiff_mgt050lt07_digi_only INTERACT xdfm_routp_mgt050lt07_digit
   xdfm_pdiff_mgt050lt07_digit = xdfm_pdiff_mgt050lt07_digi_only INTERACT xdfm_routp_mgt050lt07_digit
//
// get poly touching nmos and pmos
   xdfm_ntub_mgt050lt07_digit  = NTUB ENCLOSE xdfm_pdiff_mgt050lt07_digit
   xdfm_nplus_mgt050lt07_digit = NPLUS ENCLOSE xdfm_ndiff_mgt050lt07_digit
   //  subtap is near nmos
   xdfm_subtap_mgt050lt07_digit = subtap INTERACT (SIZE xdfm_nplus_mgt050lt07_digit BY 1.0)
//
#IFDEF DEBUG_DIGITAL
   xdfm_routp_mgt050lt07_digit { COPY xdfm_routp_mgt050lt07_digit }
   xdfm_ndiff_mgt050lt07_digit { COPY xdfm_ndiff_mgt050lt07_digit }
   xdfm_pdiff_mgt050lt07_digit { COPY xdfm_pdiff_mgt050lt07_digit }
   xdfm_subtap_mgt050lt07_digit { COPY xdfm_subtap_mgt050lt07_digit }
   xdfm_ntub_mgt050lt07_digit { COPY xdfm_ntub_mgt050lt07_digit }
#ENDIF
//
//--------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------
//
   ovlp_ndiff_sd = COPY x_n
   NTRANS_MISS_CONTS_DFMC0004 { @ DFM0004 : use as many diffcon as possible
                              @ more s/d conts should be placed on ntrans sd      
     ndiff_sd_cont_closed = SIZE ndiff_sd_cont BY 0.5
     ovlp_ndiff_sd_conts = ovlp_ndiff_sd AND  ndiff_sd_cont_closed
     ndiff_sd_cont_closed_conn = STAMP ndiff_sd_cont_closed BY ndiff_sd_cont
     xx = NET AREA RATIO ndiff_sd ndiff_sd_cont_closed_conn > sd_dens
     yy = SIZE( xx NOT ndiff_sd_cont_closed) BY 0.4 UNDEROVER
     // not in pad nmos ESD Protection
     z = yy NOT INTERACT ndiff_nmos_pad
     // filter digital cells
#IFDEF DEBUG_DIGITAL
     COPY z
#ELSE
     z NOT INTERACT (xdfm_ndiff_eq035_digit OR xdfm_ndiff_meq05_digit)
#ENDIF
     //zz = yy NOT INTERACT ndiff_nmos_pad
     // show all diff
     //ndiff_sd INTERACT zz
   }
//
// get pdiff sd conts
//--------------------------
//
   common_edge1_p = EXTERNAL MET1 [pdiff_sd] < 0.002 INSIDE ALSO CONNECTED
   common_edge2_p = EXTERNAL pdiff_sd [MET1] < 0.002 INSIDE ALSO CONNECTED
   //comm1 { COPY common_edge1_p }
   //comm2 { COPY common_edge2_p }
   common_m1_p = (MET1 and pdiff_sd) WITH EDGE common_edge1_p
   common_m2_p = (MET1 and pdiff_sd) WITH EDGE common_edge2_p
   x_p = common_m1_p OR common_m2_p
//
#IFDEF CONNECT_COUNT    
   INFO_M1_PDIFF_CONT_1_CONNECTION {
          x_p ENCLOSE pdiff_sd_cont == 1
   }
   INFO_M1_PDIFF_CONT_2_CONNECTION {
          x_p ENCLOSE pdiff_sd_cont == 2
   }
   INFO_M1_PDIFF_CONT_3_CONNECTION {
          x_p ENCLOSE pdiff_sd_cont == 3
   }
   INFO_M1_PDIFF_CONT_4_CONNECTION {
          x_p ENCLOSE pdiff_sd_cont == 4
   }
   INFO_M1_PDIFF_CONT_5_CONNECTION {
          x_p ENCLOSE pdiff_sd_cont == 5
   }
   INFO_M1_PDIFF_CONT_6_CONNECTION {
          x_p ENCLOSE pdiff_sd_cont == 6
   }
   INFO_M1_PDIFF_CONT_7_CONNECTION {
          x_p ENCLOSE pdiff_sd_cont == 7
   }
   INFO_M1_PDIFF_CONT_8_CONNECTION {
          x_p ENCLOSE pdiff_sd_cont == 8
   }
   INFO_M1_PDIFF_CONT_9_CONNECTION {
          x_p ENCLOSE pdiff_sd_cont == 9
   }
   INFO_M1_PDIFF_CONT_GE10_CONNECTION {
          x_p ENCLOSE pdiff_sd_cont >= 10
   }
#ENDIF
//
//
   ovlp_pdiff_sd = COPY x_p
//
// remove error from large ptrans in pad with cont/sd spacing == 1.8
//
   pdiff_sd_gate_1 = pdiff_sd COIN EDGE pgate
   pdiff_sd_gate_2 = LENGTH pdiff_sd_gate_1 > 45.0
   pdiff_sd_long   = pdiff_sd WITH EDGE pdiff_sd_gate_2
   pdiff_cont_ovl  = ENC pdiff_sd_cont pdiff_sd_long > 1.7 < 1.9 PARALLEL OPPOSITE REGION
//
   pdiff_sd_long_ptrans_pad =  pdiff_sd_long INTERACT pdiff_cont_ovl
   //pdiff_sd_long_ptrans_pad { FLATTEN pdiff_sd_long_ptrans_pad }
//
   PTRANS_MISS_CONTS_DFMC0004 { @ DFM0004: use as many diffcon as possible
                                @ more s/d conts should be placed on ptrans sd diff
     pdiff_sd_cont_closed = SIZE pdiff_sd_cont BY 0.5
     ovlp_pdiff_sd_conts = ovlp_pdiff_sd AND  pdiff_sd_cont_closed
     pdiff_sd_cont_closed_conn = STAMP pdiff_sd_cont_closed BY pdiff_sd_cont
     xx = NET AREA RATIO pdiff_sd pdiff_sd_cont_closed_conn > sd_dens
     yy = SIZE( xx NOT pdiff_sd_cont_closed) BY 0.4 UNDEROVER
     z = yy NOT INTERACT pdiff_sd_long_ptrans_pad
     // filter digital cells
#IFDEF DEBUG_DIGITAL
     COPY z
#ELSE
     z NOT INTERACT (xdfm_pdiff_eq035_digit OR xdfm_pdiff_meq05_digit)
#ENDIF
     //zz = yy NOT INTERACT pdiff_sd_long_ptrans_pad
     //show all ndiff
     //pdiff_sd INTERACT zz
   }
//
// substrate taps
//--------------------------
//
   common_edge1_subtap = EXTERNAL MET1 [subtap] < 0.002 INSIDE ALSO CONNECTED
   common_edge2_subtap = EXTERNAL subtap [MET1] < 0.002 INSIDE ALSO CONNECTED
   //comm1 { COPY common_edge1_subtap }
   //comm2 { COPY common_edge2_subtap }
   common_m1_subtap = (MET1 and subtap) WITH EDGE common_edge1_subtap
   common_m2_subtap = (MET1 and subtap) WITH EDGE common_edge2_subtap
   ovlp_subtap = common_m1_subtap OR common_m2_subtap
//   ovlp_subtap { COPY ovlp_subtap }
//
// search m1 with subtap net and check if more conts can be placed there
   MORE_CONT_SUBTAP_DFMC0004 { @ DFM0004 : use as many diffcon as possible
                              @ more subtap conts can be placed here on existing met1 connection
     pdiff_subtap_cont_closed = (SIZE pdiff_subtap_cont BY 0.5) AND ovlp_subtap
     z = SIZE ( ovlp_subtap NOT pdiff_subtap_cont_closed) BY 0.2 UNDEROVER
     // filter digital cells
     aa = z NOT (xdfm_subtap_eq035_digit OR xdfm_subtap_meq05_digit)
     // allow at least 20 conts to add
     bb = RECTANGLES 0.4 0.4 0.4 INSIDE OF LAYER aa
     aa ENCLOSE bb > 20
   }
//
// search subtap diff with subtap conts and check if more conts can be placed
// in diff without met1, remove unrelated metal1
//
   SUBTAP_MISS_CONTS_DFMC0004 { @ DFM0004 : use as many diffcon as possible
                               @ more subtap conts should be placed in subtap pdiff with met1   
                               @ latchup improvement
     pdiff_subtap_cont_closed = (SIZE pdiff_subtap_cont BY 0.5) AND ovlp_subtap
     pdiff_subtap_cont_closed_conn = STAMP pdiff_subtap_cont_closed BY pdiff_subtap_cont
     // remove subtap covered by unrelated met1
     subtap_unrelated = subtap NOT (SIZE (MET1 NOT ovlp_subtap) BY 0.2)
     xx = NET AREA RATIO subtap_unrelated pdiff_subtap_cont_closed_conn > subtap_dens
     z = SIZE( xx NOT pdiff_subtap_cont_closed) BY 0.4 UNDEROVER
     // filter digital  
     aa = z NOT ( xdfm_subtap_eq035_digit OR xdfm_subtap_meq05_digit)
     // allow at least 20 conts to add
     bb = RECTANGLES 0.4 0.4 0.4 INSIDE OF LAYER aa
     aa ENCLOSE bb > 20
   }
//
// well substrate taps
//--------------------------
//
   common_edge1_welltap = EXTERNAL MET1 [welltap] < 0.002 INSIDE ALSO CONNECTED
   common_edge2_welltap = EXTERNAL welltap [MET1] < 0.002 INSIDE ALSO CONNECTED
   //comm1 { COPY common_edge1_welltap }
   //comm2 { COPY common_edge2_welltap }
   common_m1_welltap = (MET1 and welltap) WITH EDGE common_edge1_welltap
   common_m2_welltap = (MET1 and welltap) WITH EDGE common_edge2_welltap
   ovlp_welltap = common_m1_welltap OR common_m2_welltap
//   ovlp_welltap { COPY ovlp_welltap }
//
   MORE_CONT_WELLTAP_DFMC0004 { @ DFM0004: use as many diffcon as possible
                               @  more welltap conts can be placed here on existing met1 connection
     ndiff_welltap_cont_closed = (SIZE ndiff_welltap_cont BY 0.5) AND ovlp_welltap
     xx = SIZE ( ovlp_welltap NOT ndiff_welltap_cont_closed) BY 0.2 UNDEROVER
     // not in nwell pad ESD protection
     yy = xx NOT INTERACT ndiff_nmos_pad
     // filter digital cells
     aa = yy NOT (xdfm_ntub_eq035_digit OR xdfm_ntub_meq05_digit)
     // allow at least 20 conts to add
     bb = RECTANGLES 0.4 0.4 0.4 INSIDE OF LAYER aa
     aa ENCLOSE bb > 20
   }
//
//   ndiff_welltap_cont { COPY ndiff_welltap_cont }
//   welltap { COPY welltap }
//   ndiff_welltap_cont_closed { COPY ((SIZE ndiff_welltap_cont BY 0.5) AND ovlp_welltap) }
// cont width = 0.4, diff ovlp = 0.3
//
   WELLTAP_MISS_CONTS_DFMC0004 { @ DFM0004 : use as many diffcon as possible
                                 @ more welltap conts should be placed in welltap ndiff with met1   
                                 @ latchup improvement
     ndiff_welltap_cont_closed = (SIZE ndiff_welltap_cont BY 0.5) AND ovlp_welltap
     ndiff_welltap_cont_closed_conn = STAMP ndiff_welltap_cont_closed BY ndiff_welltap_cont
     // remove welltap covered by unrelated met1
     // eg metals crossing ntap ring in well for interconnection
     welltap_unrelated = welltap NOT (SIZE (MET1 NOT ovlp_welltap) BY 0.2)
     xx = NET AREA RATIO welltap_unrelated ndiff_welltap_cont_closed_conn > welltap_dens
     yy = SIZE( xx NOT ndiff_welltap_cont_closed) BY 0.4 UNDEROVER
     zz = yy NOT INTERACT ndiff_nmos_pad
     // filter digital
     aa = zz NOT (xdfm_ntub_eq035_digit OR xdfm_ntub_meq05_digit)
     // allow at least 20 conts to add
     bb = RECTANGLES 0.4 0.4 0.4 INSIDE OF LAYER aa
     aa ENCLOSE bb > 20
   }
//
   WELLTAP_UNCONNECTED_DFMC0003 { @ DFM0003 : ntap without diffcon is not allowed
        welltap NOT ENCLOSE CONT
   }
//
   SUBTAP_UNCONNECTED_DFMC0002 { @ DFM0002 : ptap without diffcon is not allowed
        subtap NOT ENCLOSE CONT
   }
//
#ENDIF
//
//==========================================================================
// DFM0005 check for too long gate to poly cont connection
//==========================================================================
//  check for 15 U, trace from cont to gate and from gate to cont
//
//
#IFNDEF CONNECT_STATISTIC
// this is twice
//
   ndiff_1        = DIFF  AND NPLUS
   pdiff_1        = DIFF  AND PPLUS
   ndiff          = ndiff_1 NOT POLY1
   pdiff          = pdiff_1 NOT POLY1
   trans          = DIFF AND POLY1
   ngate          = trans NOT NTUB
   pgate          = trans AND NTUB

#ENDIF
//
   //routingpoly    = POLY1 NOT RESDEF
   routingpoly    = COPY POLY1
//
   gates_l0 = ngate OR pgate
//
   routingpoly_nogat = routingpoly NOT gates_l0
   routingpoly_for_trace = routingpoly_nogat INTERACT gates_l0
//
   poly_diff_term = (COIN EDGE routingpoly_for_trace DIFF) EXPAND EDGE OUTSIDE  BY 0.1
   //poly_diff_term { COPY poly_diff_term }
//
// trace 25 U from gate term
// use 15 U
//
   //poly_a { COPY poly_a }
   poly1con_gate = poly1con INTERACT routingpoly_for_trace
//
   poly1con_gate_trace  = SIZE poly1con_gate INSIDE OF routingpoly_for_trace BY 15 STEP 0.2
   poly_diff_term_trace = SIZE poly_diff_term INSIDE OF (routingpoly_for_trace NOT poly1con_gate_trace) BY 15 STEP 0.2
//
   //poly1con_gate_trace { COPY  poly1con_gate_trace }
   //poly_diff_term_trace { COPY  poly_diff_term_trace }
//
// check only if dist to poly cont is more than 15
// do not check poly without cont
// false errors if L > W in trans with snake like gate
//
   gate_notch = EXT gates_l0 < 1.0 NOTCH REGION
//
   LONG_POLY1_GATE_CONT_DFMA0005 { @ DFM0005: maximum poly1 length from gate to first poly1con 15 U
                                   @          use metal for gate connection
                                   @          only narrow poly < 0.6 U width
       x = poly_diff_term_trace INTERACT ( routingpoly_for_trace INTERACT poly1con_gate)
       // filter 
       y = x NOT gate_notch
       z = y WITH WIDTH < 0.6
       u = z NOT INTERACT xdfm_routp_eq035_digit
       AREA u > 1.0
   }
//
//==========================================================================
//         DFM0009/ DFM0012/ DFM0015 gate to via area checks                         
//==========================================================================
// add at the end
//
//
// skip this for testing
//
#IFDEF CHECK_MERGE
//====================================================================================
//          get duplicated placement of cells
// finds all merged data, also in all levels of hierarchy
//====================================================================================
// only for testing 
// attention : hierarchcal DRC removes cells in some cases
//             ELIMINATING DUPLICATE CELL
//             needs flat DRC
//
//
// check for any LV - gates in duplicate placed cells
// by single layer merge
// get rid of any pieces overlapping
//
// check for low voltage gate
//
     nplus_merg = AND NPLUS_alldata        
     pplus_merg = AND PPLUS_alldata        
     diff_merg  = AND DIFF_alldata        
     poly1_merg = AND POLY1_alldata        
     poly2_merg = AND POLY2_alldata        
     met1_merg  = AND MET1_alldata        
     met2_merg  = AND MET2_alldata        
     met3_merg  = AND MET3_alldata        
     met4_merg  = AND MET4_alldata               
     cont_merg  = AND CONT_alldata        
     via_merg   = AND VIA_alldata        
     via2_merg  = AND VIA2_alldata        
     via3_merg  = AND VIA3_alldata        
//
   met1_cont_merg = met1_merg AND cont_merg
//
   INFO_DUPLICATE_PLACEMENT_DEVICE { @ INFO : this device is probably located in a duplicated placed cell
     gate = poly1_merg AND diff_merg
     ngate = nplus_merg AND gate
     pgate = pplus_merg AND gate
//   only > 0.15
     gate_all = SIZE ( ngate OR pgate) BY 0.15 UNDEROVER
     pndiff_all = (diff_merg AND (nplus_merg OR pplus_merg)) INTERACT gate_all
     sd_diff = pndiff_all NOT gate_all
     gate_merge =  gate_all TOUCH sd_diff == 2
//
// get merged diff and poly1 cont
//
     x = diff_merg AND met1_cont_merg 
     x1 = x AND nplus_merg
     x2 = x AND pplus_merg
     cd = x1 OR x2
     diffcont_merg = RECTANGLE cd == 0.4 BY == 0.4
     cp = poly1_merg AND met1_cont_merg 
     p1cont_merge =  RECTANGLE cp == 0.4 BY == 0.4
//
// get s/d diff and gate touching merged data
//
     sd_diff_final = (sd_diff INTERACT gate_merge) ENCLOSE diffcont_merg
     poly1_final   = (poly1_merg INTERACT sd_diff) ENCLOSE p1cont_merge  
     gate_merge_final = ( gate_merge INTERACT sd_diff_final) INTERACT poly1_final 
     sd_diff_final INTERACT  gate_merge_final
     poly1_final INTERACT  gate_merge_final
     FLATTEN ( poly1_final OR (sd_diff_final OR gate_merge_final))
  }
//
   INFO_DUPLICATE_PLACEMENT_VIA { @ INFO : this via is probably located in a duplicated placed cell
     vi = via_merg AND (met1_merg AND met2_merg)
     FLATTEN( RECTANGLE vi == 0.5 BY == 0.5)
   }
   INFO_DUPLICATE_PLACEMENT_VIA2 { @ INFO : this via2 is probably located in a duplicated placed cell
     vi = via2_merg AND (met3_merg AND met2_merg)
     FLATTEN( RECTANGLE vi == 0.5 BY == 0.5)
   }
   INFO_DUPLICATE_PLACEMENT_VIA3 { @ INFO : this via3 is probably located in a duplicated placed cell
     vi = via3_merg AND (met4_merg AND met3_merg)
     FLATTEN( RECTANGLE vi == 0.5 BY == 0.5)
   }
#ENDIF
//==========================================================================
//           DFM0017 ROF value (thick met4 only s35/h35)                         
//==========================================================================
#IFDEF fourmetal_thick
//=====================================================================
// check for total surface of thick met4 ( area + perimeter * 2.8 )
// ROF value = (chip area + met4 perim * 3)/ chip area
// 2.8 U is thickness of met4
//=====================================================================
//
// examples stress rectangles only
//
// 4249 = count of rectangles 2.5 * 5
// 53112 = area
// 63735 = 15 * 4249
// 278458 = 25 x 4249 x 2.8
// tot = 231570 U * U
//
   met4_stress_rectangles =  RECTANGLE MET4 == 2.5 BY == 5.0
   //met4_stress_rectangles { COPY met4_stress_rectangles }
//
   rof_substrate_all = EXTENT
//
   met4_thick_net = COPY MET4
   substrate_all_net = COPY rof_substrate_all
   CONNECT met4_thick_net substrate_all_net
//
   THICK_MET4_STRESS_RECT_INFO_DFM0017 { @ DFM0017 :total thick met4 stress rectangles
       //substrate_all_net = POLYNET substrate_all
       met4_thick_net = STAMP met4_stress_rectangles BY substrate_all_net
       xx = NET AREA RATIO met4_thick_net substrate_all_net > 0 [ COUNT(met4_thick_net)] ACCUMULATE
       NET AREA RATIO PRINT xx 'met4_stress_rect_count.txt'
   }
//
   THICK_MET4_SURFACE_DUMMY_DFM0017 { @ DFM0017 :total thick met4 surface
       //substrate_all_net = POLYNET substrate_all
       //met4_thick_net = STAMP MET4 BY substrate_all_net
       // get shape count
       xx = NET AREA RATIO met4_thick_net substrate_all_net > 0 [ COUNT(met4_thick_net)] ACCUMULATE
       NET AREA RATIO PRINT xx 'met4_shape_count.txt'
       // get shape area
       yy = NET AREA RATIO met4_thick_net substrate_all_net > 0 [ AREA(met4_thick_net)] ACCUMULATE
       NET AREA RATIO PRINT yy 'met4_shape_area.txt'
       // get total surface
       zz = NET AREA RATIO met4_thick_net substrate_all_net > 0 [ PERIMETER(met4_thick_net)] ACCUMULATE
       NET AREA RATIO PRINT zz 'met4_shape_perim.txt'
       // get die area
       uu = NET AREA RATIO met4_thick_net substrate_all_net > 0 [ AREA(substrate_all_net)] ACCUMULATE
       NET AREA RATIO PRINT uu 'met4_die_area_all.txt'
       // get total met to die area
       rr = NET AREA RATIO met4_thick_net substrate_all_net > 0 [ AREA(met4_thick_net)/AREA(substrate_all_net)] ACCUMULATE
       NET AREA RATIO PRINT rr 'met4_met4_die_ratio.txt'
       // for fab
       vv = NET AREA RATIO met4_thick_net substrate_all_net > 0
               [(AREA(substrate_all_net) + (3.0 * PERIMETER(met4_thick_net)))/ AREA(substrate_all_net)] ACCUMULATE
       NET AREA RATIO PRINT vv 'met4_rof_nitride_final_ratio.txt'
   }
//
//
//==================================================
// check for critical value of ROF 
//==================================================
//
// ROF value : Nitrid-dicken-Abscheidung
//              Probleme mit Fill - Pattern
//              Fill Pattern 2.5x5 mit 4 um Abstand
//              Stuetzpattern (innerhalb 25 um) fuer isolierte Leitungen
//
// Kritische Werte fuer  D= (Chipsize + P_metal * 3)/Chipsize
//
// Optimaler Wert: 1.5
// Kritischer Wert: 1.8
//
   BAD_TMET4_DIE_RATIO_GT_1P80_DFM0017 { @ DFM0017 Error: ROF value too high:(chipsize + met4 peri *3)/chipsize > 1.8
       NET AREA RATIO met4_thick_net substrate_all_net > 1.8
               [(AREA(substrate_all_net) + (3.0 * PERIMETER(met4_thick_net)))/ AREA(substrate_all_net)] ACCUMULATE
   }
//
   BAD_TMET4_DIE_RATIO_LT_1P10_INFO_DFM0017 { @ DFM0017 Info : ROF value too low :(chipsize + met4 peri *3)/chipsize < 1.1
       NET AREA RATIO met4_thick_net substrate_all_net < 1.1
               [(AREA(substrate_all_net) + (3.0 * PERIMETER(met4_thick_net)))/ AREA(substrate_all_net)] ACCUMULATE
   }
//
   TOO_HIGH_TMET4_DIE_RATIO_GT_1P55_LT_1P80_INFO_DFM0017 { @ DFM0017 Info :ROF value too high,
                                                           @ not optimum (chipsize + met4 peri *3)/chipsize >= 1.55 < 1.8
       NET AREA RATIO met4_thick_net substrate_all_net >= 1.55 <= 1.8
               [(AREA(substrate_all_net) + (3.0 * PERIMETER(met4_thick_net)))/ AREA(substrate_all_net)] ACCUMULATE
   }
//
   TOO_LOW_TMET4_DIE_RATIO_GT_1P10_LT_1P45_INFO_DFM0017 { @ DFM0017 Info:ROF value too low,
                                                          @  not optimum (chipsize + met4 peri *3)/chipsize > 1.1 <= 1.45
       NET AREA RATIO met4_thick_net substrate_all_net >= 1.1 <= 1.45
               [(AREA(substrate_all_net) + (3.0 * PERIMETER(met4_thick_net)))/ AREA(substrate_all_net)] ACCUMULATE
   }
//
   OPTIMUM_TMET4_DIE_RATIO_GT_1P45_LT_1P55_INFO_DFM0017 { @ DFM0017 Info ROF value optimum (chipsize + met4 peri *3)/chipsize > 1.45 < 1.55
       NET AREA RATIO met4_thick_net substrate_all_net > 1.45 < 1.55
               [(AREA(substrate_all_net) + (3.0 * PERIMETER(met4_thick_net)))/ AREA(substrate_all_net)] ACCUMULATE
   }
//====================================================================================
#ENDIF
//
///////////////////////////////////////////////////////////////////////
//
//                   end of DFM part1 checks 
//
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//
//   CALIBRE  R U L E S  F I L E  F O R  P R O C E S S  C 3 5
//
///////////////////////////////////////////////////////////////////////
//
//  CMOS C35 DFM rules  Document: ENG-301              Revision: REV 3
//
///////////////////////////////////////////////////////////////////////
//                  c35 device recognition
///////////////////////////////////////////////////////////////////////
//
//       _rules_title
//
//       Document: ENG-325                      Revision: 1.0
//
//       Created with ams_tech on by
//
//=====================================================================
//   Version          Datum          by       Description
//---------------------------------------------------------------------
//    2.0          20-Jun-2008     aob    update device recognition 
//---------------------------------------------------------------------
//
//                  8-Feb-2007  aob   Doc rev 6 implemented
//                                    metres, ipdef, kepout
//                 13-Feb-2007  aob   photo diode added (phdnwa850)
//                                    c35b4o1/c35b3o1 process options and
//                                    nwell shield added
//                 10-Sep-2007  aob   add nmos30m/nmos30t device
//
//                 30-Jun-2008  aob   for h35 skip device info and add extra
//                                    latchup for isloated devices only
//---------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////
//
//   Derived Layers are defined to find the following devices
//---------------------------------------------------------------------
//
//   EX 1 - metres, metrpoly1, rpoly2, rpoly2rf, rpolyh, rpolyhrf, rdiffn, rdiffp, rnwell
//   EX 2 - pnpvert, pnplat2
//   EX 3 - nmosh, nmos4, pmos4
//   EX 4 - cpoly, cpolyrf, cvar, cmim
//   EX 5 - nd, pd, nwd, zdiode, photo
//   EX 6 - nmos30m/t
//          spirals
//          rf devices
//          lvt devices ( 6 )
//
///////////////////////////////////////////////////////////////////////
//=====================================================================
//=====================================================================
// some variables may be identical with other section, add dfm_ 
//=====================================================================
// extract devices
//
// create layers to find substrate

// for test purposes
// POLYGON -10.0 -10.0 221.0 240.0 SUBDEF
// cut nwell if subdef edge cuts ntub, but do
// not cut substrate below ntub
// create a small area of subdef

   dfm_subdef_ring    = SUBDEF NOT (SIZE SUBDEF BY -0.05)
   dfm_substrate_all  = EXTENT

   dfm_ntub_subdefcut = NTUB NOT dfm_subdef_ring
   dfm_substrate      = (dfm_substrate_all NOT dfm_subdef_ring) OR (dfm_subdef_ring AND NTUB)

   dfm_psub           = dfm_substrate NOT NTUB

//=====================================================================
// remove cut layer areas

   dfm_diff_cut         = DIFF NOT DIFCUT
   dfm_poly1_cut        = POLY1 NOT PO1CUT
   dfm_poly2_cut        = POLY2 NOT PO2CUT


//=====================================================================
// get contacts

// poly1 and poly2 contacts

   dfm_poly1_n_poly2    = dfm_poly1_cut NOT dfm_poly2_cut
   dfm_poly1con_all     = CONT AND dfm_poly1_n_poly2
   dfm_con_n_p1         = CONT NOT dfm_poly1con_all
   dfm_poly2con_all     = CONT AND dfm_poly2_cut   

// other contacts
// rpolyh is poly2
//
   dfm_rpolyhcon        = dfm_poly2con_all AND HRES
   dfm_diffcon_all      = CONT AND dfm_diff_cut
//
// for ERC
//
   dfm_via_cont         = VIA OR CONT
   dfm_via2_via         = VIA2 OR VIA
#IFDEF fourmetal
   dfm_via3_via2        = VIA3 OR VIA2
#ELSE
   dfm_via3_via2        = COPY VIA2
#ENDIF


//=====================================================================
// create layers to find ndiff and pdiff structures

   dfm_ndiff_1          = dfm_diff_cut AND NPLUS
   dfm_pdiff_1          = dfm_diff_cut AND PPLUS


//=====================================================================
// EX 1  EX 1  EX 1  EX 1  EX 1  EX 1  EX 1  EX 1  EX 1  EX 1  EX 1  
//=====================================================================
// create layers to find poly2, polyh, ndiff, pdiff and nwell resistors

   dfm_poly1_poly2      = POLY1 AND POLY2

// poly1 resistor

   dfm_pres1_1           = (dfm_poly1_cut AND RESDEF) NOT HRES
   dfm_pres1_2           = dfm_pres1_1 NOT dfm_poly1_poly2
   dfm_pres1             = dfm_pres1_2 NOT RESTRM

// poly2 resistor

   dfm_pres_1           = (dfm_poly2_cut AND RESDEF) NOT HRES
   dfm_pres_2           = dfm_pres_1 NOT dfm_poly1_poly2
   dfm_pres             = dfm_pres_2 NOT RESTRM

// rf device
   dfm_pres_rf_device   = RFDEF ENCLOSE dfm_pres
//
   dfm_pres_norf        = dfm_pres   NOT RFDEF

// hrespoly resistor with resdef, no restrm

   dfm_presh_1          = dfm_poly2_cut AND HRES
// dfm_presh            = (dfm_presh_1 NOT PPLUS) AND RESDEF
   dfm_presh            = dfm_presh_1 NOT PPLUS
   dfm_preshterm        = dfm_presh_1 AND PPLUS
//
   dfm_presh_norf       = dfm_presh NOT RFDEF
   dfm_presh_rf_device  = RFDEF ENCLOSE dfm_presh

// pdiff resistor
 
   dfm_pdres_1          = dfm_pdiff_1 AND RESDEF
   dfm_pdres_2          = dfm_pdres_1 NOT INTERACT dfm_pres
   dfm_pdres            = dfm_pdres_2 NOT RESTRM

// ndiff resistor

   dfm_ndres_1          = dfm_ndiff_1 AND RESDEF
   dfm_ndres_2          = dfm_ndres_1 NOT INTERACT dfm_pres
   dfm_ndres            = dfm_ndres_2 NOT RESTRM

// nwell resistor

   dfm_nwres_1          = NTUB AND TUBDEF
   dfm_nwres_2          = dfm_nwres_1 NOT INTERACT dfm_pdres
   dfm_nwres_3          = dfm_nwres_2 NOT INTERACT dfm_ndres
   dfm_nwres            = dfm_nwres_3 NOT RESTRM
//
//
#IFDEF DEVSWITCH
  xrpoly1   { COPY dfm_pres1 }
  xrpoly2   { COPY dfm_pres_norf }
  xrpoly2rf { COPY dfm_pres_rf_device }
  xrpolyh { COPY dfm_presh_norf }
  xrpolyhrf  { COPY dfm_presh_rf_device }
  xrdiffp { COPY dfm_pdres }
  xrdiffn { COPY dfm_ndres }
  xrnwell { COPY dfm_nwres }
#ENDIF

//=====================================================================
// create layers to find poly1, poly2 and nwell structures not belonging
// to a resistor

   dfm_routingpoly_all  = COPY dfm_poly1_cut
   dfm_routingpoly2_1   = dfm_poly2_cut NOT dfm_pres
   dfm_routingpoly2_all = dfm_routingpoly2_1 NOT dfm_presh
//
// cut ntub if subdef crosses ntub
// remove isolated ntub stripes in spirals 
// and cut nwell in hall element
//
   dfm_routingnwell  = ((dfm_ntub_subdefcut NOT dfm_nwres) NOT INDDEF) NOT HALLDEF    

//=====================================================================
// create layers to find ndiff and pdiff structures not belonging
// to a resistor or any gate structure

   dfm_ndiff_2          = dfm_ndiff_1 NOT dfm_routingpoly_all
   dfm_ndiff            = dfm_ndiff_2 NOT dfm_ndres

   dfm_pdiff_2          = dfm_pdiff_1 NOT dfm_routingpoly_all
   dfm_pdiff            = dfm_pdiff_2 NOT dfm_pdres


//=====================================================================
// create layers to find gate structures of n- and p- low voltage 
// devices and nmosh (NTUB version)

   dfm_trans            = dfm_diff_cut AND dfm_routingpoly_all
   dfm_ngate            = dfm_trans NOT NTUB
   dfm_pgate            = dfm_trans AND NTUB
   dfm_gate             = dfm_ngate OR dfm_pgate
   dfm_ndev             = dfm_ngate AND NPLUS
   dfm_pdev             = dfm_pgate AND PPLUS


//=====================================================================
// EX 2  EX 2  EX 2  EX 2  EX 2  EX 2  EX 2  EX 2  EX 2  EX 2  EX 2  
//=====================================================================
// create layers to find pnpvert and pnplat2 bipolar transistors

// pnpvert (vert10 - pnp vertical bipolar transistor - 10um * 10um)

   dfm_pnpvert_1        = HOLES dfm_pdiff < 1000.0
// filter too large holes
   dfm_pnpvert_2        = NTUB INSIDE dfm_pnpvert_1
   dfm_pnpvert_3        = dfm_ndiff AND dfm_pnpvert_2
   dfm_pnpvert_4        = HOLES dfm_pnpvert_3
   dfm_pnpvert_5        = dfm_pdiff INSIDE dfm_pnpvert_4
   dfm_pnpvert10_e_1    = PERIMETER dfm_pnpvert_5 >39.9 < 40.1
// get rid of emi ni square
   dfm_pnpvert10_e      = RECTANGLE dfm_pnpvert10_e_1 > 9  BY > 9
   dfm_pnpvert10        = SIZE dfm_pnpvert10_e BY 2.0

// pnplat2 (pnp lateral bipolar transistors)
// lat2 has emitter area 2*2
 
   dfm_pnplat           = HOLES dfm_pdev < 10.0
//
// pnplat2_e        = PERIMETER pnplat >7.95 <8.05
//
// allow poly1 biasing
   dfm_pnplat2_e        = PERIMETER dfm_pnplat >7.5 <8.05
   dfm_pnplat2_c        = (dfm_pdiff TOUCH dfm_pnplat2_g) NOT dfm_pnplat2_e
   dfm_pnplat2_g        = dfm_pdev TOUCH dfm_pnplat2_e

#IFDEF DEVSWITCH
   xpnplat    { COPY dfm_pnplat2_e }
   xpnpvert10 { COPY dfm_pnpvert10 }
#ENDIF
//=====================================================================
// create layers to find nwells belonging to illegal hv transistors
// illegal is : ntub touches exactly trans
//              ntub ovlp != 1.6

   dfm_nwell_ill        = NTUB TOUCH trans 
   dfm_nwell_hv_trans   = NTUB CUT trans
   dfm_nwell_hvmos_good = INT dfm_nwell_hv_trans dfm_trans == 1.6 OPPOSITE PARA ONLY REGION
   dfm_ill_hvmos_nwell  = dfm_nwell_ill OR (dfm_nwell_hv_trans NOT INTERACT dfm_nwell_hvmos_good)
   dfm_nwell_n_hvmos    = NTUB NOT INTERACT dfm_nwell_hvmos_good

//=====================================================================
// EX 3  EX 3  EX 3  EX 3  EX 3  EX 3  EX 3  EX 3  EX 3  EX 3  EX 3  
//=====================================================================
// create layers to find mos transistors (pmos, nmos, nmosh)
// midox and lvt devices

   dfm_routp_n_trans    = dfm_routingpoly_all NOT trans

// pmos transistors
 
   dfm_pmos_1           = dfm_pdev NOT dfm_pnplat2_g
   dfm_pmos_2           = dfm_pmos_1 TOUCH dfm_routp_n_trans
   dfm_pmos_3           = dfm_pmos_2 TOUCH dfm_pdiff == 2
//
   dfm_pmos_4           = (dfm_pmos_3 NOT MIDOX) NOT LVTDEF
   dfm_pmos_midox       = (dfm_pmos_3 AND MIDOX) NOT LVTDEF
//
//
   dfm_pmos_lvt         = (dfm_pmos_3 NOT MIDOX) AND LVTDEF
   dfm_pmos_mlvt        = (dfm_pmos_3 AND MIDOX) AND LVTDEF
//
   dfm_pmos             = dfm_pmos_4 NOT RFDEF
   dfm_pmosrf_trans     = dfm_pmos_4 AND RFDEF
   dfm_pmosrf_device_layer = RFDEF ENCLOSE dfm_pmosrf_trans
//
// nmosh transistors
// check for touching or ovlp of ntub
//
   dfm_nmosh_1          = (dfm_trans TOUCH NTUB) OR (dfm_trans CUT NTUB)
   dfm_nmosh            = dfm_nmosh_1 INTERACT dfm_ndev
// 
// avoid false extract   
   dfm_nmoshall         = dfm_nmosh_1 AND (dfm_trans AND NPLUS)
   dfm_nmosh_d          = dfm_ndiff AND (NTUB INTERACT dfm_nmoshall)
   dfm_nmosh_d_fill     = EXT dfm_nmosh_d dfm_nmosh < 6.00 OPPOSITE PARA ONLY
                      REGION
   dfm_nmosh_d_term_1   = dfm_nmosh_d OR dfm_nmosh_d_fill
   dfm_nmosh_d_term     = dfm_nmosh_d_term_1 TOUCH dfm_nmosh

   // nmosmh { COPY nmosmh }
   // nmosh { COPY nmosh_nomidox }
//
   dfm_nmosh_nomidox    = (dfm_nmosh NOT INTERACT MIDOX) NOT LVTDEF
   dfm_nmosmh           = (dfm_nmosh INTERACT MIDOX) NOT LVTDEF
//
   dfm_nmosh_nomidox_lvt  = (dfm_nmosh NOT INTERACT MIDOX) AND LVTDEF
   dfm_nmosmh_lvt         = (dfm_nmosh INTERACT MIDOX) AND LVTDEF
//

// nmos transistors with and without midox

   dfm_nmos_1           = dfm_ndev NOT dfm_nmosh
   dfm_nmos_2           = dfm_nmos_1 NOT INTERACT dfm_ill_hvmos_nwell
   dfm_nmos_3           = dfm_nmos_2 TOUCH dfm_routp_n_trans
   dfm_nmos_4           = dfm_nmos_3 TOUCH dfm_ndiff == 2
//
   dfm_nmos_5           = (dfm_nmos_4 NOT MIDOX) NOT LVTDEF
   dfm_nmos_midox       = (dfm_nmos_4 AND MIDOX) NOT LVTDEF
//
   dfm_nmos_lvt         = (dfm_nmos_4 NOT MIDOX) AND LVTDEF
   dfm_nmos_mlvt        = (dfm_nmos_4 AND MIDOX) AND LVTDEF
//
   dfm_nmos             = dfm_nmos_5 NOT RFDEF
   dfm_nmosrf_trans     = dfm_nmos_5 AND RFDEF
   dfm_nmosrf_device_layer = RFDEF ENCLOSE dfm_nmosrf_trans
//
#IFDEF DEVSWITCH
   xnmosh { COPY dfm_nmosh_nomidox }
   xnmosmh { COPY dfm_nmosmh }
//
   xnmoshl4 { COPY dfm_nmosh_nomidox_lvt }
   xnmosmhl4 { COPY dfm_nmosmh_lvt }
//
   xnmos { COPY dfm_nmos }
   xnmosm { COPY dfm_nmos_midox }
   xpmos { COPY dfm_pmos }
   xpmosm { COPY dfm_pmos_midox }
//
   xnmosrf { COPY dfm_nmosrf_device_layer }
   xpmosrf { COPY dfm_pmosrf_device_layer }
//
   xnmosl4 { COPY dfm_nmos_lvt }
   xnmosml4 { COPY dfm_nmos_mlvt   }
   xpmosl4 { COPY dfm_pmos_lvt }
   xpmosml4 { COPY dfm_pmos_mlvt }
//
#ENDIF

//=====================================================================
// EX 4  EX 4  EX 4  EX 4  EX 4  EX 4  EX 4  EX 4  EX 4  EX 4  EX 4  
//=====================================================================
// create layers to find capacitors (poly1-poly2 and cvar)

// poly1-poly2 (cpoly) capacitor

   dfm_cpoly_1          = dfm_routingpoly_all NOT HRES
   dfm_cpoly            = dfm_cpoly_1 AND dfm_poly2_cut
//
   dfm_cpoly_rf_device = RFDEF ENCLOSE dfm_cpoly
   dfm_cpoly_norf      = dfm_cpoly NOT RFDEF
//
#IFDEF DEVSWITCH
  xcpolyrf { COPY dfm_cpoly_rf_device }
  xcpoly   { COPY dfm_cpoly_norf }
#ENDIF
//
// cvar device is nmos transistor in nwell arranged in 2 dimensional array
// all diff and poly is connected by metal
//
// one device should be : w = 6.6 l = 0.65  col spacing 1.0 row spacing 1.6
//
// get device element
//
   dfm_cvar_ele_0 = (dfm_pgate AND NPLUS) NOT INTERACT dfm_nmosh 
//
// only small trans is ok, exact value is checked in element part
//
   dfm_cvar_ele   = INT dfm_cvar_ele_0 < 3 REGION
//
// this is unsupported device
//
   dfm_cvar_unsupp_device = dfm_cvar_ele_0 NOT dfm_cvar_ele
//
   CVAR_CAP_UNSUPPORTED_ELE { @ Device Warning : This ngate in nwell is extracted as single gate cap
                              @ Device Warning : unsupported device, no standard size
        COPY dfm_cvar_unsupp_device
   }
//
// get diff polygon and close gaps
   dfm_cvar_ndiff = dfm_ndiff_1 ENCLOSE dfm_cvar_ele
   dfm_cvar_ndiff_gap = EXT dfm_cvar_ndiff < 1.8 OPPOSITE PARA ONLY REGION
   dfm_cvar_ndiff_closed = dfm_cvar_ndiff OR dfm_cvar_ndiff_gap
// get poly/ndiff intersections
   dfm_cvar_ndiff_cross1 = INSIDE EDGE dfm_cvar_ndiff_closed (dfm_routingpoly_all INTERACT dfm_cvar_ele)
   dfm_cvar_ndiff_cross = EXPAND EDGE dfm_cvar_ndiff_cross1  INSIDE BY 0.1
// cvar_ndiff_cross { COPY cvar_ndiff_cross }

   dfm_cvar_device_layer = COPY dfm_cvar_ndiff_closed
//
// cvar must have RFDEF for assura RCX
// ok for CALIBRE LVS
//
   CVAR_OLD_VERSION_NO_RFDEF_ELE { @ Device Warning : old version of CVAR
                                   @ new version of CVAR must have RFDEF
                                   @ for correct parasitic extraction
     dfm_cvar_device_layer NOT RFDEF
   }
//
#IFDEF DEVSWITCH
   xcvar { COPY dfm_cvar_device_layer }
#ENDIF
//=====================================================================
// EX 5  EX 5  EX 5  EX 5  EX 5  EX 5  EX 5  EX 5  EX 5  EX 5  EX 5  
//=====================================================================
// create layers to find diodes
// attention : all diodes are created by AND !!!

// nd (ndiff over substrate, no sd of device)

   dfm_ndiode_1       = (dfm_ndiff NOT NTUB) NOT INTERACT dfm_trans
   dfm_ndiode         = dfm_ndiode_1 AND DIODE
//   ndiode           = dfm_ndiode_2 ENCLOSE dfm_ndiode_1

// pd (pdiff over nwell, no sd of device)

   dfm_pdiode_1       = (dfm_pdiff AND NTUB) NOT INTERACT dfm_trans
   dfm_pdiode         = dfm_pdiode_1 AND DIODE
//   pdiode       = pdiode_2 ENCLOSE pdiode_1

// nwd (nwell over substrate)

   dfm_nwdiode        = NTUB AND DIODE
//   nwdiode      = nwdiode_1 ENCLOSE NTUB
//
///////////////////////////////////////////////////////////////////////

// zdiode (ndiff interact pdiff not belonging to the same net)

   dfm_zdiode_1       = dfm_pdiff COINCIDENT OUTSIDE EDGE dfm_ndiff
   dfm_zdiode_2       = dfm_zdiode_1 EXPAND EDGE OUTSIDE BY 0.1
   dfm_zdiode_3       = dfm_pdiff AND dfm_ndiff
   dfm_zdiode_4       = dfm_zdiode_2 OR dfm_zdiode_3
   dfm_zdiode_5       = dfm_pdiff INTERACT dfm_zdiode_4
   dfm_zdiode_6       = dfm_ndiff INTERACT dfm_zdiode_4
   dfm_zdiode_7       = dfm_zdiode_5 OR dfm_zdiode_6
   dfm_zdiode_8       = dfm_zdiode_7 AND ZENER
   dfm_zdiode_9       = dfm_zdiode_8 ENCLOSE dfm_zdiode_7
   dfm_zdiode_all     = dfm_zdiode_4 AND dfm_zdiode_9

// this are all possibe z diodes, but we allow only 0.2 U ovlp
//
   dfm_zdiode_02_1 = INT dfm_zdiode_all == 0.2 OPPOSITE PARA ONLY REGION
   dfm_zdiode_02   = dfm_zdiode_all INTERACT dfm_zdiode_02_1
   dfm_zdiode = COPY dfm_zdiode_02_1
//
   ILL_ZDIODE_UNDEFINED_TPTXXX3 { @ Zener diode must have 0.2 implant ovlp
            dfm_zdiode_all NOT dfm_zdiode_02 
   }
//
#IFDEF DEVSWITCH
   xndiode  { COPY dfm_ndiode }
   xpdiode  { COPY dfm_pdiode }
   xnwdiode { COPY dfm_nwdiode }
   xzdiode  { COPY dfm_zdiode }
#ENDIF
//
// C35B4O1
// CMOS core. cap, 5 Volt, ARC = anti reflecting coating
// diode_phdnwa850 with ARC
// diode_phdnw850 no ARC
//
    dfm_diode_phdnwa850 = (NTUB AND dfm_ndiff) AND OPTDEF
//
#IFDEF DEVSWITCH
   xphdnwa850 { COPY dfm_diode_phdnwa850 }
#ENDIF
//
//=====================================================================
// create layers to separate n- and p-diffusion contacts

   dfm_ndiffcon       = dfm_ndiff_1 AND CONT
   dfm_pdiffcon       = dfm_pdiff_1 AND CONT

//=====================================================================
// create layers to separate test and probe pads (smaller 70*70 U)
// from bond pads - needed for drc
// 70 x 70 is still bondpad
//
   dfm_te_pro_pad       = PAD AREA < 4761
   dfm_bondpad          = PAD NOT dfm_te_pro_pad
//
//=====================================================================
// create layers needed to check length to width ratio of poly1, nwell
// and hrespoly resistors

// poly2 resistors

   dfm_pres_w           = dfm_pres COINCIDENT EDGE RESTRM
   dfm_pres_l           = dfm_pres NOT COINCIDENT EDGE RESTRM
   dfm_pres_wexp        = dfm_pres_w EXPAND EDGE OUTSIDE BY 0.1
   dfm_pres_lexp        = dfm_pres_l EXPAND EDGE OUTSIDE BY 0.1
   dfm_pres_exp         = SIZE dfm_pres BY 0.1
   dfm_pres_exp_net     = COPY    dfm_pres_exp
   CONNECT dfm_pres_exp_net 

// nwell resistors

   dfm_nwres_w          = dfm_nwres COINCIDENT EDGE RESTRM
   dfm_nwres_l          = dfm_nwres NOT COINCIDENT EDGE RESTRM
   dfm_nwres_wexp       = dfm_nwres_w EXPAND EDGE OUTSIDE BY 0.1
   dfm_nwres_lexp       = dfm_nwres_l EXPAND EDGE OUTSIDE BY 0.1
   dfm_nwres_exp        = SIZE dfm_nwres BY 0.1
   dfm_nwres_exp_net    = COPY    dfm_nwres_exp
   CONNECT dfm_nwres_exp_net

// hrespoly resistors

   dfm_presh_w          = dfm_presh COINCIDENT EDGE dfm_preshterm
   dfm_presh_l          = dfm_presh NOT COINCIDENT EDGE dfm_preshterm
   dfm_presh_wexp       = dfm_presh_w EXPAND EDGE OUTSIDE BY 0.1
   dfm_presh_lexp       = dfm_presh_l EXPAND EDGE OUTSIDE BY 0.1
   dfm_presh_exp        = SIZE dfm_presh BY 0.1
   dfm_presh_exp_net    = COPY    dfm_presh_exp
   CONNECT dfm_presh_exp_net


//=====================================================================
// create layers for slot rule checks

   dfm_met1_withslots  = MET1 NOT M1HOLE
   dfm_met2_withslots  = MET2 NOT M2HOLE
   dfm_met3_withslots  = MET3 NOT M3HOLE
#IFDEF fourmetal
   dfm_met4_withslots  = MET4 NOT M4HOLE
#ENDIF
//----------------------------------------------------------------------------------------
//
// RMET1
//
   rmet1_1 = dfm_met1_withslots AND METRES
   rmet1_trm =  ((SIZE rmet1_1 BY 0.1) NOT rmet1_1) AND dfm_met1_withslots
   rmet1_2 = RECTANGLE rmet1_1
   //rmet1_2 = RECTANGLE rmet1_1 ASPECT == 1
   RMET1_NO_SQUARE_INFO { @ Info : MET1 resistors (shorts) preferred to be square
      rmet1_1 NOT rmet1_2
   }
// does not cut met correctly
   RMET1_BAD_METRES_SHAPE { @ Error: MET1 bad resistors def layer
       rmet1_2 TOUCH rmet1_trm !=2
       NOT RECTANGLE rmet1_1
   }
   dfm_rmet1_device =  rmet1_2 TOUCH rmet1_trm ==2
//
// RMET2
//
   rmet2_1 = dfm_met2_withslots AND METRES
   rmet2_trm =  ((SIZE rmet2_1 BY 0.1) NOT rmet2_1) AND dfm_met2_withslots
   rmet2_2 = RECTANGLE rmet2_1
   //rmet2_2 = RECTANGLE rmet2_1 ASPECT == 1
   RMET2_NO_SQUARE_INFO { @ Info : MET2 resistors (shorts) preferred to be square
      rmet2_1 NOT rmet2_2
   }
// does not cut met correctly
   RMET2_BAD_METRES_SHAPE { @ Error: MET2 bad resistors def layer
       rmet2_2 TOUCH rmet2_trm !=2
       NOT RECTANGLE rmet2_1
   }
   dfm_rmet2_device =  rmet2_2 TOUCH rmet2_trm ==2
//
// RMET3
//
   rmet3_1 = dfm_met3_withslots AND METRES
   rmet3_trm =  ((SIZE rmet3_1 BY 0.1) NOT rmet3_1) AND dfm_met3_withslots
   rmet3_2 = RECTANGLE rmet3_1
   //rmet3_2 = RECTANGLE rmet3_1 ASPECT == 1
   RMET3_NO_SQUARE_INFO { @ Info : MET3 resistors (shorts) preferred to be square
      rmet3_1 NOT rmet3_2
   }
// does not cut met correctly
   RMET3_BAD_METRES_SHAPE { @ Error: MET3 bad resistors def layer
       rmet3_2 TOUCH rmet3_trm !=2
       NOT RECTANGLE rmet3_1
   }
   dfm_rmet3_device =  rmet3_2 TOUCH rmet3_trm ==2
//
#IFDEF fourmetal
//
// RMET4
//
   rmet4_1 = dfm_met4_withslots AND METRES
   rmet4_trm =  ((SIZE rmet4_1 BY 0.1) NOT rmet4_1) AND dfm_met4_withslots
   rmet4_2 = RECTANGLE rmet4_1
   //rmet4_2 = RECTANGLE rmet4_1 ASPECT == 1
   RMET4_NO_SQUARE_INFO { @ Info : MET4 resistors (shorts) preferred to be square
      rmet4_1 NOT rmet4_2
   }
// does not cut met correctly
   RMET4_BAD_METRES_SHAPE { @ Error: MET4 bad resistors def layer
       rmet4_2 TOUCH rmet4_trm !=2
       NOT RECTANGLE rmet4_1
   }
   dfm_rmet4_device =  rmet4_2 TOUCH rmet4_trm ==2
//
#IFDEF DEVSWITCH
   rmet4_device { COPY dfm_rmet4_device }
#ENDIF
#ENDIF
//
#IFDEF DEVSWITCH
   rmet1_device { COPY dfm_rmet1_device }
   rmet2_device { COPY dfm_rmet2_device }
   rmet3_device { COPY dfm_rmet3_device }
#ENDIF


//=====================================================================
//                        nmos30m/nmos30t
//=====================================================================
// ATTENTION : FIMP AND NLDD are NOT drawn on device
//             HVDEF and FIDEF on device
//             FIDEF is identical to FIMP generated in laygen
//
// device description : 2 sources, drain in center
// drain : isolated ndiff in nldd
// gate  : surrounds circular
// source for nmos30 : ndiff polygon building gate ndiff
// bulk : pdiff separated to drain diff
// substrate : any pdiff outside, not attached to device
//
   ndiff_nldd = COPY dfm_ndiff
   nmos30_1 = ( HOLES dfm_routingpoly_all INNER ) ENCLOSE ndiff_nldd
   nmos30_2 = routingpoly TOUCH nmos30_1
// gate intersects FIDEF
   nmos30_3 = ( ndev  INTERACT nmos30_2 ) CUT FIDEF
// extend gate to drain
//
   nmos30_ndiff = ndiff_nldd INSIDE nmos30_1
   nmos30_d_fill = EXT nmos30_ndiff nmos30_3 < 2.5 OPPOSITE PARA ONLY REGION
//
// check if drain found, this is the device
   nmos30_4 = ( nmos30_3 TOUCH nmos30_d_fill) OR nmos30_d_fill
   nmos30_combidiff = nmos30_4 OR (ndiff_nldd TOUCH nmos30_4)
// for l
//
   nmos30_fimp = FIDEF CUT nmos30_combidiff
   nmos30_gate_l = nmos30_3 NOT nmos30_fimp
//
// gate must be enclosed by midox/hvox !!
//
   nmos30_4g = nmos30_4 AND DIFF
   nmos30m  = nmos30_4 INTERACT (nmos30_4g INSIDE MIDOX)
   //nmos30t   = (nmos30_4 NOT nmos30h) NOT nmos30m
   nmos30t  = nmos30_4 NOT nmos30m
//
// use double device
// device layer is area between 2 sources !!!
//
   nmos30_drain    =  nmos30_ndiff TOUCH nmos30_4
   dfm_nmos30m_double  =  nmos30m OR (nmos30_drain TOUCH nmos30m)
   dfm_nmos30t_double  =  nmos30t  OR (nmos30_drain TOUCH nmos30t)
//
#IFDEF DEVSWITCH
   xnmos30m { COPY dfm_nmos30m_double }
   xnmos30t { COPY dfm_nmos30t_double }
#ENDIF

//=====================================================================
// create other layers needed for drc and connectivity

// for erc

   //p1_or_p2         = POLY1 OR POLY2
   //diff_or_poly     = DIFF OR p1_or_p2
   //implant          = NPLUS OR PPLUS


//=====================================================================
//=====================================================================
//                       Element rules cpoly
//=====================================================================
//
//  PPLUS on CPOLY is not allowed
   ILL_PPLUS_CPOLY_DFMA0018 { @ DFM0018 : PPLUS on CPOLY is not allowed
             PPLUS AND dfm_cpoly
   }
// NPLUS on CPOLY is not allowed
   ILL_NPLUS_CPOLY_DFMA0019 { @ DFM0019 : NPLUS on CPOLY is not allowed
             NPLUS AND dfm_cpoly
   }
//
//=====================================================================
//                       Element rules rpoly2
//=====================================================================
//
// RPOLY2: Recommended minimum number of squares L/W >= 5
// Minimum number of RPOLY2 squares = 5
   ILL_RPOLY2_RATIO_DFMA0038 {@ DFM0038 : Minimum number of RPOLY2 squares = 5
   dfm_pres_wexp_net    = STAMP dfm_pres_wexp BY dfm_pres_exp_net
   dfm_pres_lexp_net    = STAMP dfm_pres_lexp BY dfm_pres_exp_net
       NET AREA RATIO dfm_pres_lexp_net dfm_pres_wexp_net < 5
   }
//
// Minimum high precision RPOLYH width = 2
   WIDTH_RPOLY2_DFMA0039 {@ DFM0039  : Minimum high precision RPOLY2 width = 2
        INT dfm_pres < 2 SINGULAR REGION
   }
// DFM0040 already checked for rpoly2 without resdef
// DFM0041 
// next check needs resdef
//
// dummy poly2 must enclose rpoly2
//
   dfm_dummy_poly2_1 = (POLY2 NOT INTERACT dfm_cpoly) NOT (dfm_pres OR dfm_presh)
   //dfm_dummy_poly2 { FLATTEN dfm_dummy_poly2 }
//
// close notches in dummy poly2 to waive errors
//
   dfm_dummy_poly2_2 = EXT dfm_dummy_poly2_1 < 0.55 NOTCH REGION
   dfm_dummy_poly2   = dfm_dummy_poly2_1 OR dfm_dummy_poly2_2
//
   dfm_pres_all = POLY2 INTERACT dfm_pres
   dfm_pres_grow_area = dfm_substrate_all NOT dfm_dummy_poly2
   dfm_pres_1_a = SIZE dfm_pres_all BY 3.0 INSIDE OF dfm_pres_grow_area STEP 0.05
   //dfm_pres_1_a { FLATTEN dfm_pres_1_a }
   dfm_pres_2_a =  dfm_pres_1_a  NOT COINCIDENT OUTSIDE EDGE dfm_dummy_poly2
   //dfm_pres_2_a { FLATTEN dfm_pres_2_a }
   dfm_pres_3_a = dfm_pres_2_a EXPAND EDGE INSIDE BY 0.2
   SPAC_MAX_RPOLY2_DUMMY_DFMA0040_DFMA0041 { @ DFM0041 Maximum rpoly2 spacing to dummy poly2
                                             @ DFM0040 rpoly2 without enclosing dummy poly2 is not allowed
       COPY dfm_pres_3_a
   }

//=====================================================================
//                       Element rules rpolyh
//=====================================================================
//
// Minimum number of RPOLYH squares = 5
   ILL_RPOLYH_RATIO_DFMA0042 {@ DFM0042 : Minimum number of RPOLYH squares = 5
   dfm_presh_wexp_net   = STAMP dfm_presh_wexp BY dfm_presh_exp_net
   dfm_presh_lexp_net   = STAMP dfm_presh_lexp BY dfm_presh_exp_net
       NET AREA RATIO dfm_presh_lexp_net dfm_presh_wexp_net < 5
   }
//
// Minimum high precision RPOLYH width = 1
   WIDTH_RPOLYH_DFMA0043 {@ DFM0043  : Minimum high precision RPOLYH width = 2
        INT dfm_presh_1 < 2 SINGULAR REGION
   }
//
// DFM0044 already checked for narrow poly2
//
// dummy poly2 must enclose rpoly2
//
   dfm_presh_all = POLY2 INTERACT dfm_presh
   dfm_presh_grow_area = dfm_substrate_all NOT dfm_dummy_poly2
   dfm_presh_1_a = SIZE dfm_presh_all BY 3.0 INSIDE OF dfm_presh_grow_area STEP 0.05
   //dfm_presh_1_a { FLATTEN dfm_presh_1_a }
   dfm_presh_2_a =  dfm_presh_1_a  NOT COINCIDENT OUTSIDE EDGE dfm_dummy_poly2
   //dfm_presh_2_a { FLATTEN dfm_presh_2_a }
   dfm_presh_3_a = dfm_presh_2_a EXPAND EDGE INSIDE BY 0.2
   SPAC_MAX_RPOLYH_DUMMY_DFMA0044_DFMA0045 { @ DFM0044 Maximum rpolyh spacing to dummy poly2
                                             @ DFM0045 rpolyh without enclosing dummy poly2 is not allowed
       COPY dfm_presh_3_a
   }
//
//=====================================================================
//                       Element rules rnwell
//=====================================================================
//
// Minimum number of RNWELL squares = 5
// RNWELL: Recommended minimum number of squares L/W >=5
   ILL_RNWELL_RATIO_DFMA0036 {@ DFM0036 : RNWELL_G1 Minimum number of RNWELL squares = 5
   dfm_nwres_wexp_net   = STAMP dfm_nwres_wexp BY dfm_nwres_exp_net
   dfm_nwres_lexp_net   = STAMP dfm_nwres_lexp BY dfm_nwres_exp_net
       NET AREA RATIO dfm_nwres_lexp_net dfm_nwres_wexp_net < 5
   }
//
   WIDTH_RNWELL_DFMA0037 {@ DFM0037 : Minimum RNWELL width = 3
        INT dfm_nwres < 3 SINGULAR REGION
   }
//
//
//=====================================================================
//                     Latchup prevention 
//=====================================================================
//
   dfm_welltap          = dfm_ndiff AND dfm_routingnwell
   dfm_subtap           = dfm_pdiff NOT dfm_routingnwell
//
#IFDEF LATCHUP_CHECK_C35
//
// substrate taps
//
//   dfm_routingnwell  = ((dfm_ntub_subdefcut NOT dfm_nwres) NOT INDDEF) NOT HALLDEF    
//   dfm_trans            = dfm_diff_cut AND dfm_routingpoly_all
//   dfm_ngate            = dfm_trans NOT NTUB
//   dfm_pgate            = dfm_trans AND NTUB
//
// check for maximum substrate contact distance 50 U in nwell
//------------------------------------------------------------
// size welltaps by 25 U . If spacing of all taps was < 50
// only 1 sized tap should stay in nwell
//
   dfm_well_pgate = dfm_routingnwell INTERACT dfm_pgate
   dfm_welltap_final = SIZE dfm_welltap BY 25 INSIDE OF dfm_well_pgate STEP 2.5
//
// check, if more than 1 substrate island in well with distance > 50
// do not show taps, only gaps
//------------------------------------------------------------------
   SPAC_NTAP_IN_NWELL_GT50_LATCHUP_DFML0048 {@ DFM0048 :  distance well taps > 50  U
     x=dfm_well_pgate INTERACT dfm_welltap_final > 1
     x NOT dfm_welltap_final
     // x AND welltap
   }
//
// check for distance ngate to subtap > 20
//----------------------------------------
// Maximum distance from any point inside source/drain DIFF to the nearest TAP DIFF of the same NTUB or PSUB. = 20
    SPAC_SUBTAP_NDIFF_LATCHUP_DFML0046 {@ DFM0046 : distance s/d diff ngate subtap > 20
         @ Maximum distance from any point inside source/drain DIFF to the nearest TAP DIFF of the same NTUB or PSUB. = 20
        // subtap_ovs  = SIZE subtap BY 20.0 OUTSIDE OF routingnwell STEP 1.0
        dfm_subtap_ovs  = SIZE dfm_subtap BY 20.0
        x = ((dfm_ndiff INTERACT dfm_ngate) NOT ENCLOSE dfm_routingnwell) NOT INSIDE dfm_subtap_ovs
        x NOT dfm_subtap_ovs
    }
//
// check for distance pgate to welltap > 20
//------------------------------------------
// Maximum distance from any point inside source/drain DIFF to the nearest TAP DIFF of the same NTUB or PSUB. = 20
   SPAC_WELLTAP_PDIFF_LATCHUP_DFML0047 {@ DFM0047 : distance s/d diff pgate welltap > 20
         @ Maximum distance from any point inside source/drain DIFF to the nearest TAP DIFF of the same NTUB or PSUB. = 20
         dfm_welltap_ovs = SIZE dfm_welltap BY 20 INSIDE OF dfm_well_pgate STEP 1.0
         x = (dfm_pdiff INTERACT dfm_pgate) NOT INSIDE  dfm_welltap_ovs
         x NOT dfm_welltap_ovs
   }
#ENDIF
//////////////////////////////////////////////////////////////////////////////////////////
#IFDEF PROCESS_IS_H35XX
//
// for h35 check nmosi/pmosi also
// get also devices in rptub/dntub
//
   udfm_trans            = (DIFF AND POLY1) NOT HVDEF
   udfm_rptub            = DPTUB AND SPTUB
   udfm_ptub_for_trans   = (NTUB OR (DNTUB OR SNTUB)) NOT rptub
   udfm_ngate            = udfm_trans NOT udfm_ptub_for_trans
   udfm_pgate            = udfm_trans AND udfm_ptub_for_trans
//
   udfm_routingpwell = ( DPTUB OR SPTUB) NOT TUBDEF
   udfm_ntub_all     = ( NTUB OR DNTUB) OR SNTUB
   udfm_routingnwell = ntub_all NOT ( TUBDEF OR HALLDEF )
//
   udfm_pdiff_c_ptub = pdiff AND udfm_routingpwell
   udfm_ndiff_c_ntub = (ndiff AND udfm_routingnwell) NOT udfm_routingpwell
   udfm_pdiff_c_sub  = (pdiff NOT udfm_routingnwell) NOT udfm_routingpwell
//
// nwells
   udfm_welltap          = COPY udfm_ndiff_c_ntub
// pwell
   udfm_subtap           = udfm_pdiff_c_sub OR udfm_pdiff_c_ptub
//
// check for maximum substrate contact distance 50 U in nwell
//------------------------------------------------------------
// size welltaps by 25 U . If spacing of all taps was < 50
// only 1 sized tap should stay in nwell
//
   udfm_well_pgate = udfm_routingnwell INTERACT udfm_pgate
   udfm_welltap_final = SIZE udfm_welltap BY 25 INSIDE OF udfm_well_pgate STEP 2.5
//
// check, if more than 1 substrate island in well with distance > 50
// do not show taps, only gaps
//------------------------------------------------------------------
   SPAC_NTAP_IN_NWELL_GT50_LATCHUP_DFML0048 {@ DFM0048 :  distance well taps > 50  U
     x=udfm_well_pgate INTERACT udfm_welltap_final > 1
     x NOT udfm_welltap_final
     // x AND welltap
   }
//
// check for distance ngate to subtap > 20
//----------------------------------------
// Maximum distance from any point inside source/drain DIFF to the nearest TAP DIFF of the same NTUB or PSUB. = 20
    SPAC_SUBTAP_NDIFF_LATCHUP_DFML0046 {@ DFM0046 : distance s/d diff ngate subtap > 20
         @ Maximum distance from any point inside source/drain DIFF to the nearest TAP DIFF of the same NTUB or PSUB. = 20
        // subtap_ovs  = SIZE subtap BY 20.0 OUTSIDE OF routingnwell STEP 1.0
        udfm_subtap_ovs  = SIZE udfm_subtap BY 20.0
        x = ((ndiff INTERACT udfm_ngate) NOT ENCLOSE udfm_routingnwell) NOT INSIDE udfm_subtap_ovs
        x NOT udfm_subtap_ovs
    }
//
// check for distance pgate to welltap > 20
//------------------------------------------
// Maximum distance from any point inside source/drain DIFF to the nearest TAP DIFF of the same NTUB or PSUB. = 20
   SPAC_WELLTAP_PDIFF_LATCHUP_DFML0047 {@ DFM0047 : distance s/d diff pgate welltap > 20
         @ Maximum distance from any point inside source/drain DIFF to the nearest TAP DIFF of the same NTUB or PSUB. = 20
         udfm_welltap_ovs = SIZE udfm_welltap BY 20 INSIDE OF udfm_well_pgate STEP 1.0
         x = (pdiff INTERACT udfm_pgate) NOT INSIDE  udfm_welltap_ovs
         x NOT udfm_welltap_ovs
   }
#ENDIF
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//
// only c35 devices
//
#IFDEF PROCESS_IS_C35XX
//
//=====================================================================
//                    get statistic of devices
//=====================================================================

//  xrpoly2   { COPY pres_norf }
//  xrpoly2rf { COPY pres_rf_device }
//  xrpolyh { COPY presh_norf }
//  xrpolyhrf  { COPY presh_rf_device }
//  xrdiffp { COPY pdres }
//  xrdiffn { COPY ndres }
//  xrnwell { COPY nwres }
//
//   xpnplat    { COPY pnplat2_e }
//   xpnpvert10 { COPY pnpvert10 }
//   xnmosh { COPY nmosh_nomidox }
//   xnmosmh { COPY nmosmh }
//
//   xnmoshl4 { COPY nmosh_nomidox_lvt }
//   xnmosmhl4 { COPY nmosmh_lvt }
//
//   xnmos { COPY nmos }
//   xnmosm { COPY nmos_midox }
//   xpmos { COPY pmos }
//   xpmosm { COPY pmos_midox }
//
//   xnmosrf { COPY nmosrf_device_layer }
//   xpmosrf { COPY pmosrf_device_layer }
//
//   xnmosl4 { COPY nmos_lvt }
//   xnmosml4 { COPY nmos_mlvt   }
//   xpmosl4 { COPY pmos_lvt }
//   xpmosml4 { COPY pmos_mlvt }
//
//  xcpolyrf { COPY cpoly_rf_device }
//  xcpoly   { COPY cpoly_norf }
//  xcvar { COPY cvar_device_layer }   xndiode  { COPY ndiode }
//  xpdiode  { COPY pdiode }
//  xnwdiode { COPY nwdiode }
//  xzdiode  { COPY zdiode }
//
#IFDEF fourmetal 
  INFO_DEV_RMET4   { @ INFO : rmet4 
    COPY dfm_rmet4_device
  }
#ENDIF
  INFO_DEV_RMET1   { @ INFO : rmet1 
    COPY dfm_rmet1_device
  }
  INFO_DEV_RMET2   { @ INFO : rmet2 
    COPY dfm_rmet2_device
  }
  INFO_DEV_RMET3   { @ INFO : rmet3 
    COPY dfm_rmet3_device
  }
  INFO_DEV_RPOLY1  { @ INFO : rpoly1  
     COPY dfm_pres1
  }
  INFO_DEV_RPOLY2  { @ INFO : rpoly2  
     COPY dfm_pres_norf
  }
  INFO_DEV_RPOLY2RF{ @ INFO : rpoly2rf  
     COPY dfm_pres_rf_device
  }
  INFO_DEV_RPOLYH  { @ INFO : rpolyh  
     COPY dfm_presh_norf
  }
  INFO_DEV_RPOLYHRF  { @ INFO : rpolyhrf  
     COPY dfm_presh_rf_device
  }
  INFO_DEV_RDIFFP  { @ INFO : rdiffp  
     COPY dfm_pdres
  }
  INFO_DEV_RDIFFN  { @ INFO : rdiffn  
     COPY dfm_ndres
  }
  INFO_DEV_RNWELL  { @ INFO : rnwell  
     COPY dfm_nwres
  }
//---------------------------------------------
  INFO_DEV_PNPLAT  { @ INFO : pnplat  
     COPY dfm_pnplat2_e
  }
  INFO_DEV_PNPVERT10  { @ INFO : pnpvert10  
     COPY dfm_pnpvert10
  }
  INFO_DEV_CPOLY  { @ INFO : cpoly  
     COPY dfm_cpoly
  }
  INFO_DEV_NDIODE  { @ INFO : ndiode  
     COPY dfm_ndiode
  }
  INFO_DEV_PDIODE  { @ INFO : pdiode  
     COPY dfm_pdiode
  }
  INFO_DEV_NWDIODE  { @ INFO : nwdiode  
     COPY dfm_nwdiode
  }
  INFO_DEV_ZDIODE  { @ INFO : zdiode  
     COPY dfm_zdiode
  }
  INFO_DEV_PHDNWA850 { @ INFO : phdnwa850
    COPY dfm_diode_phdnwa850 
  }
//--------------------------------------------------
  INFO_DEV_NMOSH  { @ INFO : nmosh  
     COPY dfm_nmosh_nomidox
  }
  INFO_DEV_NMOSMH  { @ INFO : nmosmh  
     COPY dfm_nmosmh
  }
  INFO_DEV_NMOSHL4 { @ INFO : nmoshl4  
     COPY dfm_nmosh_nomidox_lvt
  }
  INFO_DEV_NMOSMHL4  { @ INFO : nmosmhl4  
     COPY dfm_nmosmh_lvt
  }
  INFO_DEV_NMOS30T { @ INFO : nmos30t   
     COPY dfm_nmos30t_double 
  }
  INFO_DEV_NMOS30M { @ INFO : nmos30m   
     COPY dfm_nmos30m_double 
  }
//-----------------------------------------------
   INFO_DEV_NMOS { @ INFO : nmos
    x = COPY dfm_nmos
    COPY x
   }
   INFO_DEV_NMOSM { @ INFO : nmosm
    x = COPY dfm_nmos_midox
    COPY x
   }
   INFO_DEV_NMOSRF { @ INFO : nmosrf
    x = COPY dfm_nmosrf_device_layer
    COPY x
   }
   INFO_DEV_NMOSL4 { @ INFO : nmosl4
    x = COPY dfm_nmos_lvt  
    COPY x
   }
   INFO_DEV_NMOSML4 { @ INFO : nmosml4
    x = COPY dfm_nmos_mlvt  
    COPY x
   }
//---------
   INFO_DEV_PMOS { @ INFO : pmos
    x = COPY dfm_pmos
    COPY x
   }
   INFO_DEV_PMOSM { @ INFO : pmosm
    x = COPY dfm_pmos_midox
    COPY x
   }
   INFO_DEV_PMOSRF { @ INFO : pmosrf
    x = COPY dfm_pmosrf_device_layer
    COPY x
   }
   INFO_DEV_PMOSL4 { @ INFO : pmosl4
    x = COPY dfm_pmos_lvt   
    COPY x
   }
   INFO_DEV_PMOSML4 { @ INFO : pmosml4
    x = COPY dfm_pmos_mlvt   
    COPY x
   }
//-------------
  INFO_DEV_SPIRAL  { @ INFO : spiral  
     COPY INDDEF       
  }
  INFO_DEV_METCAP  { @ INFO : metcap  
     COPY METCAP       
  }
#ENDIF
//
#IFDEF GET_AREAS  
//=====================================================================
//            get areas and ratios for all layers
//=====================================================================
   die_size  = EXTENT
   die_size_dummy { die_size OUTSIDE (SIZE die_size BY 1) }
   DRC PRINT AREA die_size
//
   INFO_DENS_NTUB {@ Density 
      DENSITY NTUB < 1.1 PRINT ONLY ratio_ntub_die.txt
   }
   ntub_dummy { NTUB OUTSIDE die_size }
   DRC PRINT AREA NTUB
//
//
   INFO_DENS_DIFF {@ Density 
      DENSITY DIFF < 1.1 PRINT ONLY ratio_diff_die.txt
   }
   diff_dummy { DIFF OUTSIDE die_size }
   DRC PRINT AREA DIFF
//
//
   INFO_DENS_MIDOX {@ Density 
      DENSITY MIDOX < 1.1 PRINT ONLY ratio_midox_die.txt
   }
   midox_dummy { MIDOX OUTSIDE die_size }
   DRC PRINT AREA MIDOX
//
//
   INFO_DENS_POLY1 {@ Density 
      DENSITY POLY1 < 1.1 PRINT ONLY ratio_poly1_die.txt
   }
   poly1_dummy { POLY1 OUTSIDE die_size }
   DRC PRINT AREA POLY1
//
//
   INFO_DENS_NPLUS {@ Density 
      DENSITY NPLUS < 1.1 PRINT ONLY ratio_nplus_die.txt
   }
   nplus_dummy { NPLUS OUTSIDE die_size }
   DRC PRINT AREA NPLUS
//
//
   INFO_DENS_PPLUS {@ Density 
      DENSITY PPLUS < 1.1 PRINT ONLY ratio_pplus_die.txt
   }
   pplus_dummy { PPLUS OUTSIDE die_size }
   DRC PRINT AREA PPLUS
//
//
   INFO_DENS_POLY2 {@ Density 
      DENSITY POLY2 < 1.1 PRINT ONLY ratio_poly2_die.txt
   }
   poly2_dummy { POLY2 OUTSIDE die_size }
   DRC PRINT AREA POLY2
//
//
   INFO_DENS_CONT {@ Density 
      DENSITY CONT < 1.1 PRINT ONLY ratio_cont_die.txt
   }
   cont_dummy { CONT OUTSIDE die_size }
   DRC PRINT AREA CONT
//
//
   INFO_DENS_MET1 {@ Density 
      DENSITY MET1 < 1.1 PRINT ONLY ratio_met1_die.txt
   }
   met1_dummy { MET1 OUTSIDE die_size }
   DRC PRINT AREA MET1
//
//
   INFO_DENS_VIA {@ Density 
      DENSITY VIA < 1.1 PRINT ONLY ratio_via_die.txt
   }
   via_dummy { VIA OUTSIDE die_size }
   DRC PRINT AREA VIA
//
//
   INFO_DENS_MET2 {@ Density 
      DENSITY MET2 < 1.1 PRINT ONLY ratio_met2_die.txt
   }
   met2_dummy { MET2 OUTSIDE die_size }
   DRC PRINT AREA MET2
//
//
   INFO_DENS_VIA2 {@ Density 
      DENSITY VIA2 < 1.1 PRINT ONLY ratio_via2_die.txt
   }
   via2_dummy { VIA2 OUTSIDE die_size }
   DRC PRINT AREA VIA2
//
//
   INFO_DENS_MET3 {@ Density 
      DENSITY MET3 < 1.1 PRINT ONLY ratio_met3_die.txt
   }
   met3_dummy { MET3 OUTSIDE die_size }
   DRC PRINT AREA MET3
//
//
   INFO_DENS_PAD {@ Density 
      DENSITY PAD < 1.1 PRINT ONLY ratio_pad_die.txt
   }
   pad_dummy { PAD OUTSIDE die_size }
   DRC PRINT AREA PAD
//
//
   INFO_DENS_VIA3 {@ Density 
      DENSITY VIA3 < 1.1 PRINT ONLY ratio_via3_die.txt
   }
   via3_dummy { VIA3 OUTSIDE die_size }
   DRC PRINT AREA VIA3
//
//
   INFO_DENS_MET4 {@ Density 
      DENSITY MET4 < 1.1 PRINT ONLY ratio_met4_die.txt
   }
   met4_dummy { MET4 OUTSIDE die_size }
   DRC PRINT AREA MET4
//
//
//   INFO_DENS_BNTUB {@ Density 
//      DENSITY BNTUB < 1.1 PRINT ONLY ratio_bntub_die.txt
//   }
//   bntub_dummy { BNTUB OUTSIDE die_size }
//   DRC PRINT AREA BNTUB
//
//
//   INFO_DENS_BPOLY {@ Density 
//      DENSITY BPOLY < 1.1 PRINT ONLY ratio_bpoly_die.txt
//   }
//   bpoly_dummy { BPOLY OUTSIDE die_size }
//   DRC PRINT AREA BPOLY
//
//
//   INFO_DENS_EMITT {@ Density 
//      DENSITY EMITT < 1.1 PRINT ONLY ratio_emitt_die.txt
//   }
//   emitt_dummy { EMITT OUTSIDE die_size }
//   DRC PRINT AREA EMITT
//
//
//   INFO_DENS_COLL {@ Density 
//      DENSITY COLL < 1.1 PRINT ONLY ratio_coll_die.txt
//   }
//   coll_dummy { COLL OUTSIDE die_size }
//   DRC PRINT AREA COLL
//
#ENDIF
///////////////////////////////////////////////////////////////////////
//
//               end of c35 device recognition
//
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//
//                       DFM part2 checks
//
///////////////////////////////////////////////////////////////////////
//
//  CMOS C35 DFM rules  Document: ENG-301               Revision: REV 3
//
///////////////////////////////////////////////////////////////////////
//=====================================================================
//   Version          Date           by       Description
//---------------------------------------------------------------------
//    2.0          30-Jun-2008     aob    general update
//---------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////
// contains : - check for chip areas without transistors 
//            - analog gates with critical w/l
//            - nldd50 implant small W
//
///////////////////////////////////////////////////////////////////////

//=====================================================================
//         check for areas on chip without trans
//=====================================================================
//
// this is not finished, needs more testing
//
// I think this is better than a simple oversizing of trans
// get detailed boundrary near cells and then I do
// density checks again with with minor accuracy
// on the bounding shapes
//
// create boundrary
   trans1 = DIFF AND POLY1
   dens_out_trans2 = DENSITY trans1 == 0  WINDOW 10.0  STEP 1.0
   dens_in_trans2  = DENSITY trans1 > 0.01  WINDOW 5.0  STEP 1.0
   //dens_out_trans2 { FLATTEN dens_out_trans2 }
   //dens_in_trans2  { FLATTEN dens_in_trans2 }
   dens_out_trans2_x = dens_out_trans2 AND dens_in_trans2
// close gap
   dens_trans2_ring = SIZE dens_out_trans2_x BY 8.0 OVERUNDER
   //dens_trans2_ring { FLATTEN dens_trans2_ring }
// fill inside
   dens_trans2_ring_holes = (HOLES dens_trans2_ring INNER) OR dens_out_trans2_x
//
// create boundrary
   trans2 = COPY dens_trans2_ring_holes
   dens_out_trans3 = DENSITY trans2 == 0  WINDOW 50.0  STEP 5.0
   dens_in_trans3  = DENSITY trans2 > 0.01  WINDOW 25.0  STEP 5.0
   //dens_out_trans3 { FLATTEN dens_out_trans3 }
   //dens_in_trans3  { FLATTEN dens_in_trans3 }
   dens_out_trans3_x =  dens_out_trans3 AND dens_in_trans3
   dens_trans3_ring = (SIZE dens_out_trans3_x BY 10.0 OVERUNDER) OR dens_out_trans3_x
   //dens_trans3_ring { FLATTEN dens_trans3_ring }
//
// create ring at chip extent
   dens_all = EXTENT
   dens_all_ring = dens_all NOT (SIZE dens_all BY -20)
   dens_no_trans = dens_trans3_ring OR dens_all_ring
   //dens_no_trans { COPY dens_no_trans }
//
   dens_all_1 = dens_all NOT dens_no_trans
   dens_all_2 = DENSITY trans1 == 0 WINDOW 50 STEP 5.0 INSIDE OF LAYER dens_all_1
   no_trans_area_dfm = dens_all_2 NOT dens_all_ring
   INFO_LOW_TRANS_DENSITY_DFM { @ INFO : in this area of chip density of gate is low or 0 
                                @        gate oxid inhomogenity 
       FLATTEN no_trans_area_dfm 
   }
//
   DRC PRINT AREA no_trans_area_dfm
//
   dens_check = dens_all_2 AND trans1
   //dens_check { COPY dens_check }
// create ratio report
   INFO_NO_TRANS_AREA1_DFM { @ INFO : in this area is no transistor
      DENSITY (dens_all NOT dens_all_2 ) < 1 PRINT ONLY ratio_transgroups_die.txt
   }
//
//=====================================================================
//           find analogue and digital devices
//=====================================================================
//
   dfm_ngate_w = ngate COINCIDENT INSIDE EDGE POLY1
   dfm_pgate_w = pgate COINCIDENT INSIDE EDGE POLY1
   dfm_ngate_l = ngate COINCIDENT INSIDE EDGE DIFF 
   dfm_pgate_l = pgate COINCIDENT INSIDE EDGE DIFF 
//
// get total length of w
//-----------------------
//
   dfm_ngate_w_expand = dfm_ngate_w  EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL
   dfm_pgate_w_expand = dfm_pgate_w  EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL
   dfm_gate_w_total  = dfm_ngate_w_expand OR dfm_pgate_w_expand
//
// dummy DRC
//
   gate_w_total  { dfm_gate_w_total  OUTSIDE dfm_substrate_all }
   ngate_w_expand { dfm_ngate_w_expand  OUTSIDE dfm_substrate_all }
   pgate_w_expand { dfm_pgate_w_expand  OUTSIDE dfm_substrate_all }
   DRC PRINT AREA dfm_gate_w_total
   DRC PRINT AREA dfm_ngate_w_expand
   DRC PRINT AREA dfm_pgate_w_expand
//
// total area of s/d diff
//-------------------------
//
   dfm_ndiff_sd = dfm_ndiff INTERACT  dfm_ngate_w_expand
   dfm_pdiff_sd = dfm_pdiff INTERACT  dfm_pgate_w_expand
   dfm_diff_sd_total = ndiff_sd OR pdiff_sd
   diff_sd_total { dfm_diff_sd_total OUTSIDE dfm_substrate_all }
   DRC PRINT AREA dfm_diff_sd_total
//
//=====================================================================
//             min L and W check for analogue devices
//=====================================================================
//
// get one shape in case of 45 angle
//
//   WIDTH_NMOS_CRITICAL { ( PATH LENGTH ngate_w < 1.0 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL }
//   WIDTH_PMOS_CRITICAL { ( PATH LENGTH pgate_w < 1.0 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL }
//
//   INFO_LENGTH_NMOS_GT_035 { ( PATH LENGTH dfm_ngate_l > 0.35 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL }
//   INFO_LENGTH_PMOS_GT_035 { ( PATH LENGTH dfm_pgate_l > 0.35 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL }
//
//   INFO_LENGTH_NMOS_GT_035_LT_050 { ( PATH LENGTH dfm_ngate_l > 0.35 < 0.50 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL }
//   INFO_LENGTH_PMOS_GT_035_LT_050 { ( PATH LENGTH dfm_pgate_l > 0.35 < 0.50 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL }
//
//   INFO_LENGTH_NMOS_GT_050 { @ INFO : Analog nmos transistor
//            ( PATH LENGTH dfm_ngate_l > 0.50 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL
//   }
//
//   INFO_LENGTH_PMOS_GT_050 { @ INFO :  Analog pmos transistor
//            ( PATH LENGTH dfm_pgate_l > 0.50 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL
//   }
//
// poly1 connecting digital gates
//
//   xdfm_routp_eq035_digit { COPY xdfm_routp_eq035_digit }
//   xdfm_routp_meq05_digit { COPY xdfm_routp_meq05_digit }
//
// filter gates if digital cells
// 
//   xdfm_routp_gt035lt07_digit { COPY xdfm_routp_gt035lt07_digit }
//   xdfm_routp_mgt050lt07_digit { COPY xdfm_routp_mgt050lt07_digit }
//
//
// filter pad trans for this L check
//
// 70 x 70 is still bondpad
//
   te_pro_pad       = PAD AREA < 4761
   bondpad          = PAD NOT te_pro_pad
// filter gcnmos/gcpmos driver
   padovs_filter    = SIZE bondpad BY 50 
// 
// element checks devices
//--------------------------
//
// flag L between min and min analog 
// if L = analog check for min w
//
// nmos/pmos
//
   dfm_nmos_l = dfm_nmos COINCIDENT INSIDE EDGE DIFF 
   dfm_pmos_l = dfm_pmos COINCIDENT INSIDE EDGE DIFF 
   //dfm_pmos_w = dfm_pmos COINCIDENT INSIDE EDGE POLY1 
   //dfm_nmos_w = dfm_nmos COINCIDENT INSIDE EDGE POLY1 
   LENGTH_NMOS_GT_035_LT_070_DFMA0020 { @ DFM0020 NMOS Minimum channel length ( analog) 0.7 U
        x = ( PATH LENGTH dfm_nmos_l > 0.35 < 0.70 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL  
        y = dfm_nmos INTERACT x
        z = y NOT xdfm_routp_gt035lt07_digit
        z NOT INTERACT padovs_filter
   }
//
// check for w if L >= 0.7
//
   WIDTH_NMOS_ANALOG_DFMA0021 { @ DFM0021 NMOS Minimum channel width ( analog) L > 0.7 U  is 0.5 U
        x = ( PATH LENGTH dfm_nmos_l >= 0.7 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL  
        dfm_nmos_w = (dfm_nmos INTERACT x) COINCIDENT INSIDE EDGE POLY1
        (PATH LENGTH dfm_nmos_w < 0.5 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL  
   }
//
   LENGTH_PMOS_GT_035_LT_070_DFMA0028 { @ DFM0028 PMOS Minimum channel length ( analog) 0.7 U
        x = ( PATH LENGTH dfm_pmos_l > 0.35 < 0.70 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL  
        y = dfm_pmos INTERACT x
        z = y NOT xdfm_routp_gt035lt07_digit
        z NOT INTERACT padovs_filter
   }
//
// check for w if L >= 0.7
//
   WIDTH_PMOS_ANALOG_DFMA0029 { @ DFM0029 PMOS Minimum channel width ( analog) L > 0.7 U  is 0.5 U
        x = ( PATH LENGTH dfm_pmos_l >= 0.7 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL  
        dfm_pmos_w = (dfm_pmos INTERACT x) COINCIDENT INSIDE EDGE POLY1
        (PATH LENGTH dfm_pmos_w < 0.5 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL  
   }
//---------------------------------
//
// nmosl/pmosl
//
   dfm_nmosl_l = dfm_nmos_lvt COINCIDENT INSIDE EDGE DIFF 
   dfm_pmosl_l = dfm_pmos_lvt COINCIDENT INSIDE EDGE DIFF 
   LENGTH_NMOSL_GT_035_LT_070_DFMA0022 { @ DFM0022 NMOSL Minimum channel length ( analog) 0.7 U
        x = ( PATH LENGTH dfm_nmosl_l > 0.35 < 0.70 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL  
        y = dfm_nmos_lvt INTERACT x
        y NOT xdfm_routp_gt035lt07_digit
   }
//
// check for w if L >= 0.7
//
   WIDTH_NMOSL_ANALOG_DFMA0023 { @ DFM0023 NMOS Minimum channel width ( analog) L > 0.7 U  is 0.5 U
        x = ( PATH LENGTH dfm_nmosl_l >= 0.7 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL  
        dfm_nmosl_w = (dfm_nmos_lvt INTERACT x) COINCIDENT INSIDE EDGE POLY1
        (PATH LENGTH dfm_nmosl_w < 0.5 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL  
   }
   LENGTH_PMOSL_GT_035_LT_070_DFMA0030 { @ DFM0030 PMOSL Minimum channel length ( analog) 0.7 U
        x = ( PATH LENGTH dfm_pmosl_l > 0.35 < 0.70 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL  
        y = dfm_pmos_lvt INTERACT x
        y NOT xdfm_routp_gt035lt07_digit
   }
//
// check for w if L >= 0.7
//
   WIDTH_PMOSL_ANALOG_DFMA0031 { @ DFM0031 PMOS Minimum channel width ( analog) L > 0.7 U  is 0.5 U
        x = ( PATH LENGTH dfm_pmosl_l >= 0.7 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL  
        dfm_pmosl_w = (dfm_pmos_lvt INTERACT x) COINCIDENT INSIDE EDGE POLY1
        (PATH LENGTH dfm_pmosl_w < 0.5 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL  
   }
//
//---------------------------------
//
// nmosm/pmosm
//
   dfm_nmosm_l = dfm_nmos_midox COINCIDENT INSIDE EDGE DIFF 
   dfm_pmosm_l = dfm_pmos_midox COINCIDENT INSIDE EDGE DIFF 
//
// min L is 0.5, filter == 0.5
// 0.5 is error , but not in digital cells
//
   LENGTH_NMOSM_GT_035_LT_1_DFMA0024 { @ DFM0024 NMOSM Minimum channel length ( analog) 1.0 U
        x = ( PATH LENGTH dfm_nmosm_l > 0.35 < 1.0 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL  
        y = dfm_nmos_midox INTERACT x
        z = y NOT (xdfm_routp_mgt050lt07_digit OR xdfm_routp_meq05_digit)
        z NOT INTERACT padovs_filter
   }
//
// check for w if L >= 0.75
//
   WIDTH_NMOSM_ANALOG_DFMA0025 { @ DFM0025 NMOS Minimum channel width ( analog) L > 1.0  U  is 0.5 U
        x = ( PATH LENGTH dfm_nmosm_l >= 1.0  ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL  
        dfm_nmosm_w = (dfm_nmos_midox INTERACT x) COINCIDENT INSIDE EDGE POLY1
        (PATH LENGTH dfm_nmosm_w < 0.5 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL  
   }
   LENGTH_PMOSM_GT_035_LT_075_DFMA0032 { @ DFM0032 PMOSM Minimum channel length ( analog) L > 0.75 U
        x = ( PATH LENGTH dfm_pmosm_l > 0.35 < 0.75 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL  
        y = dfm_pmos_midox INTERACT x
        z = y NOT (xdfm_routp_mgt050lt07_digit OR xdfm_routp_meq05_digit)
        z NOT INTERACT padovs_filter
   }
//
// check for w if L >= 0.75
//
   WIDTH_PMOSM_ANALOG_DFMA0033 { @ DFM0033 PMOS Minimum channel width ( analog) L > 0.75 U  is 0.5 U
        x = ( PATH LENGTH dfm_pmosm_l >= 0.75 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL  
        dfm_pmosl_w = (dfm_pmos_midox INTERACT x) COINCIDENT INSIDE EDGE POLY1
        (PATH LENGTH dfm_pmosl_w < 0.5 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL  
   }
//
//---------------------------------
// nmosml/pmosml
//
   dfm_nmosml_l = dfm_nmos_mlvt COINCIDENT INSIDE EDGE DIFF 
   dfm_pmosml_l = dfm_pmos_mlvt COINCIDENT INSIDE EDGE DIFF 
   LENGTH_NMOSML_GT_035_LT_1_DFMA0026 { @ DFM0026 NMOSML Minimum channel length ( analog) 1.0 U
        x = ( PATH LENGTH dfm_nmosml_l > 0.35 < 1.0 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL  
        y = dfm_nmos_mlvt INTERACT x
        y NOT (xdfm_routp_mgt050lt07_digit OR xdfm_routp_meq05_digit)
   }
//
// check for w if L >= 0.75
//
   WIDTH_NMOSML_ANALOG_DFMA0027 { @ DFM0027 NMOS Minimum channel width ( analog) L > 1.0 U  is 0.5 U
        x = ( PATH LENGTH dfm_nmosml_l >= 1.0  ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL  
        dfm_nmosml_w = (dfm_nmos_mlvt  INTERACT x) COINCIDENT INSIDE EDGE POLY1
        (PATH LENGTH dfm_nmosml_w < 0.5 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL  
   }
   LENGTH_PMOSML_GT_035_LT_075_DFMA0034 { @ DFM0034 PMOSML Minimum channel length ( analog) 0.75 U
        x = ( PATH LENGTH dfm_pmosml_l > 0.35 < 0.75 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL  
        y = dfm_pmos_mlvt INTERACT x
        y NOT (xdfm_routp_mgt050lt07_digit OR xdfm_routp_meq05_digit)
   }
//
// check for w if L >= 0.75
//
   WIDTH_PMOSML_ANALOG_DFMA0035 { @ DFM0035 PMOSML Minimum channel width ( analog) L > 0.75 U  is 0.5 U
        x = ( PATH LENGTH dfm_pmosml_l >= 0.75 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL  
        dfm_pmosml_w = (dfm_pmos_mlvt INTERACT x) COINCIDENT INSIDE EDGE POLY1
        (PATH LENGTH dfm_pmosml_w < 0.5 ) EXPAND EDGE OUTSIDE BY 0.1 CORNER FILL  
   }
//
//---------------------------------
//
//   xnmos { COPY nmos }
//   xnmosm { COPY nmos_midox }
//   xpmos { COPY pmos }
//   xpmosm { COPY pmos_midox }
//
//   xnmosrf { COPY nmosrf_device_layer }
//   xpmosrf { COPY pmosrf_device_layer }
//
//   xnmosl4 { COPY nmos_lvt }
//   xnmosml4 { COPY nmos_mlvt   }
//   xpmosl4 { COPY pmos_lvt }
//   xpmosml4 { COPY pmos_mlvt }
//
//=====================================================================
// DFM0009/DFM0010/DFM0013  check for gate/via ratios             
//=====================================================================
//
//   trans            = DIFF AND POLY1
//   poly1_n_poly2    = POLY1 NOT POLY2
//   poly1con         = CONT AND poly1_n_poly2
//   con_n_p1         = CONT NOT poly1con
//   poly2con         = CONT AND POLY2
//
   DISCONNECT
//
// without connect
//
// m1m2_common = (MET1 AND MET2) NOT OUTSIDE VIA1
//
//
// any met1/diff contact (= diode)
   sdcont =  MET1 AND (CONT AND diff_cut)
// poly1/poly2 conts
   cont_p1 = CONT NOT poly2_cut
   cont_p2 = CONT AND poly2_cut
//
// get all gates
//
   diff_cut  = DIFF NOT DIFCUT
   poly1_cut = POLY1 NOT PO1CUT
   poly2_cut = POLY2 NOT PO2CUT
//
   gates_all = poly1_cut AND diff_cut
//
   gate_poly1 = COPY  poly1_cut
   gate_met1  = COPY MET1
   gates_great_5000 = COPY gates_all
   gate_met1_via_1 = COPY VIA
//
   CONNECT gate_poly1 gates_great_5000
   CONNECT gate_poly1 gate_met1 BY cont_p1
   CONNECT sdcont gate_met1
   CONNECT gate_met1 gate_met1_via_1
//
//
   RATIO_GATE_VIA_INSUFFICIENT_DFMC0009 { @ DFM0009 gate gt 5000 connected with insufficient  via
        gates_great_5000_nosd = NET AREA RATIO gates_great_5000 sdcont == 0
        x = NET AREA RATIO gates_great_5000_nosd gate_met1_via_1 > 20000                            
        via_count = NET AREA RATIO gate_met1_via_1 x > 0
        via_count_net = STAMP via_count BY gate_met1_via_1
        xx = NET AREA RATIO x                     via_count_net   > 20000  ACCUMULATE
        NET AREA RATIO PRINT xx 'ratio_gate_via1_insufficient.txt'
        gate_poly1_2  =  NET AREA RATIO gate_poly1 gate_met1 via_count_net > 0
        gate_met1_2   =  NET AREA RATIO gate_met1 gate_poly1 via_count_net > 0
        ORNET gate_poly1_2 gate_met1_2
        // for testing
        NET AREA RATIO gate_met1_2 gate_poly1_2 via_count_net > 0
                 [COUNT(via_count_net) + AREA(gate_poly1_2) + AREA(gate_met1_2)]
        RDB ONLY 'via_gate.rdb' gate_met1_2 gate_poly1_2 via_count_net
   }
//
// connect
//
   DISCONNECT
   met1_all = COPY MET1
   met2_all = COPY MET2
   gate_met2_via2_1 = COPY VIA2
   via_all = COPY VIA
//
   CONNECT gates_great_5000 gate_poly1
   CONNECT gate_poly1 met1_all      BY cont_p1
   CONNECT met1_all   sdcont
   CONNECT met2_all   met1_all      BY via_all
   CONNECT met2_all   gate_met2_via2_1
//
    RATIO_GATE_VIA2_INSUFFICIENT_DFMC0012 { @ DFM0012 : gate gt 5000 connected with insufficient via2
        gates_great_5000_nosd = NET AREA RATIO gates_great_5000 sdcont == 0
        x = NET AREA RATIO gates_great_5000_nosd gate_met2_via2_1  > 20000                              
        via_count = NET AREA RATIO gate_met2_via2_1  x > 0
        via_count_net = STAMP via_count BY gate_met2_via2_1
        xx = NET AREA RATIO x                     via_count_net   > 20000   ACCUMULATE
        NET AREA RATIO PRINT xx 'ratio_gate_via2_insufficient.txt'
        gate_poly1_2  =  NET AREA RATIO gate_poly1 met1_all met2_all via_count_net > 0
        gate_met1_2   =  NET AREA RATIO met1_all gate_poly1 met2_all via_count_net > 0
        gate_met2_2   =  NET AREA RATIO met2_all met1_all gate_poly1 via_count_net > 0
        (ORNET gate_poly1_2 gate_met1_2) ORNET gate_met2_2
        // for testing
        NET AREA RATIO gate_met2_2 gate_met1_2 gate_poly1_2 via_count_net > 0
              [COUNT(via_count_net) + AREA(gate_poly1_2) + AREA(gate_met1_2)+ AREA(gate_met2_2)]
        RDB ONLY 'via_gate.rdb' gate_met2_2 gate_met1_2 gate_poly1_2 via_count_net
   }
//
#IFDEF fourmetal
//
   DISCONNECT
//
// do NOT connect met4, only via3
   met3_all = COPY MET3
   gate_met3_via3_1 = COPY VIA3 
   via2_all = COPY VIA2
//
   CONNECT gates_great_5000 gate_poly1
   CONNECT gate_poly1 met1_all BY cont_p1
   CONNECT met1_all  sdcont
   CONNECT met2_all  met1_all  BY via_all
   CONNECT met3_all  met2_all  BY via2_all
   CONNECT met3_all  gate_met3_via3_1
//
   RATIO_GATE_VIA3_INSUFFICIENT_DFMC0015 { @ DFM0015 : gate gt 5000 connected with insufficient via3
        // only net without diff
        gates_great_5000_nosd = NET AREA RATIO gates_great_5000 sdcont == 0
        // get via3 on net ( can be count)
        x = NET AREA RATIO gates_great_5000_nosd gate_met3_via3_1  > 20000                             
        via_count = NET AREA RATIO gate_met3_via3_1  x > 0
        // connect again ??
        via_count_net = STAMP via_count BY gate_met3_via3_1
        // print via locations
        xx = NET AREA RATIO x                     via_count_net > 20000  ACCUMULATE
        NET AREA RATIO PRINT xx 'ratio_gate_via3_insufficient.txt'
        // get grafical output of net
        gate_poly1_2  =  NET AREA RATIO gate_poly1 met1_all met2_all met3_all via_count_net > 0
        gate_met1_2   =  NET AREA RATIO met1_all gate_poly1 met2_all met3_all via_count_net > 0
        gate_met2_2   =  NET AREA RATIO met2_all met1_all gate_poly1 met3_all via_count_net > 0
        gate_met3_2   =  NET AREA RATIO met3_all gate_poly1 met1_all met2_all via_count_net > 0
        ((ORNET gate_poly1_2 gate_met1_2) ORNET gate_met2_2) ORNET  gate_met3_2
        // get rdb
        NET AREA RATIO gate_met3_2 gate_met2_2 gate_met1_2 gate_poly1_2 via_count_net > 0
                 [COUNT(via_count_net) + AREA(gate_poly1_2) + AREA(gate_met1_2)+ AREA(gate_met2_2) + AREA(gate_met3_2)]
        RDB ONLY 'via_gate.rdb' gate_met3_2 gate_met2_2 gate_met1_2 gate_poly1_2 via_count_net
   }
//
#ENDIF
//
//=====================================================================
// DFM INFO : check if devices with large w and small l
// have sufficient vias for s/d  connection
//=====================================================================
// advantage : finds connection with 1 via
// this works fine with upword connections
// not so good for higher levels
// possible change : use ratio of edge/via ( ok for parallel devices), but sums up
//                   all vias
//
   DISCONNECT
//
// define any l and w for check
// can be changed
// user 50 U 
//
//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
   nw_large_exp =  ( PATH LENGTH dfm_ngate_w > 50.0 ) EXPAND EDGE INSIDE BY 0.1 CORNER FILL
   pw_large_exp =  ( PATH LENGTH dfm_pgate_w > 50.0 ) EXPAND EDGE INSIDE BY 0.1 CORNER FILL
   //nw_large_exp { COPY nw_large_exp }
   //pw_large_exp { COPY pw_large_exp }
//
   nl_large_exp =  ( PATH LENGTH dfm_ngate_l < 5.0 ) EXPAND EDGE INSIDE BY 0.1 CORNER FILL
   pl_large_exp =  ( PATH LENGTH dfm_pgate_l < 5.0 ) EXPAND EDGE INSIDE BY 0.1 CORNER FILL
   //nl_large_exp { COPY nl_large_exp }
   //pl_large_exp { COPY pl_large_exp }
//
//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//
// only device with constrains
//
   nw_large_exp1 = nw_large_exp INTERACT nl_large_exp
   pw_large_exp1 = pw_large_exp INTERACT pl_large_exp
//
   ndiff_sd_check = (dfm_ndiff_sd SIZE BY 0.05) INTERACT nw_large_exp1
   pdiff_sd_check = (dfm_pdiff_sd SIZE BY 0.05) INTERACT pw_large_exp1
//
   edge_ndiff_sd_check = nw_large_exp INTERACT ndiff_sd_check
   edge_pdiff_sd_check = pw_large_exp INTERACT pdiff_sd_check
   //edge_pdiff_sd_check { COPY edge_pdiff_sd_check }
   //edge_ndiff_sd_check { COPY edge_ndiff_sd_check }
//
   cont_ndiff_sd_check = CONT AND ndiff_sd_check
   cont_pdiff_sd_check = CONT AND pdiff_sd_check
//
   met1_ndiff_sd_check = MET1 ENCLOSE cont_ndiff_sd_check
   met1_pdiff_sd_check = MET1 ENCLOSE cont_pdiff_sd_check
//
   via_p_check = VIA INSIDE met1_pdiff_sd_check
   via_n_check = VIA INSIDE met1_ndiff_sd_check
//
//   met1_ndiff_sd_check { FLATTEN  met1_ndiff_sd_check }
//   met1_pdiff_sd_check { FLATTEN  met1_pdiff_sd_check }
//
// get overlapping met areas with 1 via only ( or more if necessary)
//
   m1m2_common = (MET1 AND MET2) NOT OUTSIDE VIA
   m1m2_via_ovlp_common    = VIA INSIDE (m1m2_common ENCLOSE VIA < 2)
   m1m2_ovlp_area_bad =  m1m2_common  ENCLOSE  m1m2_via_ovlp_common
   //m1m2_ovlp_area_bad { COPY m1m2_ovlp_area_bad }
//
   m2m3_common = (MET2 AND MET3) NOT OUTSIDE VIA2
   m2m3_via_ovlp_common    = VIA2 INSIDE (m2m3_common ENCLOSE VIA2 < 2)
   m2m3_ovlp_area_bad =  m2m3_common  ENCLOSE  m2m3_via_ovlp_common
   //m2m3_ovlp_area_bad { COPY m2m3_ovlp_area_bad }
//
#IFDEF fourmetal
   m3m4_common = (MET3 AND MET4) NOT OUTSIDE VIA3
   m3m4_via_ovlp_common    = VIA3 INSIDE (m3m4_common ENCLOSE VIA3 < 2)
   m3m4_ovlp_area_bad =  m3m4_common  ENCLOSE  m3m4_via_ovlp_common
   //m3m4_ovlp_area_bad { COPY m3m4_ovlp_area_bad }
#ENDIF
//
#DEFINE BAD_VIA_CONNECT
#IFDEF BAD_VIA_CONNECT
//
// n channel checks
//-------------------
//
   CONNECT met1_ndiff_sd_check ndiff_sd_check BY cont_ndiff_sd_check
   CONNECT ndiff_sd_check edge_ndiff_sd_check
   CONNECT met1_ndiff_sd_check  m1m2_ovlp_area_bad
//
// output net if m1m2 ovlp has only 1 via
// do this in incremental form
// UP flags connctions from lower met to higher
// second check flags all connections on net, also to lower level
// remove connections to substrate
//
// flag edge of gate w and single via
//
// only nets with ovlp
//
   INFO_NMOS_SD_VIA1_CONNECT_UP_DFM { @ INFO : one VIA1 connection on large nmos sd device
        x = NET AREA RATIO met1_ndiff_sd_check m1m2_ovlp_area_bad > 0
        m1m2_ovlp_area_bad1   = NET AREA RATIO m1m2_ovlp_area_bad  x > 0
        edge_ndiff_sd_check1  = NET AREA RATIO edge_ndiff_sd_check m1m2_ovlp_area_bad1 > 0
        FLATTEN edge_ndiff_sd_check1
        FLATTEN (m1m2_ovlp_area_bad1 NOT ( SIZE m1m2_ovlp_area_bad1 BY -0.1))
   }
//
   CONNECT met1_ndiff_sd_check  MET1
   CONNECT MET1 dfm_subtap BY dfm_diffcon_all
   CONNECT MET1 m1m2_ovlp_area_bad
   CONNECT MET2 MET1 BY VIA
   INFO_NMOS_SD_VIA1_CONNECT_ALL_DFM { @ INFO : one VIA1 connection on large nmos device
        met1_ndiff_sd_check_nosubtap = NET AREA RATIO  met1_ndiff_sd_check dfm_subtap == 0
        x = NET AREA RATIO met1_ndiff_sd_check_nosubtap m1m2_ovlp_area_bad > 0
        m1m2_ovlp_area_bad1   = NET AREA RATIO m1m2_ovlp_area_bad  x > 0
        edge_ndiff_sd_check1  = NET AREA RATIO edge_ndiff_sd_check m1m2_ovlp_area_bad1 > 0
        FLATTEN edge_ndiff_sd_check1
        FLATTEN (m1m2_ovlp_area_bad1 NOT ( SIZE m1m2_ovlp_area_bad1 BY -0.1))
   }
//
   CONNECT MET2 m2m3_ovlp_area_bad
   INFO_NMOS_SD_VIA2_CONNECT_UP_DFM { @ INFO : one VIA2 connection on large nmos sd device
        met1_ndiff_sd_check_nosubtap = NET AREA RATIO  met1_ndiff_sd_check dfm_subtap == 0
        x = NET AREA RATIO met1_ndiff_sd_check_nosubtap m2m3_ovlp_area_bad > 0
        m2m3_ovlp_area_bad1   = NET AREA RATIO m2m3_ovlp_area_bad  x > 0
        edge_ndiff_sd_check1  = NET AREA RATIO edge_ndiff_sd_check m2m3_ovlp_area_bad1 > 0
        FLATTEN (m2m3_ovlp_area_bad1 NOT ( SIZE m2m3_ovlp_area_bad1 BY -0.1))
        FLATTEN edge_ndiff_sd_check1
   }
   CONNECT MET2 MET3 BY VIA2
   INFO_NMOS_SD_VIA2_CONNECT_ALL_DFM { @ INFO : one VIA2 connection on large nmos sd device
        met1_ndiff_sd_check_nosubtap = NET AREA RATIO  met1_ndiff_sd_check dfm_subtap == 0
        x = NET AREA RATIO met1_ndiff_sd_check_nosubtap m2m3_ovlp_area_bad > 0
        m2m3_ovlp_area_bad1   = NET AREA RATIO m2m3_ovlp_area_bad  x > 0
        edge_ndiff_sd_check1  = NET AREA RATIO edge_ndiff_sd_check m2m3_ovlp_area_bad1 > 0
        FLATTEN (m2m3_ovlp_area_bad1 NOT ( SIZE m2m3_ovlp_area_bad1 BY -0.1))
        FLATTEN edge_ndiff_sd_check1
   }
#IFDEF fourmetal
   CONNECT MET3 m3m4_ovlp_area_bad
   INFO_NMOS_SD_VIA3_CONNECT_UP_DFM { @ INFO : one VIA3 connection on large nmos sd device
        met1_ndiff_sd_check_nosubtap = NET AREA RATIO  met1_ndiff_sd_check dfm_subtap == 0
        x = NET AREA RATIO met1_ndiff_sd_check_nosubtap m3m4_ovlp_area_bad > 0
        m3m4_ovlp_area_bad1   = NET AREA RATIO m3m4_ovlp_area_bad  x > 0
        edge_ndiff_sd_check1  = NET AREA RATIO edge_ndiff_sd_check m3m4_ovlp_area_bad1 > 0
        FLATTEN( m3m4_ovlp_area_bad1 NOT ( SIZE m3m4_ovlp_area_bad1 BY -0.1))
        FLATTEN  edge_ndiff_sd_check1
   }
   CONNECT MET3 MET4 BY VIA3
   INFO_NMOS_SD_VIA3_CONNECT_ALL_DFM { @ INFO : one VIA3 connection on large nmos sd device
        met1_ndiff_sd_check_nosubtap = NET AREA RATIO  met1_ndiff_sd_check dfm_subtap == 0
        x = NET AREA RATIO met1_ndiff_sd_check_nosubtap m3m4_ovlp_area_bad > 0
        m3m4_ovlp_area_bad1   = NET AREA RATIO m3m4_ovlp_area_bad  x > 0
        edge_ndiff_sd_check1  = NET AREA RATIO edge_ndiff_sd_check m3m4_ovlp_area_bad1 > 0
        FLATTEN( m3m4_ovlp_area_bad1 NOT ( SIZE m3m4_ovlp_area_bad1 BY -0.1))
        FLATTEN  edge_ndiff_sd_check1
   }
#ENDIF
//
// p channel checks
//-------------------
//
   DISCONNECT
   CONNECT met1_pdiff_sd_check pdiff_sd_check BY cont_pdiff_sd_check
   CONNECT pdiff_sd_check edge_pdiff_sd_check
   CONNECT met1_pdiff_sd_check  m1m2_ovlp_area_bad
//
   INFO_PMOS_SD_VIA1_CONNECT_UP_DFM { @ INFO : one VIA1 connection on large pmos sd device
        x = NET AREA RATIO met1_pdiff_sd_check m1m2_ovlp_area_bad > 0
        m1m2_ovlp_area_bad1   = NET AREA RATIO m1m2_ovlp_area_bad  x > 0
        edge_pdiff_sd_check1  = NET AREA RATIO edge_pdiff_sd_check m1m2_ovlp_area_bad1 > 0
        FLATTEN( m1m2_ovlp_area_bad1 NOT ( SIZE m1m2_ovlp_area_bad1 BY -0.1))
        FLATTEN edge_pdiff_sd_check1
   }
//
   CONNECT MET2 MET1 BY VIA
   CONNECT met1_pdiff_sd_check  MET1
   CONNECT MET1 dfm_welltap BY dfm_diffcon_all
   CONNECT MET1 m1m2_ovlp_area_bad
   //dfm_welltap { FLATTEN dfm_welltap }
   //met1_pdiff_sd_check { COPY met1_pdiff_sd_check }
   INFO_PMOS_SD_VIA1_CONNECT_ALL_DFM { @ INFO : one VIA1 connection on large pmos sd device
        met1_pdiff_sd_check_nowelltap = NET AREA RATIO  met1_pdiff_sd_check dfm_welltap == 0
        x = NET AREA RATIO met1_pdiff_sd_check_nowelltap m1m2_ovlp_area_bad > 0
        m1m2_ovlp_area_bad1   = NET AREA RATIO m1m2_ovlp_area_bad  x > 0
        edge_pdiff_sd_check1  = NET AREA RATIO edge_pdiff_sd_check m1m2_ovlp_area_bad1 > 0
        FLATTEN( m1m2_ovlp_area_bad1 NOT ( SIZE m1m2_ovlp_area_bad1 BY -0.1))
        FLATTEN edge_pdiff_sd_check1
   }
   CONNECT MET2 m2m3_ovlp_area_bad
   INFO_PMOS_SD_VIA2_CONNECT_UP_DFM { @ INFO : one VIA2 connection on large pmos sd device
        met1_pdiff_sd_check_nowelltap = NET AREA RATIO  met1_pdiff_sd_check dfm_welltap == 0
        x = NET AREA RATIO met1_pdiff_sd_check_nowelltap m2m3_ovlp_area_bad > 0
        m2m3_ovlp_area_bad1   = NET AREA RATIO m2m3_ovlp_area_bad  x > 0
        edge_pdiff_sd_check1  = NET AREA RATIO edge_pdiff_sd_check m2m3_ovlp_area_bad1 > 0
        FLATTEN (m2m3_ovlp_area_bad1 NOT ( SIZE m2m3_ovlp_area_bad1 BY -0.1))
        FLATTEN  edge_pdiff_sd_check1
   }
   CONNECT MET2 MET3 BY VIA2
   INFO_PMOS_SD_VIA2_CONNECT_ALL_DFM { @ INFO : one VIA2 connection on large pmos sd device
        met1_pdiff_sd_check_nowelltap = NET AREA RATIO  met1_pdiff_sd_check dfm_welltap == 0
        x = NET AREA RATIO met1_pdiff_sd_check_nowelltap m2m3_ovlp_area_bad > 0
        m2m3_ovlp_area_bad1   = NET AREA RATIO m2m3_ovlp_area_bad  x > 0
        edge_pdiff_sd_check1  = NET AREA RATIO edge_pdiff_sd_check m2m3_ovlp_area_bad1 > 0
        FLATTEN (m2m3_ovlp_area_bad1 NOT ( SIZE m2m3_ovlp_area_bad1 BY -0.1))
        FLATTEN  edge_pdiff_sd_check1
   }
#IFDEF fourmetal
//
   CONNECT MET3 m3m4_ovlp_area_bad
//
   INFO_PMOS_SD_VIA3_CONNECT_UP_DFM { @ INFO : one VIA3 connection on large pmos sd device
        met1_pdiff_sd_check_nowelltap = NET AREA RATIO  met1_pdiff_sd_check dfm_welltap == 0
        x = NET AREA RATIO met1_pdiff_sd_check_nowelltap m3m4_ovlp_area_bad > 0
        m3m4_ovlp_area_bad1   = NET AREA RATIO m3m4_ovlp_area_bad  x > 0
        edge_pdiff_sd_check1  = NET AREA RATIO edge_pdiff_sd_check m3m4_ovlp_area_bad1 > 0
        m3m4_ovlp_area_bad1 NOT ( SIZE m3m4_ovlp_area_bad1 BY -0.1)
        COPY  edge_pdiff_sd_check1
   }
   CONNECT MET3 MET4 BY VIA3
   INFO_PMOS_SD_VIA3_CONNECTALL_DFM { @ INFO : one VIA3 connection on large pmos sd device
        met1_pdiff_sd_check_nowelltap = NET AREA RATIO  met1_pdiff_sd_check dfm_welltap == 0
        x = NET AREA RATIO met1_pdiff_sd_check_nowelltap m3m4_ovlp_area_bad > 0
        m3m4_ovlp_area_bad1   = NET AREA RATIO m3m4_ovlp_area_bad  x > 0
        edge_pdiff_sd_check1  = NET AREA RATIO edge_pdiff_sd_check m3m4_ovlp_area_bad1 > 0
        m3m4_ovlp_area_bad1 NOT ( SIZE m3m4_ovlp_area_bad1 BY -0.1)
        COPY  edge_pdiff_sd_check1
   }
#ENDIF
//
// try to find parallel devices bad connected to s/d
//----------------------------------------------------
// is ok, but only edges with length above are selected 
//
   DISCONNECT
//
// check if parallel
// 20 is 50 U length, 1 via
// (length * 0.1 ) area(via)
// 1 via = 0.25 u*u
// W  * 0.1 / 0.25 = 20
//
   DISCONNECT
   CONNECT met1_pdiff_sd_check pdiff_sd_check BY cont_pdiff_sd_check
   CONNECT met1_pdiff_sd_check dfm_welltap BY dfm_diffcon_all
   CONNECT pdiff_sd_check edge_pdiff_sd_check
   CONNECT met1_pdiff_sd_check  VIA
//
// not connected to well
//
   INFO_PMOS_SD_VIA1_RATIO_DFM { @ INFO : insufficient VIA1 connection on large pmos sd device
                                 @        large device bad connected
        edge_pdiff_sd_check_nowelltap = NET AREA RATIO edge_pdiff_sd_check dfm_welltap ==0
        x = NET AREA RATIO edge_pdiff_sd_check_nowelltap VIA > 19.9
        via_bad = NET AREA RATIO VIA  x > 0
        edge_pdiff_sd_check1  = NET AREA RATIO x via_bad > 0
        FLATTEN( via_bad NOT ( SIZE via_bad BY -0.1))
        FLATTEN edge_pdiff_sd_check1
   }
//
   DISCONNECT
   CONNECT met1_ndiff_sd_check ndiff_sd_check BY cont_ndiff_sd_check
   CONNECT met1_ndiff_sd_check dfm_subtap BY dfm_diffcon_all
   CONNECT ndiff_sd_check edge_ndiff_sd_check
   CONNECT met1_ndiff_sd_check  VIA
//
// not connected to substrate
//
   INFO_NMOS_SD_VIA1_RATIO_DFM { @ INFO : insufficient VIA1 connection on large nmos sd device
                                 @        large device bad connected
        edge_ndiff_sd_check_nosubtap = NET AREA RATIO edge_ndiff_sd_check dfm_subtap ==0
        x = NET AREA RATIO edge_ndiff_sd_check_nosubtap VIA > 19.9
        via_bad = NET AREA RATIO VIA  x > 0
        edge_ndiff_sd_check1  = NET AREA RATIO x via_bad > 0
        FLATTEN( via_bad NOT ( SIZE via_bad BY -0.1))
        FLATTEN edge_ndiff_sd_check1
   }
   CONNECT MET1 met1_ndiff_sd_check
   CONNECT MET1 MET2 BY VIA
   CONNECT MET2 VIA2
   INFO_NMOS_SD_VIA2_RATIO_DFM { @ INFO : insufficient VIA2 connection on large nmos sd device
                                 @        large device bad connected
        edge_ndiff_sd_check_nosubtap = NET AREA RATIO edge_ndiff_sd_check dfm_subtap ==0
        x = NET AREA RATIO edge_ndiff_sd_check_nosubtap VIA2 > 19.9
        via_bad = NET AREA RATIO VIA2  x > 0
        edge_ndiff_sd_check1  = NET AREA RATIO x via_bad > 0
        FLATTEN( via_bad NOT ( SIZE via_bad BY -0.1))
        FLATTEN edge_ndiff_sd_check1
   }
//
#ENDIF
//
//=====================================================================
// DFM0065/DFM0066  Miniumum coverage of NMOSM gate edge with (NLDD50 -0.7 U ps) = 50 %
// DFM0065/DFM0066  Miniumum coverage of NMOSML gate edge with (NLDD50 -0.7 U ps) = 50 %
// only NLDD50 edges parallel to transistor L edges are biased
// This rule does not apply to gate edges with NLDD50 extension > 1.4 U
//=====================================================================
// check is split up in more pieces and also for analogue trans L >=1
//
// nmosm/nmosml is not extra separated
//
    nmosm_1_nldd50dfm = MIDOX NOT NTUB
    nmosm_2_nldd50dfm = nmosm_1_nldd50dfm AND POLY1
    nmosm_3_nldd50dfm =  nmosm_2_nldd50dfm AND NPLUS
    nmos_midox_nldd50dfm = nmosm_3_nldd50dfm AND DIFF
//
    nmosm_sd_diff = ndiff TOUCH nmos_midox_nldd50dfm
    nmos_midox_w  = nmos_midox_nldd50dfm COINCIDENT INSIDE EDGE POLY1
    nmos_midox_w_edgeexp = nmos_midox_w EXPAND EDGE OUTSIDE BY 0.1
//
//  nmos_midox_w_edgeexp { COPY  nmos_midox_w_edgeexp }
//
    nmos_midox_diff_edge_1 = TOUCH EDGE DIFF nmos_midox_nldd50dfm
    nmos_midox_diff_edge_l =  nmos_midox_diff_edge_1 NOT INSIDE EDGE POLY1
//    nmos_midox_diff_edge_l { COPY  nmos_midox_diff_edge_l }
//
    nldd50_bias_0 =  NLDD50 OR ( MIDOX AND NPLUS)
//
    nldd50_ovlp_region =  ENC  nmos_midox_diff_edge_l  nldd50_bias_0 < 1.5 REGION PARALLEL OPPOSITE
//    nldd50_ovlp_region { COPY nldd50_ovlp_region }
    nldd50_ovlp_edge =  nldd50_ovlp_region COIN EDGE nldd50_bias_0
//    nldd50_ovlp_edge { COPY  nldd50_ovlp_edge }
//
// 1.)  if nldd50 ovl parallel to w edge is 1.4 or larger ...drop this device independant of w
//      generate region for AND
//
    nldd50_ovlp_region_w =  ENC  nmos_midox_w  nldd50_bias_0 <= 1.4 REGION PARALLEL OPPOSITE
//    nldd50_ovlp_region_w { COPY nldd50_ovlp_region_w }
//
// 2.) shielding is 0.7
//
    nldd50_ovlp_edge_exp = EXPAND EDGE nldd50_ovlp_edge INSIDE BY 0.7
//    nldd50_ovlp_edge_exp { COPY nldd50_ovlp_edge_exp  }
//
    nldd50_ovlp_edge_exp_x =  (nldd50_bias_0 NOT nldd50_ovlp_edge_exp) NOT POLY1
//    nldd50_ovlp_edge_exp_x { COPY  nldd50_ovlp_edge_exp_x }
//
// add nldd50 if exists on data
//
//XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//
   nmosm_sd_diff_bias_0 = (nmosm_sd_diff AND  nldd50_bias_0) AND nldd50_ovlp_edge_exp_x
//   nmosm_sd_diff_bias_0 { COPY  nmosm_sd_diff_bias_0 }
//
// gate edge does not see nldd50 implant 45 degree
//
// all gate edge
     nmosm_sd_diff_bias_0_edge = nmosm_sd_diff_bias_0  COINCIDENT  OUTSIDE EDGE nmos_midox_nldd50dfm
     nmosm_sd_diff_bias_0_edgeexp =  nmosm_sd_diff_bias_0_edge EXPAND EDGE INSIDE BY 0.1 CORNER FILL
//     nmosm_sd_diff_bias_0_edgeexp { COPY  nmosm_sd_diff_bias_0_edgeexp }
//
// if bias edge exists get w edge
// get w edge interacting bias edge
//
    nmos_midox_w_edgeexp_bias_0 = nmos_midox_w_edgeexp INTERACT nmosm_sd_diff_bias_0_edgeexp
   WIDTH_NMOSM_NLDD50_0_DFM0065 { @ DFM0065/DFM0066  Miniumum coverage of NMOSM/NMOSML gate edge with (NLDD50 -0.7 U ps) = 50 %
                                 @ gate edge no nldd50 45deg implant
                                 @ this problem is solved during mask generation by
                                 @  NLDD50 = ((DIFF AND NPLUS) AND MIDOX) SIZE BY 0.6
         //nmos_midox_w_edgeexp NOT INTERACT nmosm_sd_diff_bias_0
         // only error if nldd50 ovlp is < 1.4
         (nmos_midox_w_edgeexp NOT INTERACT nmosm_sd_diff_bias_0) AND  nldd50_ovlp_region_w
    }
//
    CONNECT nmos_midox_w_edgeexp_bias_0 nmosm_sd_diff_bias_0_edgeexp
//
//============================================================================================================
//
//  split check up in :
//
//  - 0%
//  < 20%
//  < 40%
//  < 50%
//
// DFM0065/DFM0066  Miniumum coverage of NMOSM gate edge with (NLDD50 -0.7 U ps) = 50 %
//
    WIDTH_NMOSM_NLDD50_LT05_DFM0065 { @  DFM0065/DFM0066  Miniumum coverage of NMOSM/NMOSML gate edge with (NLDD50 -0.7 U ps) = 50 %
                                    @  W/W(nldd50 45deg implant)  < 0.5
                                 @ this problem is solved during mask generation by
                                 @  NLDD50 = ((DIFF AND NPLUS) AND MIDOX) SIZE BY 0.6
         x = NET AREA RATIO  nmosm_sd_diff_bias_0_edgeexp nmos_midox_w_edgeexp_bias_0 < 0.5
         // only error if nldd50 ovlp is < 1.4
         x AND nldd50_ovlp_region_w
         //xx = NET AREA RATIO  nmosm_sd_diff_bias_0_edgeexp  nmos_midox_w_edgeexp_bias_0  < 0.5 ACCUMULATE
         //NET AREA RATIO PRINT xx 'nmosm_nldd50_05.txt'
    }
    WIDTH_NMOSM_NLDD50_LT04_DFM0065 { @  DFM0065/DFM0066  Miniumum coverage of NMOSM/NMOSML gate edge with (NLDD50 -0.7 U ps) = 50 %
                                    @  W/W(nldd50 45deg implant)  < 0.4
                                 @ this problem is solved during mask generation by
                                 @  NLDD50 = ((DIFF AND NPLUS) AND MIDOX) SIZE BY 0.6
         x = NET AREA RATIO  nmosm_sd_diff_bias_0_edgeexp nmos_midox_w_edgeexp_bias_0 < 0.4
         // only error if nldd50 ovlp is < 1.4
         x AND nldd50_ovlp_region_w
         //xx = NET AREA RATIO  nmosm_sd_diff_bias_0_edgeexp  nmos_midox_w_edgeexp_bias_0  < 0.4 ACCUMULATE
         //NET AREA RATIO PRINT xx 'nmosm_nldd50_04.txt'
    }
    WIDTH_NMOSM_NLDD50_LT02_DFM0065 { @  DFM0065/DFM0066  Miniumum coverage of NMOSM/NMOSML gate edge with (NLDD50 -0.7 U ps) = 50 %
                                    @  W/W(nldd50 45deg implant)  < 0.2
                                 @ this problem is solved during mask generation by
                                 @  NLDD50 = ((DIFF AND NPLUS) AND MIDOX) SIZE BY 0.6
         x = NET AREA RATIO  nmosm_sd_diff_bias_0_edgeexp nmos_midox_w_edgeexp_bias_0 < 0.2
         // only error if nldd50 ovlp is < 1.4
         x AND nldd50_ovlp_region_w
         //xx = NET AREA RATIO  nmosm_sd_diff_bias_0_edgeexp  nmos_midox_w_edgeexp_bias_0  < 0.2 ACCUMULATE
         //NET AREA RATIO PRINT xx 'nmosm_nldd50_02.txt'
    }
//
//============================================================================================================
//
// same check for devices L >=1 U
//
    nmos_midox_nldd50dfm_l =  nmos_midox_nldd50dfm COINCIDENT INSIDE EDGE DIFF
    nmos_midox_nldd50dfm_l_10  = (LENGTH nmos_midox_nldd50dfm_l >= 1.0) EXPAND EDGE BY 0.1
    nmos_midox_nldd50dfm_analog = nmos_midox_nldd50dfm INTERACT nmos_midox_nldd50dfm_l_10 
//
    WIDTH_NMOSM_ANALOG_NLDD50_0_DFM0065 { @ DFM0065/DFM0066  Miniumum coverage of NMOSM/NMOSML gate edge with (NLDD50 -0.7 U ps) = 50 %
                                        @ gate edge no nldd50 45deg implant and L >= 1 U
                                 @ this problem is solved during mask generation by
                                 @  NLDD50 = ((DIFF AND NPLUS) AND MIDOX) SIZE BY 0.6
         x = (nmos_midox_w_edgeexp NOT INTERACT nmosm_sd_diff_bias_0) AND  nldd50_ovlp_region_w
         x INTERACT nmos_midox_nldd50dfm_analog
    }
//
    WIDTH_NMOSM_ANALOG_NLDD50_LT05_DFM0065 { @ DFM0065/DFM0066  Miniumum coverage of NMOSM/NMOSML gate edge with (NLDD50 -0.7 U ps) = 50 %
                                           @  W/W(nldd50 45deg implant)  < 0.5 and L >=1 U
                                 @ this problem is solved during mask generation by
                                 @  NLDD50 = ((DIFF AND NPLUS) AND MIDOX) SIZE BY 0.6
         x = NET AREA RATIO  nmosm_sd_diff_bias_0_edgeexp nmos_midox_w_edgeexp_bias_0 < 0.5
         (x AND nldd50_ovlp_region_w) INTERACT nmos_midox_nldd50dfm_analog
    }
    WIDTH_NMOSM_ANALOG_NLDD50_LT04_DFM0065 { @ DFM0065/DFM0066  Miniumum coverage of NMOSM/NMOSML gate edge with (NLDD50 -0.7 U ps) = 50 %
                                           @  W/W(nldd50 45deg implant)  < 0.4 and L >=1 U
                                 @ this problem is solved during mask generation by
                                 @  NLDD50 = ((DIFF AND NPLUS) AND MIDOX) SIZE BY 0.6
         x = NET AREA RATIO  nmosm_sd_diff_bias_0_edgeexp nmos_midox_w_edgeexp_bias_0 < 0.4
         (x AND nldd50_ovlp_region_w) INTERACT nmos_midox_nldd50dfm_analog
    }
    WIDTH_NMOSM_ANALOG_NLDD50_LT02_DFM0065 { @ DFM0065/DFM0066  Miniumum coverage of NMOSM/NMOSML gate edge with (NLDD50 -0.7 U ps) = 50 %
                                           @  W/W(nldd50 45deg implant)  < 0.2 and L >=1 U
                                 @ this problem is solved during mask generation by
                                 @  NLDD50 = ((DIFF AND NPLUS) AND MIDOX) SIZE BY 0.6
         x = NET AREA RATIO  nmosm_sd_diff_bias_0_edgeexp nmos_midox_w_edgeexp_bias_0 < 0.2
         (x AND nldd50_ovlp_region_w) INTERACT nmos_midox_nldd50dfm_analog
    }
//
//============================================================================================================
//============================================================================================================
// not used
#UNDEFINE OPTIONAL_OUTPUT
#IFDEF OPTIONAL_OUTPUT
//
    ILL_NMOSM_NLDD50_GTEQ09_LT10 { @          ... W/W(nldd50 45deg implant)  >=0.9 < 0.99
         x = NET AREA RATIO  nmosm_sd_diff_bias_0_edgeexp nmos_midox_w_edgeexp_bias_0 >=0.9 < 0.99
         x AND nldd50_ovlp_region_w
         //xx = NET AREA RATIO  nmosm_sd_diff_bias_0_edgeexp  nmos_midox_w_edgeexp_bias_0  < 0.9 ACCUMULATE
         //NET AREA RATIO PRINT xx 'nmosm_bias0_09.txt'
    }
//
    ILL_NMOSM_NLDD50_GTEQ08_LT09 { @          ... W/W(nldd50 45deg implant)  >= 0.8 < 0.9
         x = NET AREA RATIO  nmosm_sd_diff_bias_0_edgeexp nmos_midox_w_edgeexp_bias_0 >= 0.8 < 0.9
         x AND nldd50_ovlp_region_w
         //xx = NET AREA RATIO  nmosm_sd_diff_bias_0_edgeexp  nmos_midox_w_edgeexp_bias_0  < 0.8 ACCUMULATE
         //NET AREA RATIO PRINT xx 'nmosm_bias0_08.txt'
    }
//
    ILL_NMOSM_NLDD50_GTEQ07_LT08 { @          ... W/W(nldd50 45deg implant)  >= 0.7 < 0.8
         x = NET AREA RATIO  nmosm_sd_diff_bias_0_edgeexp nmos_midox_w_edgeexp_bias_0 >= 0.7 < 0.8
         x AND nldd50_ovlp_region_w
         //xx = NET AREA RATIO  nmosm_sd_diff_bias_0_edgeexp  nmos_midox_w_edgeexp_bias_0  < 0.7 ACCUMULATE
         //NET AREA RATIO PRINT xx 'nmosm_bias0_07.txt'
    }
//
    ILL_NMOSM_NLDD50_GTEQ06_LT07 { @          ... W/W(nldd50 45deg implant) >= 0.6 < 0.7
         x = NET AREA RATIO  nmosm_sd_diff_bias_0_edgeexp nmos_midox_w_edgeexp_bias_0 >= 0.6 < 0.7
         x AND nldd50_ovlp_region_w
         //xx = NET AREA RATIO  nmosm_sd_diff_bias_0_edgeexp  nmos_midox_w_edgeexp_bias_0  < 0.6 ACCUMULATE
         //NET AREA RATIO PRINT xx 'nmosm_bias0_06.txt'
    }
//
    ILL_NMOSM_NLDD50_GTEQ05_LT06 { @          ... W/W(nldd50 45deg implant) >= 0.5 < 0.6
         x = NET AREA RATIO  nmosm_sd_diff_bias_0_edgeexp nmos_midox_w_edgeexp_bias_0 >= 0.5 < 0.6
         x AND nldd50_ovlp_region_w
         //xx = NET AREA RATIO  nmosm_sd_diff_bias_0_edgeexp  nmos_midox_w_edgeexp_bias_0  < 0.5 ACCUMULATE
         //NET AREA RATIO PRINT xx 'nmosm_bias0_05.txt'
    }
//
    ILL_NMOSM_NLDD50_GTEQ04_LT05 { @          ... W/W(nldd50 45deg implant)  >=0.4 < 0.5
         x = NET AREA RATIO  nmosm_sd_diff_bias_0_edgeexp nmos_midox_w_edgeexp_bias_0 >=0.4 < 0.5
         x AND nldd50_ovlp_region_w
         //xx = NET AREA RATIO  nmosm_sd_diff_bias_0_edgeexp  nmos_midox_w_edgeexp_bias_0  < 0.4 ACCUMULATE
         //NET AREA RATIO PRINT xx 'nmosm_bias0_04.txt'
    }
//
    ILL_NMOSM_NLDD50_GTEQ03_LT04 { @          ... W/W(nldd50 45deg implant)  >=0.3 < 0.4
         x = NET AREA RATIO  nmosm_sd_diff_bias_0_edgeexp nmos_midox_w_edgeexp_bias_0 >=0.3 < 0.4
         x AND nldd50_ovlp_region_w
         //xx = NET AREA RATIO  nmosm_sd_diff_bias_0_edgeexp  nmos_midox_w_edgeexp_bias_0  < 0.4 ACCUMULATE
         //NET AREA RATIO PRINT xx 'nmosm_bias0_04.txt'
    }
    ILL_NMOSM_NLDD50_GTEQ02_LT03 { @          ... W/W(nldd50 45deg implant)  >=0.2 < 0.3
         x = NET AREA RATIO  nmosm_sd_diff_bias_0_edgeexp nmos_midox_w_edgeexp_bias_0 >=0.2 < 0.3
         x AND nldd50_ovlp_region_w
         //xx = NET AREA RATIO  nmosm_sd_diff_bias_0_edgeexp  nmos_midox_w_edgeexp_bias_0  < 0.4 ACCUMULATE
         //NET AREA RATIO PRINT xx 'nmosm_bias0_04.txt'
    }
    ILL_NMOSM_NLDD50_GTEQ01_LT02 { @          ... W/W(nldd50 45deg implant) >=0.1 < 0.2
         x = NET AREA RATIO  nmosm_sd_diff_bias_0_edgeexp nmos_midox_w_edgeexp_bias_0 >=0.1 < 0.2
         x AND nldd50_ovlp_region_w
         //xx = NET AREA RATIO  nmosm_sd_diff_bias_0_edgeexp  nmos_midox_w_edgeexp_bias_0  < 0.4 ACCUMULATE
         //NET AREA RATIO PRINT xx 'nmosm_bias0_04.txt'
    }
    ILL_NMOSM_NLDD50_GT00_LT01 { @          ... W/W(nldd50 45deg implant)  >=0.01 < 0.1
         x = NET AREA RATIO  nmosm_sd_diff_bias_0_edgeexp nmos_midox_w_edgeexp_bias_0 >=0.01 < 0.1
         x AND nldd50_ovlp_region_w
         //xx = NET AREA RATIO  nmosm_sd_diff_bias_0_edgeexp  nmos_midox_w_edgeexp_bias_0  < 0.4 ACCUMULATE
         //NET AREA RATIO PRINT xx 'nmosm_bias0_04.txt'
    }
//
#ENDIF
//============================================================================================================
//============================================================================================================
///////////////////////////////////////////////////////////////////////
//
//                  end of DFM part2 checks
//
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
//
//      end of techfile   end of techfile    end of techfile         //
//
///////////////////////////////////////////////////////////////////////

