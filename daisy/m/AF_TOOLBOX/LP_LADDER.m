	function [L, C, Wo, K] = LP_LADDER(ZinNum, ZinDen, Z, P)	%	% 	Computes the element values in a lowpass LC ladder filter with finite zeros. 	%	Uses the transmission zeros and input impedance (ZinNum/ZinDen) of the ladder 	%	for the synthesis. 	%	The vector K defines the LC sections, see LADDER-2_H	%	% 	Toolbox for ANALOG FILTERS USING MATLAB, Springer, 2009		%	Author: 		Lars Wanhammar 2007-08-26    %	Copyright:		Divison of Electronics Systems	%					Dept. Electrical Engineering, Linkoping University, Sweden						%	Modified by: 		 	%	Version: 		1			%	Known bugs:		 	%	Report bugs to:	larsw@isy.liu.se		Z(imag(Z) < 0) = [];	%	Remove any "negative" transmission zeros	% ==============================	%	The order of the transmission zeros may be changed to get 	%	an equivalent ladder, but with different element values.		% =====================================	for j = 1:length(Z) 		winv(j) = -1/Z(j)^2;		Wo(j) = abs(Z(j));	end	winv = cat(2, winv,[0]);	Lx = zeros(length(winv));	B = Lx;	for k = 1:length(winv)		if winv(k) ~= 0			Den = POLY_AT_X(ZinDen, Z(k));			Num = POLY_AT_X(ZinNum, Z(k));			Lx(k, 1) = real(Num/(Den*Z(k)));			% Compute the shunt inductors, Lshunt = (Zin_prim - Lseries)/2			N_prim = POLY_AT_X(POLY_PRIM(ZinNum), Z(k));			D_prim = POLY_AT_X(POLY_PRIM(ZinDen), Z(k));			Z_prim = (N_prim*Den - D_prim*Num)/Den^2;			Lshunt(k, 1) = real((Z_prim - Lx(k,1))/2);			B(k, 1) = Lshunt(k, 1)*abs(Z(k))^2;	%	Compute the shunt capacitor		else			Lx(k, 1) = real(ZinNum(1)/ZinDen(1));	% A transmission zero at s = °			B(k, 1) = (ZinNum(3) - Lx(k, 1)*ZinDen(3))/ZinDen(1);			Lshunt(k, 1) = 0;		end	end	%	==========================================	%	Perform Amstutz permutations	for k = 2:length(winv)		% For the remaining transmission zeros		for m = k:length(winv)	% Combine section m with j where j > m			for j = m:length(winv)				U = Lx(m-1, m-1) - Lx(j, k-1);				V = 1/(U/(B(m-1, m-1)*(winv(j)-winv(m-1))) - 1);				Lx(j, m) = U*V;				B(j, m) = B(j, m-1)*(V^2) - B(m-1, m-1)*(1+V)^2;			end 		end	end	for j = 1:length(winv)		L(2*j-1) = Lx(j, j);		K(2*j-1) = 2;		end	for j = 1:length(winv)-(mod(length(P), 2) == 1)		C(2*j) = 1/B(j, j);		C(2*j+1) = 0;		L(2*j) = winv(j)*B(j, j);			if (L(2*j) == 0)			K(2*j) = 9;		else			K(2*j) = 10;		end	end